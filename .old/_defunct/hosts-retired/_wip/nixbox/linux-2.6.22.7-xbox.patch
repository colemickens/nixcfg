diff -uprN a/arch/i386/Kconfig b/arch/i386/Kconfig
--- a/arch/i386/Kconfig	2007-07-09 00:32:17.000000000 +0100
+++ b/arch/i386/Kconfig	2007-10-12 11:17:00.000000000 +0100
@@ -192,6 +192,15 @@ config X86_VISWS
 	  A kernel compiled for the Visual Workstation will not run on PCs
 	  and vice versa. See <file:Documentation/sgi-visws.txt> for details.
 
+config X86_XBOX
+	bool "Xbox (Microsoft)"
+	help
+	  Xbox is a standard PC from Microsoft minus some legacy hardware.
+	  More info may be gleaned from <http://xbox-linux.sourceforge.net/>.
+
+	  Only choose this option if you are building a kernel for such a
+	  machine, otherwise choose "PC-compatible".
+
 config X86_GENERICARCH
        bool "Generic architecture (Summit, bigsmp, ES7000, default)"
        help
@@ -1131,7 +1140,7 @@ config ISA_DMA_API
 
 config ISA
 	bool "ISA support"
-	depends on !(X86_VOYAGER || X86_VISWS)
+	depends on !(X86_VOYAGER || X86_VISWS || X86_XBOX)
 	help
 	  Find out whether you have ISA slots on your motherboard.  ISA is the
 	  name of a bus system, i.e. the way the CPU talks to the other stuff
@@ -1158,7 +1167,7 @@ config EISA
 source "drivers/eisa/Kconfig"
 
 config MCA
-	bool "MCA support" if !(X86_VISWS || X86_VOYAGER)
+	bool "MCA support" if !(X86_VISWS || X86_VOYAGER || X86_XBOX)
 	default y if X86_VOYAGER
 	help
 	  MicroChannel Architecture is found in some IBM PS/2 machines and
@@ -1254,17 +1263,17 @@ config GENERIC_PENDING_IRQ
 
 config X86_SMP
 	bool
-	depends on SMP && !X86_VOYAGER
+	depends on SMP && !(X86_VOYAGER || X86_XBOX)
 	default y
 
 config X86_HT
 	bool
-	depends on SMP && !(X86_VISWS || X86_VOYAGER)
+	depends on SMP && !(X86_VISWS || X86_VOYAGER || X86_XBOX)
 	default y
 
 config X86_BIOS_REBOOT
 	bool
-	depends on !(X86_VISWS || X86_VOYAGER)
+	depends on !(X86_VISWS || X86_VOYAGER || X86_XBOX)
 	default y
 
 config X86_TRAMPOLINE
diff -uprN a/arch/i386/Makefile b/arch/i386/Makefile
--- a/arch/i386/Makefile	2007-09-23 18:33:00.000000000 +0100
+++ b/arch/i386/Makefile	2007-10-12 11:17:00.000000000 +0100
@@ -31,7 +31,7 @@ LDFLAGS_vmlinux := --emit-relocs
 endif
 CHECKFLAGS	+= -D__i386__
 
-CFLAGS += -pipe -msoft-float -mregparm=3 -freg-struct-return
+CFLAGS += -pipe -mregparm=3 -freg-struct-return
 
 # prevent gcc from keeping the stack 16 byte aligned
 CFLAGS += $(call cc-option,-mpreferred-stack-boundary=2)
@@ -71,6 +71,10 @@ mcore-$(CONFIG_X86_VOYAGER)	:= mach-voya
 mflags-$(CONFIG_X86_VISWS)	:= -Iinclude/asm-i386/mach-visws
 mcore-$(CONFIG_X86_VISWS)	:= mach-visws
 
+# Xbox subarch support
+mflags-$(CONFIG_X86_XBOX)	:= -Iinclude/asm-i386/mach-xbox
+mcore-$(CONFIG_X86_XBOX)	:= mach-xbox
+
 # NUMAQ subarch support
 mflags-$(CONFIG_X86_NUMAQ)	:= -Iinclude/asm-i386/mach-numaq
 mcore-$(CONFIG_X86_NUMAQ)	:= mach-default
diff -uprN a/arch/i386/boot/compressed/Makefile b/arch/i386/boot/compressed/Makefile
--- a/arch/i386/boot/compressed/Makefile	2007-07-09 00:32:17.000000000 +0100
+++ b/arch/i386/boot/compressed/Makefile	2007-10-12 11:17:00.000000000 +0100
@@ -6,6 +6,17 @@
 
 targets		:= vmlinux vmlinux.bin vmlinux.bin.gz head.o misc.o piggy.o \
 			vmlinux.bin.all vmlinux.relocs
+
+#
+# There is some strange interaction when paging is off, that makes
+# newer v1.1+ Xboxen (manufactured August 2002 or later) crash while
+# decrompressing the kernel. Compiling the decrompressor without any
+# optimization reliably works around this problem.
+#
+ifeq ($(CONFIG_X86_XBOX),y)
+CFLAGS_misc.o   := -O0
+endif
+
 EXTRA_AFLAGS	:= -traditional
 
 LDFLAGS_vmlinux := -T
diff -uprN a/arch/i386/configs/xbox_defconfig b/arch/i386/configs/xbox_defconfig
--- a/arch/i386/configs/xbox_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/i386/configs/xbox_defconfig	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,1346 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.16
+# Thu Apr  6 13:11:30 2006
+#
+CONFIG_X86_32=y
+CONFIG_SEMAPHORE_SLEEPERS=y
+CONFIG_X86=y
+CONFIG_MMU=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_DMI=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION="-xbox"
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_UID16=y
+CONFIG_VM86=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_SLAB=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Processor type and features
+#
+# CONFIG_X86_PC is not set
+# CONFIG_X86_ELAN is not set
+# CONFIG_X86_VOYAGER is not set
+# CONFIG_X86_NUMAQ is not set
+# CONFIG_X86_SUMMIT is not set
+# CONFIG_X86_BIGSMP is not set
+# CONFIG_X86_VISWS is not set
+CONFIG_X86_XBOX=y
+# CONFIG_X86_GENERICARCH is not set
+# CONFIG_X86_ES7000 is not set
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+# CONFIG_M586 is not set
+# CONFIG_M586TSC is not set
+# CONFIG_M586MMX is not set
+# CONFIG_M686 is not set
+# CONFIG_MPENTIUMII is not set
+CONFIG_MPENTIUMIII=y
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+# CONFIG_MK8 is not set
+# CONFIG_MCRUSOE is not set
+# CONFIG_MEFFICEON is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP2 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MGEODEGX1 is not set
+# CONFIG_MGEODE_LX is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_X86_GENERIC is not set
+CONFIG_X86_CMPXCHG=y
+CONFIG_X86_XADD=y
+CONFIG_X86_L1_CACHE_SHIFT=5
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_GOOD_APIC=y
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_TSC=y
+# CONFIG_HPET_TIMER is not set
+# CONFIG_SMP is not set
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_BKL=y
+CONFIG_X86_UP_APIC=y
+CONFIG_X86_UP_IOAPIC=y
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_MCE=y
+# CONFIG_X86_MCE_NONFATAL is not set
+# CONFIG_X86_MCE_P4THERMAL is not set
+# CONFIG_TOSHIBA is not set
+# CONFIG_I8K is not set
+# CONFIG_X86_REBOOTFIXUPS is not set
+# CONFIG_MICROCODE is not set
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_NOHIGHMEM=y
+# CONFIG_HIGHMEM4G is not set
+# CONFIG_HIGHMEM64G is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_MATH_EMULATION is not set
+CONFIG_MTRR=y
+# CONFIG_REGPARM is not set
+CONFIG_SECCOMP=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+# CONFIG_KEXEC is not set
+CONFIG_PHYSICAL_START=0x100000
+CONFIG_DOUBLEFAULT=y
+
+#
+# Power management options (ACPI, APM)
+#
+# CONFIG_PM is not set
+
+#
+# ACPI (Advanced Configuration and Power Interface) Support
+#
+# CONFIG_ACPI is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+# CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
+CONFIG_PCI_GODIRECT=y
+# CONFIG_PCI_GOANY is not set
+CONFIG_PCI_DIRECT=y
+# CONFIG_PCIEPORTBUS is not set
+# CONFIG_PCI_MSI is not set
+# CONFIG_PCI_LEGACY_PROC is not set
+CONFIG_ISA_DMA_API=y
+# CONFIG_SCx200 is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_BINFMT_AOUT=m
+CONFIG_BINFMT_MISC=m
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=m
+CONFIG_INET_TCP_DIAG=m
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+# CONFIG_BLK_DEV_HD_IDE is not set
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDEDISK_MULTI_MODE=y
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_CMD640 is not set
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_BLK_DEV_OPTI621 is not set
+# CONFIG_BLK_DEV_RZ1000 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+CONFIG_IDEDMA_PCI_AUTO=y
+# CONFIG_IDEDMA_ONLYDISK is not set
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+CONFIG_BLK_DEV_AMD74XX=y
+# CONFIG_BLK_DEV_ATIIXP is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_CS5535 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SIS5513 is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=m
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=m
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+CONFIG_FORCEDETH=m
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_SONYPI is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_CS5535_GPIO is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_HANGCHECK_TIMER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+CONFIG_I2C_XBOX=m
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_RTC_X1205_I2C is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=m
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+# CONFIG_IBM_ASM is not set
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=m
+CONFIG_FB_CFB_FILLRECT=m
+CONFIG_FB_CFB_COPYAREA=m
+CONFIG_FB_CFB_IMAGEBLIT=m
+# CONFIG_FB_MACMODES is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_VIDEO_SELECT is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+CONFIG_FB_XBOX=m
+# CONFIG_FB_I810 is not set
+# CONFIG_FB_INTEL is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON_OLD is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_CYBLA is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_GEODE is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=m
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=m
+CONFIG_SND_TIMER=m
+CONFIG_SND_PCM=m
+CONFIG_SND_SEQUENCER=m
+# CONFIG_SND_SEQ_DUMMY is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_SEQUENCER_OSS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+CONFIG_SND_AC97_CODEC=m
+CONFIG_SND_AC97_BUS=m
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_VIRMIDI is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# PCI devices
+#
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS4000 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+# CONFIG_SND_HDA_INTEL is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+CONFIG_SND_INTEL8X0=m
+CONFIG_SND_INTEL8X0M=m
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+
+#
+# USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_USX2Y is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_OBSOLETE_OSS_USB_DRIVER is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+CONFIG_USB_XPAD=m
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_ATI_REMOTE2 is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+# CONFIG_EDAC is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_FATX_FS=y
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+CONFIG_XBOX_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Instrumentation Support
+#
+# CONFIG_PROFILING is not set
+# CONFIG_KPROBES is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_X86_FIND_SMP_CONFIG=y
+CONFIG_X86_MPPARSE=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_KTIME_SCALAR=y
diff -uprN a/arch/i386/mach-xbox/Makefile b/arch/i386/mach-xbox/Makefile
--- a/arch/i386/mach-xbox/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/i386/mach-xbox/Makefile	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y				:= setup.o reboot.o reset-on-eject.o
diff -uprN a/arch/i386/mach-xbox/reboot.c b/arch/i386/mach-xbox/reboot.c
--- a/arch/i386/mach-xbox/reboot.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/i386/mach-xbox/reboot.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,68 @@
+/*
+ * arch/i386/mach-xbox/reboot.c 
+ *
+ * Power-off/reboot mach hooks.
+ * 
+ * Copyright (C) 2003  Olivier Fauchon <olivier.fauchon@free.fr>
+ * Copyright (C) 2003  Anders Gustafsson <andersg@0x63.nu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <asm/io.h>
+
+#define XBOX_SMB_IO_BASE		0xC000
+#define XBOX_SMB_HOST_ADDRESS		(0x4 + XBOX_SMB_IO_BASE)
+#define XBOX_SMB_HOST_COMMAND		(0x8 + XBOX_SMB_IO_BASE)
+#define XBOX_SMB_HOST_DATA		(0x6 + XBOX_SMB_IO_BASE)
+#define XBOX_SMB_GLOBAL_ENABLE		(0x2 + XBOX_SMB_IO_BASE)
+
+#define XBOX_PIC_ADDRESS		0x10
+
+#define SMC_CMD_POWER			0x02
+#define SMC_SUBCMD_POWER_RESET		0x01
+#define SMC_SUBCMD_POWER_CYCLE		0x40
+#define SMC_SUBCMD_POWER_OFF		0x80
+
+
+void (*pm_power_off)(void);
+EXPORT_SYMBOL(pm_power_off);
+
+static void xbox_pic_cmd(u8 command)
+{
+	outw_p(((XBOX_PIC_ADDRESS) << 1), XBOX_SMB_HOST_ADDRESS);
+	outb_p(SMC_CMD_POWER, XBOX_SMB_HOST_COMMAND);
+	outw_p(command, XBOX_SMB_HOST_DATA);
+	outw_p(inw(XBOX_SMB_IO_BASE), XBOX_SMB_IO_BASE);
+	outb_p(0x0a, XBOX_SMB_GLOBAL_ENABLE);
+}
+
+void machine_emergency_restart(void)
+{
+	xbox_pic_cmd(SMC_SUBCMD_POWER_CYCLE);  
+}
+
+void machine_restart(char *cmd)
+{
+	machine_emergency_restart();
+}
+
+void machine_shutdown(void)
+{
+	/* Subarch-specific shutdown prior to a kexec */
+}
+
+void machine_power_off(void)
+{
+	xbox_pic_cmd(SMC_SUBCMD_POWER_OFF);  
+}
+
+void machine_halt(void)
+{
+	/* Lalee Forced Halts to Shut Off */
+	xbox_pic_cmd(SMC_SUBCMD_POWER_OFF);  
+}
diff -uprN a/arch/i386/mach-xbox/reset-on-eject.c b/arch/i386/mach-xbox/reset-on-eject.c
--- a/arch/i386/mach-xbox/reset-on-eject.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/i386/mach-xbox/reset-on-eject.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,146 @@
+/**
+ * Driver that handles the EXTSMI# interrupt on the xbox.
+ * Makes it possible to use the eject-button without the xbox rebooting...
+ *
+ * smbus-command sequence to prevent reboot from cromwell.
+ *
+ * Changelog:
+ *  2003-01-14 Anders Gustafsson <andersg@0x63.nu>
+ *             initial version
+ *  2003-02-08 Milosch Meriac <xboxlinux@meriac.de>
+ *             rewrote debug macros because of compiler errors
+ *  2003-08-06 Michael Steil <mist@c64.org>
+ *             removed Linux I2C dependency, now compiles
+ *             without I2C in the kernel
+ *
+ * Todo: add errorhandling!
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/xbox.h>
+#include <linux/interrupt.h>
+
+#define IRQ 12
+#define DRIVER_NAME "xboxejectfix"
+
+/* just some crap */
+static char dev[]=DRIVER_NAME;
+
+/* External variable from ide-cd.c that specifies whether we simulate drive
+   locking in software */
+extern volatile int Xbox_simulate_drive_locked;
+
+#define BASE 0x8000
+
+/* Power Management 1 Enable Register */
+#define PM02 (BASE+0x02)
+
+/* Power Management 1 Control Register */
+#define PM04 (BASE+0x04)
+
+/* ACPI GP Status Register */
+#define PM20 (BASE+0x20)
+
+/* ACPI GP Enable Register */
+#define PM22 (BASE+0x22)
+# define EXTSMI_EN_MASK 0x0002
+
+/* Global SMI Enable Register */
+#define PM2A (BASE+0x2A)
+
+
+static DECLARE_MUTEX(extsmi_sem);
+static DECLARE_COMPLETION(extsmi_exited);
+static int extsmi_pid=0;
+
+static irqreturn_t extsmi_interrupt(int unused, void *dev_id) {
+	int reason;
+
+	reason=inw(0x8020);
+	outw(reason,0x8020); /* ack  IS THIS NEEDED? */
+	if(reason&0x2){
+		/* wake up thread */
+		up(&extsmi_sem);
+	}
+	return 0;
+}
+
+/**
+ * Process an event. This is run in process-context.
+ */
+static void extsmi_process(void){
+	int reason;
+	reason=Xbox_SMC_read(SMC_CMD_INTERRUPT_REASON);
+
+	if(reason&TRAYBUTTON_MASK){ /* Tray button! Respond to prevent reboot! */
+		Xbox_SMC_write(SMC_CMD_INTERRUPT_RESPOND, SMC_SUBCMD_RESPOND_CONTINUE);
+		Xbox_SMC_write(0x00, 0x0c);
+		/* eject unless lock simulation is being used */
+		if (!Xbox_simulate_drive_locked)
+			Xbox_tray_eject();
+	}
+}
+
+static int extsmi_thread(void *data){
+	daemonize("extsmi");
+	strcpy(current->comm, "xbox_extsmi");
+
+	do {
+		extsmi_process();
+		down_interruptible(&extsmi_sem);
+	} while (!signal_pending(current));
+	
+         complete_and_exit(&extsmi_exited, 0);
+}
+
+static int extsmi_init(void){
+	int pid;
+	
+	if (!machine_is_xbox) {
+		printk("This machine is no Xbox.\n");
+		return -1;
+	}
+	printk("Enabling Xbox eject problem workaround.\n");
+
+        pid = kernel_thread(extsmi_thread, NULL,
+			    CLONE_FS | CLONE_FILES | CLONE_SIGHAND);
+	if (pid < 0) {
+		return pid;
+	}
+
+	extsmi_pid = pid;
+
+	/* this shuts a lot of interrupts off! */
+	outw(inw(0x80e2)&0xf8c7,0x80e2);
+	outw(0,0x80ac);
+	outb(0,0x8025);
+	outw(EXTSMI_EN_MASK,PM22); /* enable the EXTSMI# interrupt! */
+	outw(0,PM02);
+	outb(1,PM04); /* enable sci interrupts! */
+	Xbox_SMC_write(SMC_CMD_RESET_ON_EJECT, SMC_SUBCMD_RESET_ON_EJECT_DISABLE);
+
+	/* FIXME! retval! */
+	request_irq(IRQ,extsmi_interrupt,IRQF_DISABLED|IRQF_SHARED,"xboxejectfix",dev);
+	return 0;
+}
+
+static void extsmi_exit(void){
+	int res;
+	if (!machine_is_xbox) return; /* can this happen??? */
+	free_irq(IRQ,dev);
+
+	/* Kill the thread */
+	res = kill_proc(extsmi_pid, SIGTERM, 1);
+	wait_for_completion(&extsmi_exited);
+	return;
+}
+
+module_init(extsmi_init);
+module_exit(extsmi_exit);
+
+MODULE_AUTHOR("Anders Gustafsson <andersg@0x63.nu>");
+MODULE_LICENSE("GPL");
diff -uprN a/arch/i386/mach-xbox/setup.c b/arch/i386/mach-xbox/setup.c
--- a/arch/i386/mach-xbox/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/i386/mach-xbox/setup.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,133 @@
+/*
+ *	Machine specific setup for xbox
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <asm/acpi.h>
+#include <asm/arch_hooks.h>
+#include <asm/e820.h>
+#include <asm/setup.h>
+/**
+ * pre_intr_init_hook - initialisation prior to setting up interrupt vectors
+ *
+ * Description:
+ *	Perform any necessary interrupt initialisation prior to setting up
+ *	the "ordinary" interrupt call gates.  For legacy reasons, the ISA
+ *	interrupts should be initialised here if the machine emulates a PC
+ *	in any way.
+ **/
+void __init pre_intr_init_hook(void)
+{
+	init_ISA_irqs();
+}
+
+/*
+ * IRQ2 is cascade interrupt to second interrupt controller
+ */
+static struct irqaction irq2 = {
+	.handler	= no_action,
+	.flags		= 0,
+	.mask		= CPU_MASK_NONE,
+	.name		= "cascade",
+};
+
+/**
+ * intr_init_hook - post gate setup interrupt initialisation
+ *
+ * Description:
+ *	Fill in any interrupts that may have been left out by the general
+ *	init_IRQ() routine.  interrupts having to do with the machine rather
+ *	than the devices on the I/O bus (like APIC interrupts in intel MP
+ *	systems) are started here.
+ **/
+void __init intr_init_hook(void)
+{
+#ifdef CONFIG_X86_LOCAL_APIC
+	apic_intr_init();
+#endif
+	if (!acpi_ioapic)
+		setup_irq(2, &irq2);
+}
+
+/**
+ * pre_setup_arch_hook - hook called prior to any setup_arch() execution
+ *
+ * Description:
+ *	generally used to activate any machine specific identification
+ *	routines that may be needed before setup_arch() runs.  On VISWS
+ *	this is used to get the board revision and type.
+ **/
+void __init pre_setup_arch_hook(void)
+{
+}
+
+/**
+ * trap_init_hook - initialise system specific traps
+ *
+ * Description:
+ *	Called as the final act of trap_init().  Used in VISWS to initialise
+ *	the various board specific APIC traps.
+ **/
+void __init trap_init_hook(void)
+{
+}
+
+static struct irqaction irq0  = {
+	.handler	= timer_interrupt,
+	.flags		= IRQF_DISABLED,
+	.mask		= CPU_MASK_NONE,
+	.name		= "timer",
+};
+
+/**
+ * time_init_hook - do any specific initialisations for the system timer.
+ *
+ * Description:
+ *	Must plug the system timer interrupt source at HZ into the IRQ listed
+ *	in irq_vectors.h:TIMER_IRQ
+ **/
+void __init time_init_hook(void)
+{
+	setup_irq(0, &irq0);
+}
+
+
+/**
+ * machine_specific_memory_setup - Hook for machine specific memory setup.
+ *
+ * Description:
+ *      This is included late in kernel/setup.c so that it can make
+ *      use of all of the static functions.
+ **/
+
+char * __init machine_specific_memory_setup(void)
+{
+        char *who;
+        who = "BIOS-e820";
+        /*
+         * Try to copy the BIOS-supplied E820-map.
+         *
+         * Otherwise fake a memory map; one section from 0k->640k,
+         * the next section from 1mb->appropriate_mem_k
+         */
+        sanitize_e820_map(E820_MAP, &E820_MAP_NR);
+        if (copy_e820_map(E820_MAP, E820_MAP_NR) < 0) {
+                unsigned long mem_size;
+
+                /* compare results from other methods and take the greater */
+                if (ALT_MEM_K < EXT_MEM_K) {
+                        mem_size = EXT_MEM_K;
+                        who = "BIOS-88";
+                } else {
+                        mem_size = ALT_MEM_K;
+                        who = "BIOS-e801";
+                }
+
+                e820.nr_map = 0;
+                add_memory_region(0, LOWMEMSIZE(), E820_RAM);
+                add_memory_region(HIGH_MEMORY, mem_size << 10, E820_RAM);
+        }
+        return who;
+}
diff -uprN a/arch/i386/pci/direct.c b/arch/i386/pci/direct.c
--- a/arch/i386/pci/direct.c	2007-07-09 00:32:17.000000000 +0100
+++ b/arch/i386/pci/direct.c	2007-10-12 11:17:00.000000000 +0100
@@ -5,6 +5,7 @@
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <linux/dmi.h>
+#include "mach_pci_blacklist.h"
 #include "pci.h"
 
 /*
@@ -24,6 +25,9 @@ int pci_conf1_read(unsigned int seg, uns
 		return -EINVAL;
 	}
 
+        if (mach_pci_is_blacklisted(bus, PCI_SLOT(devfn), PCI_FUNC(devfn)))
+                return -EINVAL;
+
 	spin_lock_irqsave(&pci_config_lock, flags);
 
 	outl(PCI_CONF1_ADDRESS(bus, devfn, reg), 0xCF8);
diff -uprN a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
--- a/drivers/i2c/busses/Kconfig	2007-09-23 18:33:00.000000000 +0100
+++ b/drivers/i2c/busses/Kconfig	2007-10-12 11:17:00.000000000 +0100
@@ -63,6 +63,10 @@ config I2C_AMD756_S4882
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-amd756-s4882.
 
+config I2C_XBOX
+	tristate "XBOX I2C"
+	depends on X86_XBOX && I2C && PCI && EXPERIMENTAL
+
 config I2C_AMD8111
 	tristate "AMD 8111"
 	depends on PCI
diff -uprN a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
--- a/drivers/i2c/busses/Makefile	2007-09-23 18:33:00.000000000 +0100
+++ b/drivers/i2c/busses/Makefile	2007-10-12 11:17:00.000000000 +0100
@@ -7,6 +7,7 @@ obj-$(CONFIG_I2C_ALI1563)	+= i2c-ali1563
 obj-$(CONFIG_I2C_ALI15X3)	+= i2c-ali15x3.o
 obj-$(CONFIG_I2C_AMD756)	+= i2c-amd756.o
 obj-$(CONFIG_I2C_AMD756_S4882)	+= i2c-amd756-s4882.o
+obj-$(CONFIG_I2C_XBOX)		+= i2c-xbox.o
 obj-$(CONFIG_I2C_AMD8111)	+= i2c-amd8111.o
 obj-$(CONFIG_I2C_AT91)		+= i2c-at91.o
 obj-$(CONFIG_I2C_AU1550)	+= i2c-au1550.o
diff -uprN a/drivers/i2c/busses/i2c-xbox.c b/drivers/i2c/busses/i2c-xbox.c
--- a/drivers/i2c/busses/i2c-xbox.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/i2c/busses/i2c-xbox.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,413 @@
+/*
+    i2c-xbox.c - Part of lm_sensors, Linux kernel modules for hardware
+              monitoring
+
+    Copyright (c) 1999-2002 Edgar Hucek <hostmaster@ed-soft.at>
+
+    Shamelessly ripped from i2c-xbox.c:
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+/*
+   Supports XBOX, Note: we assume there can only be one device, with one SMBus interface.
+*/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <linux/kernel.h>
+#include <linux/stddef.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+
+#include <linux/sched.h>
+#include <linux/errno.h>  /* error codes */
+#include <linux/interrupt.h> /* intr_count */
+#include <linux/xbox.h>
+#include <linux/delay.h>
+
+
+#define GS_ABRT_STS (1 << 0)
+#define GS_COL_STS (1 << 1)
+#define GS_PRERR_STS (1 << 2)
+#define GS_HST_STS (1 << 3)
+#define GS_IRQ_ON (1 << 4)
+#define GS_HCYC_STS (1 << 4)
+#define GS_TO_STS (1 << 5)
+#define GS_SMB_STS (1 << 11)
+
+#define SMB_GCTL_HOST_START      (1 << 3)
+#define SMB_GCTL_HOST_INTERRUPT  (1 << 4)
+#define SMB_GCTL_ABORT           (1 << 5)
+#define SMB_GCTL_SNOOP           (1 << 8)
+#define SMB_GCTL_SLAVE_INTERRUPT (1 << 9)
+#define SMB_GCTL_ALERT_INTERRUPT (1 << 10)
+
+#define GS_CLEAR_STS (GS_ABRT_STS | GS_COL_STS | GS_PRERR_STS | \
+  GS_HCYC_STS | GS_TO_STS)
+
+#define GE_CYC_TYPE_MASK (7)
+#define GE_HOST_STC (1 << 3)
+#define GE_ABORT (1 << 5)
+
+#define I2C_HW_SMBUS_XBOX   0x05
+#define SMBGCFG   0x041          /* mh */
+#define SMBBA     0x058           /* mh */
+
+struct sd {
+    const unsigned short vendor;
+    const unsigned short device;
+    const unsigned short function;
+    const char* name;
+    int amdsetup:1;
+};
+
+static struct sd supported[] = {
+    {PCI_VENDOR_ID_NVIDIA, 0x01b4, 1, "nVidia XBOX nForce", 0},
+    {0, 0, 0}
+};
+
+/* XBOX SMBus address offsets */
+#define SMB_ADDR_OFFSET        0x04
+#define SMB_IOSIZE             8
+#define SMB_GLOBAL_STATUS      (0x0 + xbox_smba)
+#define SMB_GLOBAL_ENABLE      (0x2 + xbox_smba)
+#define SMB_HOST_ADDRESS       (0x4 + xbox_smba)
+#define SMB_HOST_DATA          (0x6 + xbox_smba)
+#define SMB_HOST_COMMAND       (0x8 + xbox_smba)
+
+
+
+
+
+/* Other settings */
+#define MAX_TIMEOUT 500
+
+/* XBOX constants */
+#define XBOX_QUICK        0x00
+#define XBOX_BYTE         0x01
+#define XBOX_BYTE_DATA    0x02
+#define XBOX_WORD_DATA    0x03
+#define XBOX_PROCESS_CALL 0x04
+#define XBOX_BLOCK_DATA   0x05
+
+/* insmod parameters */
+
+#ifdef MODULE
+static
+#else
+extern
+#endif
+int __init i2c_xbox_init(void);
+static int __init xbox_cleanup(void);
+static int xbox_setup(void);
+static s32 xbox_access(struct i2c_adapter *adap, u16 addr,
+			 unsigned short flags, char read_write,
+			 u8 command, int size, union i2c_smbus_data *data);
+static void xbox_do_pause(unsigned int amount);
+static void xbox_abort(void);
+static int xbox_transaction(void);
+static u32 xbox_func(struct i2c_adapter *adapter);
+
+static struct i2c_algorithm smbus_algorithm = {
+   .master_xfer = NULL,
+   .smbus_xfer = xbox_access, 
+   .algo_control = NULL,
+   .functionality = xbox_func,
+};
+
+static struct i2c_adapter xbox_adapter = {
+	.owner          = THIS_MODULE,
+	.class          = I2C_CLASS_HWMON,
+	.algo           = &smbus_algorithm,
+	.name           = "unset",
+};
+
+static int __initdata xbox_initialized;
+static unsigned short xbox_smba = 0;
+spinlock_t xbox_driver_lock = SPIN_LOCK_UNLOCKED;
+struct driver_data;
+static struct pci_dev *XBOX_dev;
+
+/* Detect whether a XBOX can be found, and initialize it, where necessary.
+   Note the differences between kernels with the old PCI BIOS interface and
+   newer kernels with the real PCI interface. In compat.h some things are
+   defined to make the transition easier. */
+int xbox_setup(void)
+{
+	unsigned char temp;
+	struct sd *currdev;
+	u16 cmd;
+
+	XBOX_dev = NULL;
+
+	/* Look for a supported chip */
+	for(currdev = supported; currdev->vendor; ) {
+		XBOX_dev = pci_get_device(currdev->vendor,
+						currdev->device, XBOX_dev);
+		if (XBOX_dev != NULL)	{
+	                pci_read_config_byte(XBOX_dev, SMBGCFG, &temp);
+			pci_read_config_word(XBOX_dev, 0x14, &xbox_smba);
+			
+			xbox_smba &= 0xfffc;
+			if (PCI_FUNC(XBOX_dev->devfn) == currdev->function)
+			{
+				pci_read_config_word(XBOX_dev,PCI_STATUS,&cmd);
+				break;
+			}
+		} else {
+		    currdev++;
+		}
+	}
+
+	if (XBOX_dev == NULL) {
+		printk
+		    ("i2c-xbox.o: Error: No XBOX or compatible device detected!\n");
+		return(-ENODEV);
+	}
+	printk(KERN_INFO "i2c-xbox.o: Found %s SMBus controller.\n", currdev->name);
+
+	/* Everything is happy, let's grab the memory and set things up. */
+	if(!request_region(xbox_smba, SMB_IOSIZE, "xbox-smbus")) {
+		printk
+		    ("i2c-xbox.o: SMB region 0x%x already in use!\n",
+		     xbox_smba);
+		return(-ENODEV);
+	}
+
+	return 0;
+}
+
+/* 
+  SMBUS event = I/O 28-29 bit 11
+     see E0 for the status bits and enabled in E2
+     
+*/
+
+/* Internally used pause function */
+void xbox_do_pause(unsigned int amount)
+{
+	current->state = TASK_INTERRUPTIBLE;
+	schedule_timeout(amount);
+}
+
+void xbox_abort(void)
+{
+	printk("i2c-xbox.o: Sending abort.\n");
+	outw_p(inw(SMB_GLOBAL_ENABLE) | GE_ABORT, SMB_GLOBAL_ENABLE);
+	xbox_do_pause(100);
+	outw_p(GS_CLEAR_STS, SMB_GLOBAL_STATUS);
+}
+
+int xbox_transaction(void)
+{
+	int temp;
+	int result = 0;
+	int timeout = 0;
+
+	/* Make sure the SMBus host is ready to start transmitting */
+	if ((temp = inw_p(SMB_GLOBAL_STATUS)) & (GS_HST_STS | GS_SMB_STS)) {
+		do {
+			udelay(100);
+			temp = inw_p(SMB_GLOBAL_STATUS);
+		} while ((temp & (GS_HST_STS | GS_SMB_STS)) &&
+		         (timeout++ < MAX_TIMEOUT));
+		/* If the SMBus is still busy, we give up */
+		if (timeout >= MAX_TIMEOUT) {
+			printk("i2c-xbox.o: Busy wait timeout! (%04x)\n", temp);
+			xbox_abort();
+			return(-1);
+		}
+		timeout = 0;
+	}
+
+	/* start the transaction by setting the start bit */
+	outw_p(inw(SMB_GLOBAL_ENABLE) | GE_HOST_STC , SMB_GLOBAL_ENABLE);
+
+	/* We will always wait for a fraction of a second! */
+	temp = inw_p(SMB_GLOBAL_STATUS);
+	while ((temp & GS_HST_STS) && (timeout++ < MAX_TIMEOUT)) {
+		udelay(100);
+		temp = inw_p(SMB_GLOBAL_STATUS);		
+	} 
+
+	/* If the SMBus is still busy, we give up */
+	if (timeout >= MAX_TIMEOUT) {
+		printk("i2c-xbox.o: Completion timeout!\n");
+		xbox_abort ();
+		return(-1);
+	}
+
+	if (temp & GS_PRERR_STS) {
+		result = -1;
+	}
+
+	if (temp & GS_COL_STS) {
+		result = -1;
+		printk("i2c-xbox.o: SMBus collision!\n");
+	}
+
+	if (temp & GS_TO_STS) {
+		result = -1;
+	}
+	outw_p(GS_CLEAR_STS, SMB_GLOBAL_STATUS);
+
+	return result;
+}
+
+/* Return -1 on error. */
+s32 xbox_access(struct i2c_adapter * adap, u16 addr,
+		  unsigned short flags, char read_write,
+		  u8 command, int size, union i2c_smbus_data * data)
+{
+  /** TODO: Should I supporte the 10-bit transfers? */
+	switch (size) {
+	case I2C_SMBUS_PROC_CALL:
+		printk
+		    ("i2c-xbox.o: I2C_SMBUS_PROC_CALL not supported!\n");
+		/* TODO: Well... It is supported, I'm just not sure what to do here... */
+		return -1;
+	case I2C_SMBUS_QUICK:
+		outw_p(((addr & 0x7f) << 1) | (read_write & 0x01),
+		       SMB_HOST_ADDRESS);
+		size = XBOX_QUICK;
+		break;
+	case I2C_SMBUS_BYTE:
+		outw_p(((addr & 0x7f) << 1) | (read_write & 0x01),
+		       SMB_HOST_ADDRESS);
+		/* TODO: Why only during write? */
+		if (read_write == I2C_SMBUS_WRITE)
+			outb_p(command, SMB_HOST_COMMAND);
+		size = XBOX_BYTE;
+		break;
+	case I2C_SMBUS_BYTE_DATA:
+		outw_p(((addr & 0x7f) << 1) | (read_write & 0x01),
+		       SMB_HOST_ADDRESS);
+		outb_p(command, SMB_HOST_COMMAND);
+		if (read_write == I2C_SMBUS_WRITE)
+			outw_p(data->byte, SMB_HOST_DATA);
+		size = XBOX_BYTE_DATA;
+		break;
+	case I2C_SMBUS_WORD_DATA:
+		outw_p(((addr & 0x7f) << 1) | (read_write & 0x01),
+		       SMB_HOST_ADDRESS);
+		outb_p(command, SMB_HOST_COMMAND);
+		if (read_write == I2C_SMBUS_WRITE)
+			outw_p(data->word, SMB_HOST_DATA);	/* TODO: endian???? */
+		size = XBOX_WORD_DATA;
+		break;
+	}
+
+	/* How about enabling interrupts... */
+	outw_p(size & GE_CYC_TYPE_MASK, SMB_GLOBAL_ENABLE);
+
+	if (xbox_transaction())	/* Error in transaction */
+		return -1;
+
+	if ((read_write == I2C_SMBUS_WRITE) || (size == XBOX_QUICK))
+		return 0;
+
+
+	switch (size) {
+	case XBOX_BYTE:
+		data->byte = inw_p(SMB_HOST_DATA);
+		break;
+	case XBOX_BYTE_DATA:
+		data->byte = inw_p(SMB_HOST_DATA);
+		break;
+	case XBOX_WORD_DATA:
+		data->word = inw_p(SMB_HOST_DATA);	/* TODO: endian???? */
+		break;
+	}
+
+	return 0;
+}
+
+u32 xbox_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
+	    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
+	    I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_PROC_CALL;
+}
+
+int __init i2c_xbox_init(void)
+{
+	int res;
+	printk("i2c-xbox.o version 0.0.1\n");
+	xbox_initialized = 0;
+	if ((res = xbox_setup())) {
+		printk
+		    ("i2c-xbox.o: XBOX or compatible device not detected, module not inserted.\n");
+		xbox_cleanup();
+		return res;
+	}
+	xbox_initialized++;
+	sprintf(xbox_adapter.name, "SMBus adapter at %04x",xbox_smba);
+	if ((res = i2c_add_adapter(&xbox_adapter))) {
+		printk
+		    ("i2c-xbox.o: Adapter registration failed, module not inserted.\n");
+		xbox_cleanup();
+		return res;
+	}
+	xbox_initialized++;
+	printk("i2c-xbox.o: SMBus bus detected and initialized\n");
+	return 0;
+}
+
+int __init xbox_cleanup(void)
+{
+	int res;
+	if (xbox_initialized >= 2) {
+		if ((res = i2c_del_adapter(&xbox_adapter))) {
+			printk
+			    ("i2c-xbox.o: i2c_del_adapter failed, module not removed\n");
+			return res;
+		} else
+			xbox_initialized--;
+	}
+	if (xbox_initialized >= 1) {
+		release_region(xbox_smba, SMB_IOSIZE);
+		xbox_initialized--;
+	}
+	free_irq(XBOX_dev->irq, XBOX_dev);
+	return 0;
+}
+
+EXPORT_SYMBOL(i2c_xbox_init);
+
+#ifdef MODULE
+
+MODULE_AUTHOR("Edgar Hucek <hostmaster@ed-soft.at>");
+MODULE_DESCRIPTION("XBOX nForce SMBus driver");
+
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif
+
+int init_module(void)
+{
+	return i2c_xbox_init();
+}
+
+void cleanup_module(void)
+{
+	xbox_cleanup();
+}
+
+#endif				/* MODULE */
diff -uprN a/drivers/ide/ide-cd.c b/drivers/ide/ide-cd.c
--- a/drivers/ide/ide-cd.c	2007-07-09 00:32:17.000000000 +0100
+++ b/drivers/ide/ide-cd.c	2007-10-12 11:17:00.000000000 +0100
@@ -352,6 +352,14 @@ static void ide_cd_put(struct cdrom_info
 	mutex_unlock(&idecd_ref_mutex);
 }
 
+#ifdef CONFIG_X86_XBOX
+#include <linux/xbox.h>
+/* Global flag indicating whether to simulate Xbox drive locking in
+ * software.  There should only be one Xbox drive in a system!  This
+ * variable is externally referenced by arch/i386/kernel/xboxejectfix.c. */
+volatile int Xbox_simulate_drive_locked = 0;
+#endif /* CONFIG_X86_XBOX */
+
 /****************************************************************************
  * Generic packet command support and error handling routines.
  */
@@ -2147,6 +2155,16 @@ cdrom_lockdoor(ide_drive_t *drive, int l
 	if (sense == NULL)
 		sense = &my_sense;
 
+#ifdef CONFIG_X86_XBOX
+        /* If we're on an Xbox and this is an Xbox drive, simulate the lock
+           request in software.  (See arch/i386/kernel/xboxejectfix.c) */
+        if (CDROM_CONFIG_FLAGS(drive)->xbox_drive && machine_is_xbox) {
+                CDROM_STATE_FLAGS(drive)->door_locked = lockflag;
+                Xbox_simulate_drive_locked = lockflag;
+                return 0;
+        }
+#endif /* CONFIG_X86_XBOX */
+
 	/* If the drive cannot lock the door, just pretend. */
 	if (CDROM_CONFIG_FLAGS(drive)->no_doorlock) {
 		stat = 0;
@@ -2195,6 +2213,23 @@ static int cdrom_eject(ide_drive_t *driv
 	if (CDROM_STATE_FLAGS(drive)->door_locked && ejectflag)
 		return 0;
 
+#ifdef CONFIG_X86_XBOX
+        /* Older Xbox DVD drives don't understand the ATAPI command, but the SMC
+           can do the eject.  Note that some Xbox drives support the eject
+           command, namely the Samsung, so for that drive we do a regular eject
+           sequence. */
+        if (machine_is_xbox && CDROM_CONFIG_FLAGS(drive)->xbox_drive &&
+                CDROM_CONFIG_FLAGS(drive)->xbox_eject) {
+                if (ejectflag) {
+                        Xbox_tray_load();
+                } else {
+                        Xbox_simulate_drive_locked = 0;
+                        Xbox_tray_eject();
+                }
+                return 0;
+        }
+#endif
+
 	cdrom_prepare_request(drive, &req);
 
 	/* only tell drive to close tray if open, if it can do that */
@@ -3248,6 +3283,61 @@ int ide_cdrom_setup (ide_drive_t *drive)
                  /* uses CD in slot 0 when value is set to 3 */
                  cdi->sanyo_slot = 3;
         }
+
+#ifdef CONFIG_X86_XBOX
+        /* THOMSON DVD drives in the Xbox report incorrect capabilities
+           and do not understand the ATAPI eject command, but the SMC
+           can do the eject. */
+        else if ((strcmp(drive->id->model, "THOMSON-DVD") == 0)) {
+                CDROM_CONFIG_FLAGS(drive)->audio_play = 1;
+                CDROM_CONFIG_FLAGS(drive)->dvd = 1;
+                CDROM_CONFIG_FLAGS(drive)->xbox_drive = 1;
+                CDROM_CONFIG_FLAGS(drive)->xbox_eject = 1;
+        }
+        /* PHILIPS drives in Xboxen manufactured pre September 2003,
+           report correct capabilities, but do not understand the ATAPI
+           eject command, hence require the SMC to do so. */
+        else if ((strcmp(drive->id->model, "PHILIPS XBOX DVD DRIVE") == 0)) {
+                CDROM_CONFIG_FLAGS(drive)->xbox_drive = 1;
+                CDROM_CONFIG_FLAGS(drive)->xbox_eject = 1;
+        }
+        /* PHILIPS drives in Xboxen manufactured post September 2003,
+           report incorrect capabilities, but understand the ATAPI
+           eject command. */
+        else if ((strcmp(drive->id->model, "PHILIPS J5 3235C") == 0)) {
+                CDROM_CONFIG_FLAGS(drive)->audio_play = 1;
+                CDROM_CONFIG_FLAGS(drive)->dvd = 1;
+                CDROM_CONFIG_FLAGS(drive)->xbox_drive = 1;
+                CDROM_CONFIG_FLAGS(drive)->xbox_eject = 0;
+        }
+        /* SAMSUNG drives in the Xbox report correct capabilities
+           and understand the ATAPI eject command. */
+        else if (strcmp(drive->id->model, "SAMSUNG DVD-ROM SDG-605B") == 0) {
+                CDROM_CONFIG_FLAGS(drive)->xbox_drive = 1;
+                CDROM_CONFIG_FLAGS(drive)->xbox_eject = 0;
+        }
+
+        if (CDROM_CONFIG_FLAGS(drive)->xbox_drive) {
+                /* If an Xbox drive is present in a regular PC, we can't eject.
+                   Act like the drive cannot eject, unless the ATAPI eject command
+                   is supported by the drive.  If the drive doesn't support ATAPI
+                   ejecting, act like door locking is impossible as well. */
+                if (!machine_is_xbox) {
+                        CDROM_CONFIG_FLAGS(drive)->no_doorlock = CDROM_CONFIG_FLAGS
+                                (drive)->xbox_eject;
+                        CDROM_CONFIG_FLAGS(drive)->no_eject = CDROM_CONFIG_FLAGS(drive)
+                                ->xbox_eject;
+                } else {
+                        /* An Xbox drive in an Xbox.  We can support ejecting through
+                           the SMC and support drive locking in software by ignoring
+                           the eject interrupt (see arch/i386/kernel/xboxejectfix.c). */
+                        CDROM_CONFIG_FLAGS(drive)->no_doorlock = 0;
+                        CDROM_CONFIG_FLAGS(drive)->no_eject = 0;
+                        Xbox_simulate_drive_locked = 0;
+                }
+        }
+#endif
+
 #endif /* not STANDARD_ATAPI */
 
 	info->toc		= NULL;
diff -uprN a/drivers/ide/ide-cd.h b/drivers/ide/ide-cd.h
--- a/drivers/ide/ide-cd.h	2007-09-23 18:33:00.000000000 +0100
+++ b/drivers/ide/ide-cd.h	2007-10-12 11:17:00.000000000 +0100
@@ -91,6 +91,10 @@ struct ide_cd_config_flags {
 	__u8 close_tray		: 1; /* can close the tray */
 	__u8 writing		: 1; /* pseudo write in progress */
 	__u8 mo_drive		: 1; /* drive is an MO device */
+#ifdef CONFIG_X86_XBOX
+        __u8 xbox_drive         : 1; /* drive is an Xbox drive */
+        __u8 xbox_eject         : 1; /* use Xbox SMC eject mechanism */
+#endif
 	__u8 reserved		: 2;
 	byte max_speed;		     /* Max speed of the drive */
 };
diff -uprN a/drivers/video/Kconfig b/drivers/video/Kconfig
--- a/drivers/video/Kconfig	2007-07-09 00:32:17.000000000 +0100
+++ b/drivers/video/Kconfig	2007-10-12 11:17:00.000000000 +0100
@@ -937,6 +937,20 @@ config FB_RIVA_DEBUG
 	  of debugging information to provide to the maintainer when
 	  something goes wrong.
 
+config FB_XBOX
+	tristate "nVidia Xbox support"
+	depends on FB && PCI && I2C_XBOX && EXPERIMENTAL
+	select FB_MODE_HELPERS
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This driver supports the graphics chip of the Microsoft Xbox.
+	  Say Y if you have an Xbox, N otherwise
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called xboxfb.
+
 config FB_RIVA_BACKLIGHT
 	bool "Support for backlight control"
 	depends on FB_RIVA
diff -uprN a/drivers/video/Makefile b/drivers/video/Makefile
--- a/drivers/video/Makefile	2007-07-09 00:32:17.000000000 +0100
+++ b/drivers/video/Makefile	2007-10-12 11:17:00.000000000 +0100
@@ -37,6 +37,7 @@ obj-$(CONFIG_FB_PM3)		  += pm3fb.o
 
 obj-$(CONFIG_FB_MATROX)		  += matrox/
 obj-$(CONFIG_FB_RIVA)		  += riva/
+obj-$(CONFIG_FB_XBOX)		  += xbox/ vgastate.o
 obj-$(CONFIG_FB_NVIDIA)		  += nvidia/
 obj-$(CONFIG_FB_ATY)		  += aty/ macmodes.o
 obj-$(CONFIG_FB_ATY128)		  += aty/ macmodes.o
diff -uprN a/drivers/video/xbox/Makefile b/drivers/video/xbox/Makefile
--- a/drivers/video/xbox/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/Makefile	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,7 @@
+#
+# Makefile for the Xbox framebuffer driver
+#
+
+obj-$(CONFIG_FB_XBOX) += xboxfb.o
+
+xboxfb-objs := fbdev.o riva_hw.o nv_driver.o encoder-i2c.o encoder.o conexant.o focus.o xcalibur.o
diff -uprN a/drivers/video/xbox/conexant.c b/drivers/video/xbox/conexant.c
--- a/drivers/video/xbox/conexant.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/conexant.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,656 @@
+/*
+ * linux/drivers/video/riva/conexant.c - Xbox driver for conexant chip
+ *
+ * Maintainer: Oliver Schwartz <Oliver.Schwartz@gmx.de>
+ *
+ * Contributors:
+ * 
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * Known bugs and issues:
+ *
+ *      none
+ */
+
+#include "conexant.h"
+#include "focus.h"
+#include <asm/i387.h>
+
+#define ADR(x) (x / 2 - 0x17)
+
+typedef struct {
+	long v_activeo;
+	long v_linesi;
+	long h_clki;
+	long h_clko;
+	long h_blanki;
+	long h_blanko;
+	long v_blanki;
+	long v_blanko;
+	long vscale;
+	double clk_ratio;
+} xbox_tv_mode_parameter;
+
+
+	// and here is all the video timing for every standard
+
+static const conexant_video_parameter vidstda[] = {
+	{ 3579545.00, 0.0000053, 0.00000782, 0.0000047, 0.000063555, 0.0000094, 0.000035667, 0.0000015, 243, 262.5, 0.0000092 },
+	{ 3579545.00, 0.0000053, 0.00000782, 0.0000047, 0.000064000, 0.0000094, 0.000035667, 0.0000015, 243, 262.5, 0.0000092 },
+	{ 4433618.75, 0.0000056, 0.00000785, 0.0000047, 0.000064000, 0.0000105, 0.000036407, 0.0000015, 288, 312.5, 0.0000105 },
+	{ 4433618.75, 0.0000056, 0.00000785, 0.0000047, 0.000064000, 0.0000094, 0.000035667, 0.0000015, 288, 312.5, 0.0000092 },
+	{ 3582056.25, 0.0000056, 0.00000811, 0.0000047, 0.000064000, 0.0000105, 0.000036407, 0.0000015, 288, 312.5, 0.0000105 },
+	{ 3575611.88, 0.0000058, 0.00000832, 0.0000047, 0.000063555, 0.0000094, 0.000035667, 0.0000015, 243, 262.5, 0.0000092 },
+	{ 4433619.49, 0.0000053, 0.00000755, 0.0000047, 0.000063555, 0.0000105, 0.000036407, 0.0000015, 243, 262.5, 0.0000092 }
+};
+
+static const unsigned char default_mode[] = {
+	0x00,
+	0x00, 0x28, 0x80, 0xE4, 0x00, 0x00, 0x80, 0x80,
+	0x80, 0x13, 0xDA, 0x4B, 0x28, 0xA3, 0x9F, 0x25,
+	0xA3, 0x9F, 0x25, 0x00, 0x00, 0x00, 0x00, 0x44,
+	0xC7, 0x00, 0x00, 0x41, 0x35, 0x03, 0x46, 0x00,
+	0x02, 0x00, 0x01, 0x60, 0x88, 0x8a, 0xa6, 0x68,
+	0xc1, 0x2e, 0xf2, 0x27, 0x00, 0xb0, 0x0a, 0x0b,
+	0x71, 0x5a, 0xe0, 0x36, 0x00, 0x50, 0x72, 0x1c,
+	0x0d, 0x24, 0xf0, 0x58, 0x81, 0x49, 0x8c, 0x0c,
+	0x8c, 0x79, 0x26, 0x52, 0x00, 0x24, 0x00, 0x00,
+	0x00, 0x00, 0x01, 0x9C, 0x9B, 0xC0, 0xC0, 0x19,
+	0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x57, 0x20,
+	0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05,
+	0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, 0x00
+};
+
+static const double pll_base = 13.5e6;
+
+static void conexant_calc_blankings(
+	xbox_video_mode * mode,
+	xbox_tv_mode_parameter * param
+);
+
+static int conexant_calc_mode_params(
+	xbox_video_mode * mode,
+	xbox_tv_mode_parameter * param
+);
+
+static double fabs(double d) {
+	if (d > 0) return d;
+	else return -d;
+}
+
+int conexant_calc_vga_mode(
+	xbox_av_type av_type,
+	int dotClock,
+	void **encoder_regs
+){
+	unsigned char *regs;
+	unsigned char pll_int = (unsigned char)((double)dotClock * 6.0 / 13.5e3 + 0.5);
+	*encoder_regs = kmalloc(NUM_CONEXANT_REGS*sizeof(char), GFP_KERNEL);
+	regs = (unsigned char*)*encoder_regs;
+	memset(regs, 0, NUM_CONEXANT_REGS);
+	// Protect against overclocking
+	if (pll_int > 36) {
+		pll_int = 36; // 36 / 6 * 13.5 MHz = 81 MHz, just above the limit.
+	}
+	if (pll_int == 0) {
+		pll_int = 1;  // 0 will cause a burnout ...
+	}
+	if (av_type == AV_VGA) {
+		// use internal sync signals
+		regs[ADR(0x2e)] = 0xbd; // HDTV_EN = 1, RPR_SYNC_DIS = 1, BPB_SYNC_DIS = 1, GY_SYNC_DIS=1, HD_SYNC_EDGE = 1, RASTER_SEL = 01
+	}
+	else {
+ 		// use sync on green
+		regs[ADR(0x2e)] = 0xad; // HDTV_EN = 1, RPR_SYNC_DIS = 1, BPB_SYNC_DIS = 1, HD_SYNC_EDGE = 1, RASTER_SEL = 01
+	}
+	regs[ADR(0x32)] = 0x48; // DRVS = 2, IN_MODE[3] = 1;
+	regs[ADR(0x3c)] = 0x80; // MCOMPY
+	regs[ADR(0x3e)] = 0x80; // MCOMPU
+	regs[ADR(0x40)] = 0x80; // MCOMPV
+	regs[ADR(0xc6)] = 0x98; // IN_MODE = 24 bit RGB multiplexed
+	regs[ADR(0x6c)] = 0x46; // FLD_MODE = 10, EACTIVE = 1, EN_SCART = 0, EN_REG_RD = 1
+	regs[ADR(0x9c)] = 0x00; // PLL_FRACT
+	regs[ADR(0x9e)] = 0x00; // PLL_FRACT
+	regs[ADR(0xa0)] = pll_int; // PLL_INT
+	regs[ADR(0xba)] = 0x28; // SLAVER = 1, DACDISD = 1
+	regs[ADR(0xce)] = 0xe1; // OUT_MUXA = 01, OUT_MUXB = 00, OUT_MUXC = 10, OUT_MUXD = 11
+	regs[ADR(0xd6)] = 0x0c; // OUT_MODE = 11 (RGB / SCART / HDTV)
+
+	return 1;
+}
+
+int conexant_calc_hdtv_mode(
+	xbox_hdtv_mode hdtv_mode,
+	int dotClock,
+	void  **encoder_regs
+){
+	unsigned char pll_int = (unsigned char)((double)dotClock * 6.0 / 13.5e3 + 0.5);
+	unsigned char *regs;
+	*encoder_regs=kmalloc(NUM_CONEXANT_REGS*sizeof(char), GFP_KERNEL);
+	regs = (unsigned char*)*encoder_regs;
+	
+	memset(regs, 0, NUM_CONEXANT_REGS);
+	// Protect against overclocking
+	if (pll_int > 36) {
+		pll_int = 36; // 36 / 6 * 13.5 MHz = 81 MHz, just above the limit.
+	}
+	if (pll_int == 0) {
+		pll_int = 1;  // 0 will cause a burnout ...
+	}
+	switch (hdtv_mode) {
+		case HDTV_480p:
+			// use sync on green
+			regs[ADR(0x2e)] = 0xed; // HDTV_EN = 1, RGB2PRPB = 1, RPR_SYNC_DIS = 1, BPB_SYNC_DIS = 1, HD_SYNC_EDGE = 1, RASTER_SEL = 01
+			regs[ADR(0x32)] = 0x48; // DRVS = 2, IN_MODE[3] = 1;
+			regs[ADR(0x3e)] = 0x45; // MCOMPU
+			regs[ADR(0x40)] = 0x51; // MCOMPV
+			break;
+		case HDTV_720p:
+			// use sync on green
+			regs[ADR(0x2e)] = 0xea; // HDTV_EN = 1, RGB2PRPB = 1, RPR_SYNC_DIS = 1, BPB_SYNC_DIS = 1, HD_SYNC_EDGE = 1, RASTER_SEL = 01
+			regs[ADR(0x32)] = 0x49; // DRVS = 2, IN_MODE[3] = 1, CSC_SEL=1;
+			regs[ADR(0x3e)] = 0x45; // MCOMPU
+			regs[ADR(0x40)] = 0x51; // MCOMPV
+			break;
+		case HDTV_1080i:
+			// use sync on green
+			regs[ADR(0x2e)] = 0xeb; // HDTV_EN = 1, RGB2PRPB = 1, RPR_SYNC_DIS = 1, BPB_SYNC_DIS = 1, HD_SYNC_EDGE = 1, RASTER_SEL = 01
+			regs[ADR(0x32)] = 0x49; // DRVS = 2, IN_MODE[3] = 1, CSC_SEL=1;
+			regs[ADR(0x3e)] = 0x48; // MCOMPU
+			regs[ADR(0x40)] = 0x5b; // MCOMPV
+			break;
+	}
+	regs[ADR(0x3c)] = 0x80; // MCOMPY
+	regs[ADR(0xa0)] = pll_int; // PLL_INT
+	regs[ADR(0xc6)] = 0x98; // IN_MODE = 24 bit RGB multiplexed
+	regs[ADR(0x6c)] = 0x46; // FLD_MODE = 10, EACTIVE = 1, EN_SCART = 0, EN_REG_RD = 1
+	regs[ADR(0x9c)] = 0x00; // PLL_FRACT
+	regs[ADR(0x9e)] = 0x00; // PLL_FRACT
+	regs[ADR(0xba)] = 0x28; // SLAVER = 1, DACDISD = 1
+	regs[ADR(0xce)] = 0xe1; // OUT_MUXA = 01, OUT_MUXB = 00, OUT_MUXC = 10, OUT_MUXD = 11
+	regs[ADR(0xd6)] = 0x0c; // OUT_MODE = 11 (RGB / SCART / HDTV)
+
+	return 1;
+}
+
+int conexant_calc_mode(xbox_video_mode * mode, struct riva_regs * riva_out)
+{
+	unsigned char b;
+	unsigned int m = 0;
+	double dPllOutputFrequency;
+	xbox_tv_mode_parameter param;
+	char* regs;
+	int ret = 0;
+
+	riva_out->encoder_regs = kmalloc(NUM_CONEXANT_REGS*sizeof(char),GFP_KERNEL);
+	regs = (unsigned char*)riva_out->encoder_regs;
+	
+	kernel_fpu_begin();
+	if (conexant_calc_mode_params(mode, &param))
+	{
+		// copy default mode settings
+		memcpy(regs,default_mode,sizeof(default_mode));
+
+		regs[ADR(0x32)] = 0x28; // DRVS = 1, IN_MODE[3] = 1;
+
+		// H_CLKI
+		b=regs[ADR(0x8e)]&(~0x07);
+		regs[ADR(0x8e)] = ((param.h_clki>>8)&0x07)|b;
+		regs[ADR(0x8a)] = ((param.h_clki)&0xff);
+		// H_CLKO
+		b=regs[ADR(0x86)]&(~0x0f);
+		regs[ADR(0x86)] = ((param.h_clko>>8)&0x0f)|b;
+		regs[ADR(0x76)] = ((param.h_clko)&0xff);
+		// V_LINESI
+		b=regs[ADR(0x38)]&(~0x02);
+		regs[ADR(0x38)] = ((param.v_linesi>>9)&0x02)|b;
+		b=regs[ADR(0x96)]&(~0x03);
+		regs[ADR(0x96)] = ((param.v_linesi>>8)&0x03)|b;
+		regs[ADR(0x90)] = ((param.v_linesi)&0xff);
+		// V_ACTIVEO
+		/* TODO: Absolutely not sure about other modes than plain NTSC / PAL */
+		switch(mode->tv_encoding) {
+			case TV_ENC_NTSC:
+			case TV_ENC_NTSC60:
+			case TV_ENC_PALM:
+			case TV_ENC_PAL60:
+				m=param.v_activeo + 1;
+				break;
+			case TV_ENC_PALBDGHI:
+				m=param.v_activeo + 2;
+				break;
+			default:
+				m=param.v_activeo + 2;
+				break;
+		}
+		b=regs[ADR(0x86)]&(~0x80);
+		regs[ADR(0x86)] = ((m>>1)&0x80)|b;
+		regs[ADR(0x84)] = ((m)&0xff);
+		// H_ACTIVE
+		b=regs[ADR(0x86)]&(~0x70);
+		regs[ADR(0x86)] = (((mode->xres + 5)>>4)&0x70)|b;
+		regs[ADR(0x78)] = ((mode->xres + 5)&0xff);
+		// V_ACTIVEI
+		b=regs[ADR(0x96)]&(~0x0c);
+		regs[ADR(0x96)] = ((mode->yres>>6)&0x0c)|b;
+		regs[ADR(0x94)] = ((mode->yres)&0xff);
+		// H_BLANKI
+		b=regs[ADR(0x38)]&(~0x01);
+		regs[ADR(0x38)] = ((param.h_blanki>>9)&0x01)|b;
+		b=regs[ADR(0x8e)]&(~0x08);
+		regs[ADR(0x8e)] = ((param.h_blanki>>5)&0x08)|b;
+		regs[ADR(0x8c)] = ((param.h_blanki)&0xff);
+		// H_BLANKO
+		b=regs[ADR(0x9a)]&(~0xc0);
+		regs[ADR(0x9a)] = ((param.h_blanko>>2)&0xc0)|b;
+		regs[ADR(0x80)] = ((param.h_blanko)&0xff);
+
+		// V_SCALE
+		b=regs[ADR(0x9a)]&(~0x3f);
+		regs[ADR(0x9a)] = ((param.vscale>>8)&0x3f)|b;
+		regs[ADR(0x98)] = ((param.vscale)&0xff);
+		// V_BLANKO
+		regs[ADR(0x82)] = ((param.v_blanko)&0xff);
+		// V_BLANKI
+		regs[ADR(0x92)] = ((param.v_blanki)&0xff);
+		{
+			unsigned int dwPllRatio, dwFract, dwInt;
+			// adjust PLL
+			dwPllRatio = (int)(6.0 * ((double)param.h_clko / vidstda[mode->tv_encoding].m_dSecHsyncPeriod) *
+				param.clk_ratio * 0x10000 / pll_base + 0.5);
+			dwInt = dwPllRatio / 0x10000;
+			dwFract = dwPllRatio - (dwInt * 0x10000);
+			b=regs[ADR(0xa0)]&(~0x3f);
+			regs[ADR(0xa0)] = ((dwInt)&0x3f)|b;
+			regs[ADR(0x9e)] = ((dwFract>>8)&0xff);
+			regs[ADR(0x9c)] = ((dwFract)&0xff);
+			// recalc value
+			dPllOutputFrequency = ((double)dwInt + ((double)dwFract)/65536.0)/(6 * param.clk_ratio / pll_base);
+			// enable 3:2 clocking mode
+			b=regs[ADR(0x38)]&(~0x20);
+			if (param.clk_ratio > 1.1) {
+				b |= 0x20;
+			}
+			regs[ADR(0x38)] = b;
+
+			// update burst start position
+			m=(vidstda[mode->tv_encoding].m_dSecBurstStart) * dPllOutputFrequency + 0.5;
+			b=regs[ADR(0x38)]&(~0x04);
+			regs[ADR(0x38)] = ((m>>6)&0x04)|b;
+			regs[ADR(0x7c)] = (m&0xff);
+			// update burst end position (note +128 is in hardware)
+			m=(vidstda[mode->tv_encoding].m_dSecBurstEnd) * dPllOutputFrequency + 0.5;
+			if(m<128) m=128;
+			b=regs[ADR(0x38)]&(~0x08);
+			regs[ADR(0x38)] = (((m-128)>>5)&0x08)|b;
+			regs[ADR(0x7e)] = ((m-128)&0xff);
+			// update HSYNC width
+			m=(vidstda[mode->tv_encoding].m_dSecHsyncWidth) * dPllOutputFrequency + 0.5;
+			regs[ADR(0x7a)] = ((m)&0xff);
+		}
+		// adjust Subcarrier generation increment
+		{
+			unsigned int dwSubcarrierIncrement = (unsigned int) (
+				(65536.0 * 65536.0) * (
+					vidstda[mode->tv_encoding].m_dHzBurstFrequency
+					* vidstda[mode->tv_encoding].m_dSecHsyncPeriod
+					/ (double)param.h_clko
+				) + 0.5
+			);
+			regs[ADR(0xae)] = (dwSubcarrierIncrement&0xff);
+			regs[ADR(0xb0)] = ((dwSubcarrierIncrement>>8)&0xff);
+			regs[ADR(0xb2)] = ((dwSubcarrierIncrement>>16)&0xff);
+			regs[ADR(0xb4)] = ((dwSubcarrierIncrement>>24)&0xff);
+		}
+		// adjust WSS increment
+		{
+			unsigned int dwWssIncrement = 0;
+
+			switch(mode->tv_encoding) {
+				case TV_ENC_NTSC:
+				case TV_ENC_NTSC60:
+					dwWssIncrement=(unsigned int) ((1048576.0 / ( 0.000002234 * dPllOutputFrequency))+0.5);
+					break;
+				case TV_ENC_PALBDGHI:
+				case TV_ENC_PALN:
+				case TV_ENC_PALNC:
+				case TV_ENC_PALM:
+				case TV_ENC_PAL60:
+					dwWssIncrement=(unsigned int) ((1048576.0 / ( 0.0000002 * dPllOutputFrequency))+0.5);
+					break;
+				default:
+					break;
+				}
+
+			regs[ADR(0x66)] = (dwWssIncrement&0xff);
+			regs[ADR(0x68)] = ((dwWssIncrement>>8)&0xff);
+			regs[ADR(0x6a)] = ((dwWssIncrement>>16)&0xf);
+		}
+		// set mode register
+		b=regs[ADR(0xa2)]&(0x41);
+		switch(mode->tv_encoding) {
+				case TV_ENC_NTSC:
+					b |= 0x0a; // SETUP + VSYNC_DUR
+					break;
+				case TV_ENC_NTSC60:
+					b |= 0x08; // VSYNC_DUR
+					break;
+				case TV_ENC_PALBDGHI:
+				case TV_ENC_PALNC:
+						b |= 0x24; // PAL_MD + 625LINE
+					break;
+				case TV_ENC_PALN:
+					b |= 0x2e; // PAL_MD + SETUP + 625LINE + VSYNC_DUR
+					break;
+				case TV_ENC_PALM:
+					b |= 0x2a; // PAL_MD + SETUP + VSYNC_DUR
+					break;
+				case TV_ENC_PAL60:
+					b |= 0x28; // PAL_MD + VSYNC_DUR
+					break;
+				default:
+					break;
+		}
+		regs[ADR(0xa2)] = b;
+		regs[ADR(0xc6)] = 0x98; // IN_MODE = 24 bit RGB multiplexed
+		switch(mode->av_type) {
+			case AV_COMPOSITE:
+			case AV_SVIDEO:
+				regs[ADR(0x2e)] |= 0x40; // RGB2YPRPB = 1
+				regs[ADR(0x6c)] = 0x46; // FLD_MODE = 10, EACTIVE = 1, EN_SCART = 0, EN_REG_RD = 1
+				regs[ADR(0x5a)] = 0x00; // Y_OFF (Brightness)
+				regs[ADR(0xa4)] = 0xe5; // SYNC_AMP
+				regs[ADR(0xa6)] = 0x74; // BST_AMP
+				regs[ADR(0xba)] = 0x24; // SLAVER = 1, DACDISC = 1
+				regs[ADR(0xce)] = 0x19; // OUT_MUXA = 01, OUT_MUXB = 10, OUT_MUXC = 10, OUT_MUXD = 00
+				regs[ADR(0xd6)] = 0x00; // OUT_MODE = 00 (CVBS)
+				break;
+			case AV_SCART_RGB:
+				regs[ADR(0x6c)] = 0x4e; // FLD_MODE = 10, EACTIVE = 1, EN_SCART = 1, EN_REG_RD = 1
+				regs[ADR(0x5a)] = 0xff; // Y_OFF (Brightness)
+				regs[ADR(0xa4)] = 0xe7; // SYNC_AMP
+				regs[ADR(0xa6)] = 0x77; // BST_AMP
+				regs[ADR(0xba)] = 0x20; // SLAVER = 1, enable all DACs
+				regs[ADR(0xce)] = 0xe1; // OUT_MUXA = 01, OUT_MUXB = 00, OUT_MUXC = 10, OUT_MUXD = 11
+				regs[ADR(0xd6)] = 0x0c; // OUT_MODE = 11 (RGB / SCART / HDTV)
+				break;
+			default:
+				break;
+		}
+		riva_out->ext.vend = mode->yres;
+		riva_out->ext.vtotal = param.v_linesi - 1;
+		riva_out->ext.vcrtc = mode->yres;
+		riva_out->ext.vsyncstart = param.v_linesi - param.v_blanki;
+		riva_out->ext.vsyncend = riva_out->ext.vsyncstart + 3;
+		riva_out->ext.vvalidstart = 0;
+		riva_out->ext.vvalidend = mode->yres;
+		riva_out->ext.hend = mode->xres + 7;
+		riva_out->ext.htotal = param.h_clki - 1;
+		riva_out->ext.hcrtc = mode->xres - 1;
+		riva_out->ext.hsyncstart = param.h_clki - param.h_blanki - 7;
+		riva_out->ext.hsyncend = riva_out->ext.hsyncstart + 32;
+		riva_out->ext.hvalidstart = 0;
+		riva_out->ext.hvalidend = mode->xres - 1;
+		riva_out->ext.crtchdispend = mode->xres + 8;
+		riva_out->ext.crtcvstart = mode->yres + 34;
+		riva_out->ext.crtcvtotal = param.v_linesi + 32;
+		ret = 1;
+	}
+	else
+	{
+		ret = 0;
+	}
+	kernel_fpu_end();
+	return ret;
+}
+
+static int conexant_calc_mode_params(
+	xbox_video_mode * mode,
+	xbox_tv_mode_parameter * param
+){
+	const double dMinHBT = 2.5e-6; // 2.5uSec time for horizontal syncing
+	const double invalidMetric = 1000;
+
+	/* algorithm shamelessly ripped from nvtv/calc_bt.c */
+	double dTempVOC = 0;
+	double dTempHOC = 0;
+	double dBestMetric = invalidMetric;
+	double dTempVSR = 0;
+	double dBestVSR = 0;
+	double dTempCLKRATIO = 1;
+	double dBestCLKRATIO = 1;
+	unsigned int  minTLI = 0;
+	unsigned int  maxTLI = 0;
+	unsigned int  tempTLI = 0;
+	unsigned int  bestTLI = 0;
+	unsigned int  minHCLKO = 0;
+	unsigned int  maxHCLKO = 0;
+	unsigned int  minHCLKI = 0;
+	unsigned int  tempHCLKI = 0;
+	unsigned int  bestHCLKI = 0;
+	int    actCLKRATIO;
+	unsigned int  dTempHCLKO = 0;
+	double dTempVACTIVEO = 0;
+	double dDelta = 0;
+	double dMetric = 0;
+	double alo =  vidstda[mode->tv_encoding].m_dwALO;
+	double tlo =  vidstda[mode->tv_encoding].m_TotalLinesOut;
+	double tto = vidstda[mode->tv_encoding].m_dSecHsyncPeriod;
+	double ato = tto - (vidstda[mode->tv_encoding].m_dSecBlankBeginToHsync + vidstda[mode->tv_encoding].m_dSecActiveBegin);
+
+	/* Range to search */
+	double dMinHOC = mode->hoc - 0.02;
+	double dMaxHOC = mode->hoc + 0.02;
+	double dMinVOC = mode->voc - 0.02;
+	double dMaxVOC = mode->voc + 0.02;
+
+	if (dMinHOC < 0) dMinHOC = 0;
+	if (dMinVOC < 0) dMinVOC = 0;
+
+	minTLI= (unsigned int)(mode->yres / ((1 - dMinVOC) * alo) * tlo);
+	maxTLI = min((unsigned int)(mode->yres / ((1 - dMaxVOC) * alo) * tlo), (unsigned int)1023);
+	minHCLKO = (unsigned int) ((mode->xres * 2) /
+				((1 - dMinHOC) * (ato / tto)));
+	maxHCLKO = (unsigned int) ((mode->xres * 2) /
+				((1 - dMaxHOC) * (ato / tto)));
+	for (actCLKRATIO = 0; actCLKRATIO <= 1; actCLKRATIO++)
+	{
+		dTempCLKRATIO = 1.0;
+		if (actCLKRATIO) dTempCLKRATIO = 3.0/2.0;
+		for(tempTLI = minTLI; tempTLI <= maxTLI; tempTLI++)
+		{
+			dTempVSR = (double)tempTLI / tlo;
+			dTempVACTIVEO = (int)((((double)mode->yres * tlo) +
+						(tempTLI - 1)) / tempTLI);
+			dTempVOC = 1 - dTempVACTIVEO / alo;
+
+			for(dTempHCLKO = minHCLKO; dTempHCLKO <= maxHCLKO; dTempHCLKO++)
+			{
+				tempHCLKI = (unsigned int)((dTempHCLKO * dTempCLKRATIO) * (tlo / tempTLI) + 0.5);
+				minHCLKI = ((dMinHBT / tto) * tempHCLKI) + mode->xres;
+				// check if solution is valid
+				if ((fabs((double)(tempTLI * tempHCLKI) - (tlo * dTempHCLKO * dTempCLKRATIO)) < 1e-3) &&
+					(tempHCLKI >= minHCLKI) && (tempHCLKI < 2048))
+				{
+					dTempHOC = 1 - (((double)mode->xres / ((double)dTempHCLKO / 2)) /
+						(ato / tto));
+					dDelta = fabs(dTempHOC - mode->hoc) + fabs(dTempVOC - mode->voc);
+					dMetric = ((dTempHOC - mode->hoc) * (dTempHOC - mode->hoc)) +
+						((dTempVOC - mode->voc) * (dTempVOC - mode->voc)) +
+						(2 * dDelta * dDelta);
+					if(dMetric < dBestMetric)
+					{
+						dBestVSR = dTempVSR;
+						dBestMetric = dMetric;
+						bestTLI = tempTLI;
+						bestHCLKI = tempHCLKI;
+						dBestCLKRATIO = dTempCLKRATIO;
+					}
+				} /* valid solution */
+			} /* dTempHCLKO loop */
+		} /* tempTLI loop */
+	} /* CLKRATIO loop */
+
+	if(dBestMetric != invalidMetric)
+	{
+		param->v_linesi = bestTLI;
+		param->h_clki = bestHCLKI;
+		param->clk_ratio = dBestCLKRATIO;
+		param->v_activeo = (unsigned int)(
+			(
+				(mode->yres * vidstda[mode->tv_encoding].m_TotalLinesOut)
+				+ param->v_linesi - 1
+			) / param->v_linesi
+		);
+		param->h_clko = (unsigned int)(
+			(
+				(param->v_linesi * param->h_clki) /
+				(vidstda[mode->tv_encoding].m_TotalLinesOut * param->clk_ratio)
+			)
+			+ 0.5
+		);
+		conexant_calc_blankings(mode, param);
+		return 1;
+	}
+	else
+	{
+		return 0;
+	}
+}
+
+static void conexant_calc_blankings(
+	xbox_video_mode * mode,
+	xbox_tv_mode_parameter * param
+){
+	double dTotalHBlankI;
+	double dFrontPorchIn;
+	double dFrontPorchOut;
+	double dMinFrontPorchIn;
+	double dBackPorchIn;
+	double dBackPorchOut;
+	double dTotalHBlankO;
+	double dHeadRoom;
+	double dMaxHsyncDrift;
+	double dFifoMargin;
+	double vsrq;
+	double dMaxHR;
+	double tlo =  vidstda[mode->tv_encoding].m_TotalLinesOut;
+	const int MFP = 14; // Minimum front porch
+	const int MBP = 4;  // Minimum back porch
+	const int FIFO_SIZE = 1024;
+	double vsr = (double)param->v_linesi / vidstda[mode->tv_encoding].m_TotalLinesOut;
+
+	// H_BLANKO
+	param->h_blanko = 2 * (int)(
+		vidstda[mode->tv_encoding].m_dSecImageCentre / (2 * vidstda[mode->tv_encoding].m_dSecHsyncPeriod) *
+		param->h_clko
+		+ 0.5
+	) - mode->xres + 15;
+
+	// V_BLANKO
+	switch (mode->tv_encoding) {
+		case TV_ENC_NTSC:
+		case TV_ENC_NTSC60:
+		case TV_ENC_PAL60:
+		case TV_ENC_PALM:
+			param->v_blanko = (int)( 140 - ( param->v_activeo / 2.0 ) + 0.5 );
+			break;
+		default:
+			param->v_blanko = (int)( 167 - ( param->v_activeo / 2.0 ) + 0.5 );
+			break;
+	}
+
+	// V_BLANKI
+	vsrq = ( (int)( vsr * 4096.0 + .5 ) ) / 4096.0;
+	param->vscale = (int)( ( vsr - 1 ) * 4096 + 0.5 );
+	if( vsrq < vsr )
+	{
+	// These calculations are in units of dHCLKO
+		dMaxHsyncDrift = ( vsrq - vsr ) * tlo / vsr * param->h_clko;
+		dMinFrontPorchIn = MFP / ( (double)param->h_clki * vsr ) * param->h_clko;
+		dFrontPorchOut = param->h_clko - param->h_blanko - mode->xres * 2;
+		dFifoMargin = ( FIFO_SIZE - mode->xres ) * 2;
+
+		// Check for fifo overflow
+		if( dFrontPorchOut + dFifoMargin < -dMaxHsyncDrift + dMinFrontPorchIn )
+		{
+			dTotalHBlankO = param->h_clko - mode->xres * 2;
+			dTotalHBlankI = ( (double)param->h_clki - (double)mode->xres ) / param->h_clki / vsr * param->h_clko;
+
+			// Try forcing the Hsync drift the opposite direction
+			dMaxHsyncDrift = ( vsrq + 1.0 / 4096 - vsr ) * tlo / vsr * param->h_clko;
+
+			// Check that fifo overflow and underflow can be avoided
+			if( dTotalHBlankO + dFifoMargin >= dTotalHBlankI + dMaxHsyncDrift )
+			{
+				vsrq = vsrq + 1.0 / 4096;
+				param->vscale = (int)( ( vsrq - 1 ) * 4096 );
+			}
+
+			// NOTE: If fifo overflow and underflow can't be avoided,
+			//       alternative overscan compensation ratios should
+			//       be selected and all calculations repeated.  If
+			//       that is not feasible, the calculations for
+			//       H_BLANKI below will delay the overflow or under-
+			//       flow as much as possible, to minimize the visible
+			//       artifacts.
+		}
+	}
+
+	param->v_blanki = (int)( ( param->v_blanko - 1 ) * vsrq );
+
+	// H_BLANKI
+
+	// These calculations are in units of dHCLKI
+	dTotalHBlankI = param->h_clki - mode->xres;
+	dFrontPorchIn = max( (double)MFP, min( dTotalHBlankI / 8.0, dTotalHBlankI - (double)MBP ) );
+	dBackPorchIn = dTotalHBlankI - dFrontPorchIn;
+	dMaxHsyncDrift = ( vsrq - vsr ) * tlo * param->h_clki;
+	dTotalHBlankO = ( param->h_clko - mode->xres * 2.0 ) / param->h_clko * vsr * param->h_clki;
+	dBackPorchOut = ((double)param->h_blanko) / (double)param->h_clko * vsr * param->h_clki;
+	dFrontPorchOut = dTotalHBlankO - dBackPorchOut;
+	dFifoMargin = ( FIFO_SIZE - mode->xres ) * 2.0 / param->h_clko * vsr * param->h_clki;
+	// This may be excessive, but is adjusted by the code.
+	dHeadRoom = 32.0;
+
+	// Check that fifo overflow and underflow can be avoided
+	if( ( dTotalHBlankO + dFifoMargin ) >= ( dTotalHBlankI + fabs( dMaxHsyncDrift ) ) )
+	{
+		dMaxHR = ( dTotalHBlankO + dFifoMargin ) - ( dTotalHBlankI - fabs( dMaxHsyncDrift ) );
+		if( dMaxHR < ( dHeadRoom * 2.0 ) )
+		{
+			dHeadRoom = (int)( dMaxHR / 2.0);
+		}
+
+		// Check for overflow
+		if( ( ( dFrontPorchOut + dFifoMargin ) - dHeadRoom ) < ( dFrontPorchIn - min( dMaxHsyncDrift, 0.0 ) ) )
+		{
+			dFrontPorchIn = max( (double)MFP, ( dFrontPorchOut + dFifoMargin + min( dMaxHsyncDrift, 0.0 ) - dHeadRoom ) );
+			dBackPorchIn = dTotalHBlankI - dFrontPorchIn;
+		}
+
+		// Check for underflow
+		if( dBackPorchOut - dHeadRoom < dBackPorchIn + max( dMaxHsyncDrift, 0.0 ) )
+		{
+			dBackPorchIn = max( (double)MBP, ( dBackPorchOut - max( dMaxHsyncDrift, 0.0 ) - dHeadRoom ) );
+			dFrontPorchIn = dTotalHBlankI - dBackPorchIn;
+		}
+	}
+	else if( dMaxHsyncDrift < 0 )
+	{
+		// Delay the overflow as long as possible
+		dBackPorchIn = min( ( dBackPorchOut - 1 ), ( dTotalHBlankI - MFP ) );
+		dFrontPorchIn = dTotalHBlankI - dBackPorchIn;
+	}
+	else
+	{
+		// Delay the underflow as long as possible
+		dFrontPorchIn = min( ( dFrontPorchOut + dFifoMargin - 1 ), ( dTotalHBlankI - MBP ) );
+		dBackPorchIn = dTotalHBlankI - dFrontPorchIn;
+	}
+
+	param->h_blanki = (int)( dBackPorchIn );
+
+}
diff -uprN a/drivers/video/xbox/conexant.h b/drivers/video/xbox/conexant.h
--- a/drivers/video/xbox/conexant.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/conexant.h	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,29 @@
+/*
+ * linux/drivers/video/riva/conexant.h - Xbox driver for conexant chip
+ *
+ * Maintainer: Oliver Schwartz <Oliver.Schwartz@gmx.de>
+ *
+ * Contributors:
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * Known bugs and issues:
+ *
+ *      none
+ */
+
+#ifndef conexant_h
+#define conexant_h
+
+#include <linux/xboxfbctl.h>
+#include <linux/slab.h>
+#include "xboxfb.h"
+#include "encoder.h"
+
+int conexant_calc_mode(xbox_video_mode * mode, struct riva_regs * riva_out);
+int conexant_calc_vga_mode(xbox_av_type av_type, int dotClock, void **encoder_regs);
+int conexant_calc_hdtv_mode(xbox_hdtv_mode hdtv_mode, int dotClock, void **encoder_regs);
+
+#endif
diff -uprN a/drivers/video/xbox/encoder-i2c.c b/drivers/video/xbox/encoder-i2c.c
--- a/drivers/video/xbox/encoder-i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/encoder-i2c.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,209 @@
+/*
+ * linux/drivers/video/riva/encoder-i2c.c - Xbox I2C driver for encoder chip
+ *
+ * Maintainer: Oliver Schwartz <Oliver.Schwartz@gmx.de>
+ *
+ * Contributors:
+ *
+ * Most of the code was stolen from extsmi.c
+ * 
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * Known bugs and issues:
+ *
+ *      none
+ */
+
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#define CONEXANT_ADDRESS 0x45
+#define FOCUS_ADDRESS 0x6a
+#define XLB_ADDRESS 0x70
+#define EEPROM_ADDRESS 0x54
+#define PIC_ADDRESS 0x10
+
+#define DRIVER_NAME "xbox-tv-i2c"
+
+
+#ifndef MODULE
+extern int __init i2c_xbox_init(void);
+#endif
+
+static int tv_attach_adapter(struct i2c_adapter *adap);
+
+static struct i2c_driver tv_driver = {
+	.driver = {
+		.name	= "i2c xbox conexant driver",
+	},
+	.id		= I2C_DRIVERID_I2CDEV,
+	.attach_adapter	= tv_attach_adapter,
+};
+
+static struct i2c_client pic_client = {
+	.name		= "I2C xbox pic client",
+	.flags		= 0,
+	.addr		= PIC_ADDRESS,
+	.adapter	= NULL,
+	.driver		= &tv_driver,
+};
+
+static struct i2c_client conexant_client = {
+	.name		= "I2C xbox conexant",
+	.flags		= 0,
+	.addr		= CONEXANT_ADDRESS,
+	.adapter	= NULL,
+	.driver		= &tv_driver,
+};
+
+static struct i2c_client focus_client = {
+	.name		= "I2C xbox focus",
+	.flags		= 0,
+	.addr		= FOCUS_ADDRESS,
+	.adapter	= NULL,
+	.driver		= &tv_driver,
+};
+
+static struct i2c_client xcalibur_client = {
+	.name		= "I2C xbox Xcalibur",
+	.flags		= 0,
+	.addr		= XLB_ADDRESS,
+	.adapter	= NULL,
+	.driver		= &tv_driver,
+};
+
+static struct i2c_client eeprom_client = {
+	.name		= "I2C xbox eeprom",
+	.flags		= 0,
+	.addr		= EEPROM_ADDRESS,
+	.adapter	= NULL,
+	.driver		= &tv_driver,
+};
+
+static int tv_attach_adapter(struct i2c_adapter *adap)
+{
+	int i;
+
+	if ((i = i2c_adapter_id(adap)) < 0) {
+		printk("i2c-dev.o: Unknown adapter ?!?\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO DRIVER_NAME ": Using '%s'!\n",adap->name);
+	conexant_client.adapter = adap;
+	focus_client.adapter = adap;
+	xcalibur_client.adapter = adap;
+	pic_client.adapter = adap;
+	eeprom_client.adapter = adap;
+	i2c_attach_client(&conexant_client);
+	i2c_attach_client(&focus_client);
+	i2c_attach_client(&xcalibur_client);
+	i2c_attach_client(&pic_client);
+	i2c_attach_client(&eeprom_client);
+
+	return 0;
+}
+
+int tv_i2c_init(void) {
+	int res;
+
+#ifndef MODULE
+	i2c_xbox_init();
+#endif
+
+	if ((res = i2c_add_driver(&tv_driver))) {
+		printk(KERN_ERR DRIVER_NAME ": XBox tv driver registration failed.\n");
+		return res;
+	}
+	return 0;
+}
+
+int conexant_i2c_read_reg(unsigned char adr) {
+	if (!conexant_client.adapter) {
+		printk(KERN_ERR DRIVER_NAME " : No conexant client attached.\n");
+		return -1;
+	}
+	udelay(500);
+	return i2c_smbus_read_byte_data(&conexant_client, adr);
+}
+
+int conexant_i2c_write_reg(unsigned char adr, unsigned char value) {
+	if (!conexant_client.adapter) {
+		printk(KERN_ERR DRIVER_NAME " : No conexant client attached.\n");
+		return -1;
+	}
+	udelay(500);
+	return i2c_smbus_write_byte_data(&conexant_client, adr, value);
+}
+
+int focus_i2c_read_reg(unsigned char adr) {
+	if (!focus_client.adapter) {
+		printk(KERN_ERR DRIVER_NAME " : No focus client attached.\n");
+		return -1;
+	}
+	udelay(500);
+	return i2c_smbus_read_byte_data(&focus_client, adr);
+}
+
+int focus_i2c_write_reg(unsigned char adr, unsigned char value) {
+	if (!focus_client.adapter) {
+		printk(KERN_ERR DRIVER_NAME " : No focus client attached.\n");
+		return -1;
+	}
+	udelay(500);
+	return i2c_smbus_write_byte_data(&focus_client, adr, value);
+}
+
+int xcalibur_i2c_read_reg(unsigned char adr) {
+	if (!xcalibur_client.adapter) {
+		printk(KERN_ERR DRIVER_NAME " : No Xcalibur client attached.\n");
+		return -1;
+	}
+	udelay(500);
+	return i2c_smbus_read_byte_data(&xcalibur_client, adr);
+}
+
+int xcalibur_i2c_read_block(unsigned char adr, unsigned char *data) {
+	if (!xcalibur_client.adapter) {
+		printk(KERN_ERR DRIVER_NAME " : No Xcalibur client attached.\n");
+		return -1;
+	}
+	udelay(500);
+	return i2c_smbus_read_i2c_block_data(&xcalibur_client, adr, data);
+}
+
+int xcalibur_i2c_write_block(unsigned char adr, unsigned char *data, int len){
+	if (!xcalibur_client.adapter) {
+		printk(KERN_ERR DRIVER_NAME " : No Xcalibur client attached.\n");
+		return -1;
+	}
+	udelay(500);
+	return i2c_smbus_write_block_data(&xcalibur_client, adr, len, data);
+}
+
+unsigned char pic_i2c_read_reg(unsigned char adr) {
+	if (!pic_client.adapter) {
+		printk(KERN_ERR DRIVER_NAME " : No pic client attached.\n");
+		return 0;
+	}
+	udelay(500);
+	return (unsigned char)i2c_smbus_read_byte_data(&pic_client, adr);
+}
+
+unsigned char eeprom_i2c_read(unsigned char adr) {
+	if (!eeprom_client.adapter) {
+		printk(KERN_ERR DRIVER_NAME " : No eeprom client attached.\n");
+		return 0;
+	}
+	udelay(500);
+	return (unsigned char)i2c_smbus_read_byte_data(&eeprom_client, adr);
+}
+
+void tv_i2c_exit(void){
+	i2c_del_driver(&tv_driver);
+}
+
diff -uprN a/drivers/video/xbox/encoder-i2c.h b/drivers/video/xbox/encoder-i2c.h
--- a/drivers/video/xbox/encoder-i2c.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/encoder-i2c.h	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,32 @@
+/*
+ * linux/drivers/video/riva/encoder-i2c.h - Xbox I2C driver for encoder chip
+ *
+ * Maintainer: Oliver Schwartz <Oliver.Schwartz@gmx.de>
+ *
+ * Contributors:
+ * 
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * Known bugs and issues:
+ *
+ *      none
+ */
+ 
+#ifndef encoder_i2c_h
+#define encoder_i2c_h
+
+int tv_i2c_init(void);
+void tv_i2c_exit(void);
+int conexant_i2c_read_reg(unsigned char adr);
+int conexant_i2c_write_reg(unsigned char adr, unsigned char value);
+int focus_i2c_read_reg(unsigned char adr);
+int focus_i2c_write_reg(unsigned char adr, unsigned char value);
+int xcalibur_i2c_read_reg(unsigned char adr);
+int xcalibur_i2c_read_block(unsigned char adr, unsigned char *data);
+int xcalibur_i2c_write_block(unsigned char adr, unsigned char *data, int len);
+unsigned char pic_i2c_read_reg(unsigned char adr);
+unsigned char eeprom_i2c_read(unsigned char adr);
+
+#endif
diff -uprN a/drivers/video/xbox/encoder.c b/drivers/video/xbox/encoder.c
--- a/drivers/video/xbox/encoder.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/encoder.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,175 @@
+/*
+ * linux/drivers/video/riva/encoder.c - Xbox driver for encoder chip
+ *
+ * Maintainer: Oliver Schwartz <Oliver.Schwartz@gmx.de>
+ *
+ * Contributors:
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * Known bugs and issues:
+ *
+ *      none
+ */
+
+#include "encoder-i2c.h"
+#include "encoder.h"
+#include "focus.h"
+#include <asm/io.h>
+
+xbox_encoder_type tv_get_video_encoder(void) {
+	unsigned char b = 0;
+
+	b = conexant_i2c_read_reg(0x00);
+	if(b != 255) {
+		return ENCODER_CONEXANT;
+	}
+	b = focus_i2c_read_reg(0x00);
+	if(b != 255) {
+		return ENCODER_FOCUS;
+	}
+	b = xcalibur_i2c_read_reg(0x00);
+	if(b != 255) {
+		return ENCODER_XCALIBUR;
+	}
+	return 0;
+}
+
+int tv_init(void) {
+	return tv_i2c_init();
+}
+
+void tv_exit(void) {
+	tv_i2c_exit();
+}
+
+void tv_load_mode(unsigned char *encoder_regs) {
+	int n, n1;
+	unsigned char b;
+	unsigned char *mode;
+	u32 *XCal_Reg;
+	switch (tv_get_video_encoder()) {
+		case ENCODER_CONEXANT:
+			conexant_i2c_write_reg(0xc4, 0x00); // EN_OUT = 1
+			mode = (unsigned char *)encoder_regs;
+			// Conexant init (starts at register 0x2e)
+			n1=0;
+			for(n=0x2e;n<0x100;n+=2) {
+				switch(n) {
+					case 0x6c: // reset
+						conexant_i2c_write_reg(n, mode[n1] & 0x7f);
+						break;
+					case 0xc4: // EN_OUT
+						conexant_i2c_write_reg(n, mode[n1] & 0xfe);
+						break;
+					case 0xb8: // autoconfig
+						break;
+	
+					default:
+						conexant_i2c_write_reg(n, mode[n1]);
+						break;
+				}
+				n1++;
+			}
+			// Timing Reset
+			b=conexant_i2c_read_reg(0x6c) & (0x7f);
+			conexant_i2c_write_reg(0x6c, 0x80|b);
+			b=conexant_i2c_read_reg(0xc4) & (0xfe);
+			conexant_i2c_write_reg(0xc4, 0x01|b); // EN_OUT = 1
+			
+			conexant_i2c_write_reg(0xA8, 0x81);
+			conexant_i2c_write_reg(0xAA, 0x49);
+			conexant_i2c_write_reg(0xAC, 0x8C);
+			break;
+		case ENCODER_FOCUS:
+			mode = (unsigned char *)encoder_regs;
+			//Set the command register soft reset
+			focus_i2c_write_reg(0x0c,0x03);
+			focus_i2c_write_reg(0x0d,0x21);
+			
+			for (n = 0; n<0xc4; n++) {
+				focus_i2c_write_reg(n,mode[n]);
+			}
+			//Clear soft reset flag
+			b = focus_i2c_read_reg(0x0c);
+			b &= ~0x01;
+			focus_i2c_write_reg(0x0c,b);
+			b = focus_i2c_read_reg(0x0d);
+			focus_i2c_write_reg(0x0d,b);
+			break;
+		case ENCODER_XCALIBUR:
+			//Xcalibur regs are 4 bytes long
+			XCal_Reg = (u32*)encoder_regs;
+			mode = kmalloc(4*sizeof(char),GFP_KERNEL);
+			for(n = 0; n < 0x90; n++) {
+				//Endianness.
+				memcpy(&mode[0],(unsigned char*)(&XCal_Reg[n])+3,0x01);
+				memcpy(&mode[1],(unsigned char*)(&XCal_Reg[n])+2,0x01);
+				memcpy(&mode[2],(unsigned char*)(&XCal_Reg[n])+1,0x01);
+				memcpy(&mode[3],(unsigned char*)(&XCal_Reg[n]),0x01);
+				xcalibur_i2c_write_block(n, mode, 0x04);
+			}
+						
+			kfree(mode);
+		}
+	kfree(encoder_regs);
+}
+
+void tv_save_mode(unsigned char *encoder_regs) {
+	int n, n1;
+	char *mode;
+	
+	switch (tv_get_video_encoder()) {
+		case ENCODER_CONEXANT:
+			encoder_regs = kmalloc(256*sizeof(char),GFP_KERNEL);
+			mode = (unsigned char*) encoder_regs;
+			// Conexant init (starts at register 0x2e)
+			n1=0;		
+			for(n=0x2e;n<0x100;n+=2) {
+				mode[n1] = conexant_i2c_read_reg(n);
+				n1++;
+			}
+			break;
+		case ENCODER_FOCUS:
+			encoder_regs = kmalloc(256*sizeof(char),GFP_KERNEL);
+			mode = (unsigned char*) encoder_regs;
+			for (n=0;n<0xc4;n++) {
+				mode[n] = focus_i2c_read_reg(n);
+			}
+			break;
+		case ENCODER_XCALIBUR:
+			encoder_regs = kmalloc(0x90*sizeof(char)*4, GFP_KERNEL);
+			//We don't save these yet - sorry!
+			break;
+	}			
+}
+
+xbox_tv_encoding get_tv_encoding(void) {
+	unsigned char eeprom_value;
+	xbox_tv_encoding enc = TV_ENC_PALBDGHI;
+	eeprom_value = eeprom_i2c_read(0x5a);
+	if (eeprom_value == 0x40) {
+		enc = TV_ENC_NTSC;
+	}
+	else {
+		enc = TV_ENC_PALBDGHI;
+	}
+	return enc;
+}
+
+xbox_av_type detect_av_type(void) {
+	xbox_av_type avType;
+	switch (pic_i2c_read_reg(0x04)) {
+		case 0: avType = AV_SCART_RGB; break;
+		case 1: avType = AV_HDTV; break;
+		case 2: avType = AV_VGA_SOG; break;
+		case 4: avType = AV_SVIDEO; break;
+		case 6: avType = AV_COMPOSITE; break;
+		case 7: avType = AV_VGA; break;
+		default: avType = AV_COMPOSITE; break;
+	}
+	return avType;
+}
+
diff -uprN a/drivers/video/xbox/encoder.h b/drivers/video/xbox/encoder.h
--- a/drivers/video/xbox/encoder.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/encoder.h	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,64 @@
+/*
+ * linux/drivers/video/riva/encoder.h - Xbox driver for encoder chip
+ *
+ * Maintainer: Oliver Schwartz <Oliver.Schwartz@gmx.de>
+ *
+ * Contributors:
+ * 
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * Known bugs and issues:
+ *
+ *      none
+ */
+
+
+#ifndef encoder_h
+#define encoder_h
+
+#include <linux/xboxfbctl.h>
+
+typedef struct {
+	double m_dHzBurstFrequency;
+	double m_dSecBurstStart;
+	double m_dSecBurstEnd;
+	double m_dSecHsyncWidth;
+	double m_dSecHsyncPeriod;
+	double m_dSecActiveBegin;
+	double m_dSecImageCentre;
+	double m_dSecBlankBeginToHsync;
+	unsigned int m_dwALO;
+	double m_TotalLinesOut;
+	double m_dSecHsyncToBlankEnd;
+} conexant_video_parameter;
+
+typedef struct _xbox_video_mode {
+	int xres;
+	int yres;
+	int bpp;
+	double hoc;
+	double voc;
+	xbox_av_type av_type;
+	xbox_tv_encoding tv_encoding;
+} xbox_video_mode;
+
+typedef enum enumHdtvModes {
+        HDTV_480p,
+	HDTV_720p,
+	HDTV_1080i
+} xbox_hdtv_mode;
+
+static const conexant_video_parameter vidstda[];
+
+int tv_init(void);
+void tv_exit(void);
+xbox_encoder_type tv_get_video_encoder(void);
+
+void tv_save_mode(unsigned char * mode_out);
+void tv_load_mode(unsigned char * mode);
+xbox_tv_encoding get_tv_encoding(void);
+xbox_av_type detect_av_type(void);
+
+#endif
diff -uprN a/drivers/video/xbox/fbdev.c b/drivers/video/xbox/fbdev.c
--- a/drivers/video/xbox/fbdev.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/fbdev.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,2515 @@
+/*
+ * linux/drivers/video/riva/fbdev.c - nVidia Xbox fb driver
+ *
+ * Maintained by Oliver Schwartz <Oliver.Schwartz@gmx.de>
+ *
+ * Based on the nVidia RIVA 128/TNT/TNT2 fb driver, maintained by 
+ * Ani Joshi <ajoshi@shell.unixbox.com>
+ *
+ * Copyright 1999-2000 Jeff Garzik
+ *
+ * Contributors:
+ *
+ *	Ani Joshi:  Lots of debugging and cleanup work, really helped
+ *	get the driver going
+ *
+ *	Ferenc Bakonyi:  Bug fixes, cleanup, modularization
+ *
+ *	Jindrich Makovicka:  Accel code help, hw cursor, mtrr
+ *
+ *	Paul Richards:  Bug fixes, updates
+ *
+ * Initial template from skeletonfb.c, created 28 Dec 1997 by Geert Uytterhoeven
+ * Includes riva_hw.c from nVidia, see copyright below.
+ * KGI code provided the basis for state storage, init, and mode switching.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * Known bugs and issues:
+ *	restoring text mode fails
+ *	doublescan modes are broken
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#ifdef CONFIG_MTRR
+#include <asm/mtrr.h>
+#endif
+#ifdef CONFIG_PPC_OF
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
+#endif
+
+#include "xboxfb.h"
+#include "nvreg.h"
+#include <linux/sys.h>
+#include <asm/uaccess.h>
+#include <linux/xboxfbctl.h>
+#include "encoder-i2c.h"
+#include "conexant.h"
+#include "focus.h"
+#include "xcalibur.h"
+
+#ifndef CONFIG_PCI		/* sanity check */
+#error This driver requires PCI support.
+#endif
+
+/* version number of this driver */
+#define XBOXFB_VERSION "0.9.5b-xbox"
+
+/* ------------------------------------------------------------------------- *
+ *
+ * various helpful macros and constants
+ *
+ * ------------------------------------------------------------------------- */
+#ifdef CONFIG_FB_RIVA_DEBUG
+#define NVTRACE          printk
+#else
+#define NVTRACE          if(0) printk
+#endif
+
+#define NVTRACE_ENTER(...)  NVTRACE("%s START\n", __FUNCTION__)
+#define NVTRACE_LEAVE(...)  NVTRACE("%s END\n", __FUNCTION__)
+
+#ifdef CONFIG_FB_RIVA_DEBUG
+#define assert(expr) \
+	if(!(expr)) { \
+	printk( "Assertion failed! %s,%s,%s,line=%d\n",\
+	#expr,__FILE__,__FUNCTION__,__LINE__); \
+	BUG(); \
+	}
+#else
+#define assert(expr)
+#endif
+
+#define PFX "xboxfb: "
+
+/* macro that allows you to set overflow bits */
+#define SetBitField(value,from,to) SetBF(to,GetBF(value,from))
+#define SetBit(n)		(1<<(n))
+#define Set8Bits(value)		((value)&0xff)
+
+/* HW cursor parameters */
+#define MAX_CURS		32
+
+/* ------------------------------------------------------------------------- *
+ *
+ * prototypes
+ *
+ * ------------------------------------------------------------------------- */
+
+static int xboxfb_blank(int blank, struct fb_info *info);
+
+/* ------------------------------------------------------------------------- *
+ *
+ * card identification
+ *
+ * ------------------------------------------------------------------------- */
+
+enum riva_chips {
+	CH_GEFORCE3_XBOX
+};
+
+/* directly indexed by riva_chips enum, above */
+static struct riva_chip_info {
+	const char *name;
+	unsigned arch_rev;
+} riva_chip_info[] __initdata = {
+        { "GeForce3", NV_ARCH_20}
+};
+
+static struct pci_device_id xboxfb_pci_tbl[] = {
+	{ PCI_VENDOR_ID_NVIDIA, 0x2a0,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE3_XBOX },
+	{ 0, } /* terminate list */
+};
+MODULE_DEVICE_TABLE(pci, xboxfb_pci_tbl);
+
+/* ------------------------------------------------------------------------- *
+ *
+ * global variables
+ *
+ * ------------------------------------------------------------------------- */
+
+/* command line data, set in xboxfb_setup() */
+static u32 pseudo_palette[17];
+static int flatpanel __initdata = -1; /* Autodetect later */
+static int forceCRTC __initdata = -1;
+static int noaccel   __initdata = 0;
+#ifdef CONFIG_MTRR
+static int nomtrr __initdata = 0;
+#endif
+
+static char *mode_option __initdata = NULL;
+static int  strictmode __initdata = 0;
+
+static xbox_tv_encoding tv_encoding  __initdata = TV_ENC_INVALID;
+static xbox_av_type av_type __initdata = AV_INVALID;
+static int hoc __initdata = -1;
+static int voc __initdata = -1;
+
+static struct fb_fix_screeninfo xboxfb_fix = {
+	.id		= "Xbox",
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.xpanstep	= 1,
+	.ypanstep	= 1,
+};
+
+static struct fb_var_screeninfo xboxfb_default_var = {
+	.xres		= 640,
+	.yres		= 480,
+	.xres_virtual	= 640,
+	.yres_virtual	= 480,
+	.bits_per_pixel	= 8,
+	.red		= {0, 8, 0},
+	.green		= {0, 8, 0},
+	.blue		= {0, 8, 0},
+	.transp		= {0, 0, 0},
+	.activate	= FB_ACTIVATE_NOW,
+	.height		= -1,
+	.width		= -1,
+	.accel_flags	= FB_ACCELF_TEXT,
+	.pixclock	= 39721,
+	.left_margin	= 40,
+	.right_margin	= 24,
+	.upper_margin	= 32,
+	.lower_margin	= 11,
+	.hsync_len	= 96,
+	.vsync_len	= 2,
+	.vmode		= FB_VMODE_NONINTERLACED
+};
+
+static struct fb_var_screeninfo xboxfb_mode_480p = {
+	.xres           = 720,
+	.yres           = 480,
+	.xres_virtual   = 720,
+	.yres_virtual   = 480,
+	.bits_per_pixel = 32,
+	.red            = {0, 8, 16},
+	.green          = {0, 8, 8},
+	.blue           = {0, 8, 0},
+	.transp         = {0, 0, 0},
+	.activate       = FB_ACTIVATE_NOW,
+	.height         = -1,
+	.width          = -1,
+	.accel_flags    = FB_ACCELF_TEXT,
+	.pixclock       = 37000,
+	.left_margin    = 56,
+	.right_margin   = 18,
+	.upper_margin   = 29,
+	.lower_margin   = 9,
+	.hsync_len      = 64,
+	.vsync_len      = 7,
+	.vmode          = FB_VMODE_NONINTERLACED
+};
+
+static struct fb_var_screeninfo xboxfb_mode_720p = {
+	.xres           = 1280,
+	.yres           = 720,
+	.xres_virtual   = 1280,
+	.yres_virtual   = 720,
+	.bits_per_pixel = 8,
+	.red            = {0, 8, 0},
+	.green          = {0, 8, 0},
+	.blue           = {0, 8, 0},
+	.transp         = {0, 0, 0},
+	.activate       = FB_ACTIVATE_NOW,
+	.height         = -1,
+	.width          = -1,
+	.accel_flags    = FB_ACCELF_TEXT,
+	.pixclock       = 13468,
+	.left_margin    = 220,
+	.right_margin   = 70,
+	.upper_margin   = 22,
+	.lower_margin   = 3,
+	.hsync_len      = 80,
+	.vsync_len      = 5,
+	.vmode          = FB_VMODE_NONINTERLACED
+};
+
+static const char* tvEncodingNames[] = {
+        "NTSC",
+        "NTSC-60",
+        "PAL-BDGHI",
+        "PAL-N",
+        "PAL-NC",
+        "PAL-M",
+        "PAL-60"
+};
+
+static const char* avTypeNames[] = {
+        "SCART (RGB)",
+        "S-Video",
+        "VGA (Sync on green)",
+        "HDTV (Component video)",
+        "Composite",
+        "VGA (internal syncs)"
+};
+
+/* from GGI */
+static const struct riva_regs reg_template = {
+	{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,	/* ATTR */
+	 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	 0x41, 0x01, 0x0F, 0x00, 0x00},
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* CRT  */
+	 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3,	/* 0x10 */
+	 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 0x20 */
+	 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 0x30 */
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00,							/* 0x40 */
+	 },
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,	/* GRA  */
+	 0xFF},
+	{0x03, 0x01, 0x0F, 0x00, 0x0E},				/* SEQ  */
+	0xEB							/* MISC */
+};
+
+/*
+ * Backlight control
+ */
+#ifdef CONFIG_PMAC_BACKLIGHT
+
+static int riva_backlight_levels[] = {
+    0x158,
+    0x192,
+    0x1c6,
+    0x200,
+    0x234,
+    0x268,
+    0x2a2,
+    0x2d6,
+    0x310,
+    0x344,
+    0x378,
+    0x3b2,
+    0x3e6,
+    0x41a,
+    0x454,
+    0x534,
+};
+
+static int riva_set_backlight_enable(int on, int level, void *data);
+static int riva_set_backlight_level(int level, void *data);
+static struct backlight_controller riva_backlight_controller = {
+	riva_set_backlight_enable,
+	riva_set_backlight_level
+};
+#endif /* CONFIG_PMAC_BACKLIGHT */
+
+/* ------------------------------------------------------------------------- *
+ *
+ * MMIO access macros
+ *
+ * ------------------------------------------------------------------------- */
+
+static inline void CRTCout(struct riva_par *par, unsigned char index,
+			   unsigned char val)
+{
+	VGA_WR08(par->riva.PCIO, 0x3d4, index);
+	VGA_WR08(par->riva.PCIO, 0x3d5, val);
+}
+
+static inline unsigned char CRTCin(struct riva_par *par,
+				   unsigned char index)
+{
+	VGA_WR08(par->riva.PCIO, 0x3d4, index);
+	return (VGA_RD08(par->riva.PCIO, 0x3d5));
+}
+
+static inline void GRAout(struct riva_par *par, unsigned char index,
+			  unsigned char val)
+{
+	VGA_WR08(par->riva.PVIO, 0x3ce, index);
+	VGA_WR08(par->riva.PVIO, 0x3cf, val);
+}
+
+static inline unsigned char GRAin(struct riva_par *par,
+				  unsigned char index)
+{
+	VGA_WR08(par->riva.PVIO, 0x3ce, index);
+	return (VGA_RD08(par->riva.PVIO, 0x3cf));
+}
+
+static inline void SEQout(struct riva_par *par, unsigned char index,
+			  unsigned char val)
+{
+	VGA_WR08(par->riva.PVIO, 0x3c4, index);
+	VGA_WR08(par->riva.PVIO, 0x3c5, val);
+}
+
+static inline unsigned char SEQin(struct riva_par *par,
+				  unsigned char index)
+{
+	VGA_WR08(par->riva.PVIO, 0x3c4, index);
+	return (VGA_RD08(par->riva.PVIO, 0x3c5));
+}
+
+static inline void ATTRout(struct riva_par *par, unsigned char index,
+			   unsigned char val)
+{
+	VGA_WR08(par->riva.PCIO, 0x3c0, index);
+	VGA_WR08(par->riva.PCIO, 0x3c0, val);
+}
+
+static inline unsigned char ATTRin(struct riva_par *par,
+				   unsigned char index)
+{
+	VGA_WR08(par->riva.PCIO, 0x3c0, index);
+	return (VGA_RD08(par->riva.PCIO, 0x3c1));
+}
+
+static inline void MISCout(struct riva_par *par, unsigned char val)
+{
+	VGA_WR08(par->riva.PVIO, 0x3c2, val);
+}
+
+static inline unsigned char MISCin(struct riva_par *par)
+{
+	return (VGA_RD08(par->riva.PVIO, 0x3cc));
+}
+
+static u8 byte_rev[256] = {
+	0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
+	0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
+	0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
+	0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
+	0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
+	0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
+	0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
+	0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
+	0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
+	0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
+	0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
+	0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
+	0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
+	0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
+	0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
+	0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
+	0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
+	0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
+	0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
+	0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
+	0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
+	0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
+	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
+	0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
+	0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
+	0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
+	0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
+	0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
+	0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
+	0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
+	0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
+	0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
+};
+
+static inline void reverse_order(u32 *l)
+{
+	u8 *a = (u8 *)l;
+	*a = byte_rev[*a], a++;
+	*a = byte_rev[*a], a++;
+	*a = byte_rev[*a], a++;
+	*a = byte_rev[*a];
+}
+
+/* ------------------------------------------------------------------------- *
+ *
+ * cursor stuff
+ *
+ * ------------------------------------------------------------------------- */
+
+/**
+ * xboxfb_load_cursor_image - load cursor image to hardware
+ * @data: address to monochrome bitmap (1 = foreground color, 0 = background)
+ * @par:  pointer to private data
+ * @w:    width of cursor image in pixels
+ * @h:    height of cursor image in scanlines
+ * @bg:   background color (ARGB1555) - alpha bit determines opacity
+ * @fg:   foreground color (ARGB1555)
+ *
+ * DESCRIPTiON:
+ * Loads cursor image based on a monochrome source and mask bitmap.  The
+ * image bits determines the color of the pixel, 0 for background, 1 for
+ * foreground.  Only the affected region (as determined by @w and @h 
+ * parameters) will be updated.
+ *
+ * CALLED FROM:
+ * xboxfb_cursor()
+ */
+static void xboxfb_load_cursor_image(struct riva_par *par, u8 *data8,
+				     u16 bg, u16 fg, u32 w, u32 h)
+{
+	int i, j, k = 0;
+	u32 b, tmp;
+	u32 *data = (u32 *)data8;
+	bg = le16_to_cpu(bg);
+	fg = le16_to_cpu(fg);
+
+	w = (w + 1) & ~1;
+
+	for (i = 0; i < h; i++) {
+		b = *data++;
+		reverse_order(&b);
+		
+		for (j = 0; j < w/2; j++) {
+			tmp = 0;
+#if defined (__BIG_ENDIAN)
+			tmp = (b & (1 << 31)) ? fg << 16 : bg << 16;
+			b <<= 1;
+			tmp |= (b & (1 << 31)) ? fg : bg;
+			b <<= 1;
+#else
+			tmp = (b & 1) ? fg : bg;
+			b >>= 1;
+			tmp |= (b & 1) ? fg << 16 : bg << 16;
+			b >>= 1;
+#endif
+			writel(tmp, &par->riva.CURSOR[k++]);
+		}
+		k += (MAX_CURS - w)/2;
+	}
+}
+
+/* ------------------------------------------------------------------------- *
+ *
+ * general utility functions
+ *
+ * ------------------------------------------------------------------------- */
+
+/**
+ * riva_wclut - set CLUT entry
+ * @chip: pointer to RIVA_HW_INST object
+ * @regnum: register number
+ * @red: red component
+ * @green: green component
+ * @blue: blue component
+ *
+ * DESCRIPTION:
+ * Sets color register @regnum.
+ *
+ * CALLED FROM:
+ * xboxfb_setcolreg()
+ */
+static void riva_wclut(RIVA_HW_INST *chip,
+		       unsigned char regnum, unsigned char red,
+		       unsigned char green, unsigned char blue)
+{
+	VGA_WR08(chip->PDIO, 0x3c8, regnum);
+	VGA_WR08(chip->PDIO, 0x3c9, red);
+	VGA_WR08(chip->PDIO, 0x3c9, green);
+	VGA_WR08(chip->PDIO, 0x3c9, blue);
+}
+
+/**
+ * riva_rclut - read fromCLUT register
+ * @chip: pointer to RIVA_HW_INST object
+ * @regnum: register number
+ * @red: red component
+ * @green: green component
+ * @blue: blue component
+ *
+ * DESCRIPTION:
+ * Reads red, green, and blue from color register @regnum.
+ *
+ * CALLED FROM:
+ * xboxfb_setcolreg()
+ */
+static void riva_rclut(RIVA_HW_INST *chip,
+		       unsigned char regnum, unsigned char *red,
+		       unsigned char *green, unsigned char *blue)
+{
+	
+	VGA_WR08(chip->PDIO, 0x3c8, regnum);
+	*red = VGA_RD08(chip->PDIO, 0x3c9);
+	*green = VGA_RD08(chip->PDIO, 0x3c9);
+	*blue = VGA_RD08(chip->PDIO, 0x3c9);
+}
+
+/**
+ * riva_save_state - saves current chip state
+ * @par: pointer to riva_par object containing info for current riva board
+ * @regs: pointer to riva_regs object
+ *
+ * DESCRIPTION:
+ * Saves current chip state to @regs.
+ *
+ * CALLED FROM:
+ * xboxfb_probe()
+ */
+/* from GGI */
+static void riva_save_state(struct riva_par *par, struct riva_regs *regs)
+{
+	int i;
+
+	par->riva.LockUnlock(&par->riva, 0);
+
+	par->riva.UnloadStateExt(&par->riva, &regs->ext);
+
+	regs->misc_output = MISCin(par);
+
+	for (i = 0; i < NUM_CRT_REGS; i++)
+		regs->crtc[i] = CRTCin(par, i);
+
+	for (i = 0; i < NUM_ATC_REGS; i++)
+		regs->attr[i] = ATTRin(par, i);
+
+	for (i = 0; i < NUM_GRC_REGS; i++)
+		regs->gra[i] = GRAin(par, i);
+
+	for (i = 0; i < NUM_SEQ_REGS; i++)
+		regs->seq[i] = SEQin(par, i);
+}
+
+/**
+ * riva_load_state - loads current chip state
+ * @par: pointer to riva_par object containing info for current riva board
+ * @regs: pointer to riva_regs object
+ *
+ * DESCRIPTION:
+ * Loads chip state from @regs.
+ *
+ * CALLED FROM:
+ * riva_load_video_mode()
+ * xboxfb_probe()
+ * xboxfb_remove()
+ */
+/* from GGI */
+static void riva_load_state(struct riva_par *par, struct riva_regs *regs)
+{
+	RIVA_HW_STATE *state = &regs->ext;
+	int i;
+
+	CRTCout(par, 0x11, 0x00);
+
+	par->riva.LockUnlock(&par->riva, 0);
+
+	par->riva.LoadStateExt(&par->riva, state);
+
+	par->riva.PGRAPH[0x00000820/4] = par->riva_fb_start;
+	par->riva.PGRAPH[0x00000824/4] = par->riva_fb_start;
+	par->riva.PGRAPH[0x00000828/4] = par->riva_fb_start;
+	par->riva.PGRAPH[0x0000082c/4] = par->riva_fb_start;
+
+	par->riva.PGRAPH[0x00000684/4] = par->riva.RamAmountKBytes * 1024 - 1;
+	par->riva.PGRAPH[0x00000688/4] = par->riva.RamAmountKBytes * 1024 - 1;
+	par->riva.PGRAPH[0x0000068c/4] = par->riva.RamAmountKBytes * 1024 - 1;
+	par->riva.PGRAPH[0x00000690/4] = par->riva.RamAmountKBytes * 1024 - 1;
+	par->riva.PRAMDAC[0x00000848/4] = 0x10100111;
+	par->riva.PRAMDAC[0x00000880/4] = 0;
+	par->riva.PRAMDAC[0x000008a0/4] = 0;
+	par->riva.PMC[0x00008908/4] = par->riva.RamAmountKBytes * 1024 - 1;
+	par->riva.PMC[0x0000890c/4] = par->riva.RamAmountKBytes * 1024 - 1;
+	
+        /* It has been decided to leave the GPU in RGB mode always, and handle
+	* the scaling in the encoder, if necessary. This sidesteps the 2.6
+	* kernel cursor issue seen with YUV output */
+	if(par->video_encoder == ENCODER_XCALIBUR) {
+		par->riva.PRAMDAC[0x00000630/4] = 2; // switch GPU to YCrCb
+		/* YUV values: */
+		par->riva.PRAMDAC[0x0000084c/4] = 0x00801080;
+		par->riva.PRAMDAC[0x000008c4/4] = 0x40801080;
+	} else {
+		par->riva.PRAMDAC[0x00000630/4] = 0;
+		/* These two need to be 0 on RGB to fix the maroon
+		* borders issue */
+		par->riva.PRAMDAC[0x0000084c/4] = 0;
+		par->riva.PRAMDAC[0x000008c4/4] = 0;
+	}
+	
+	MISCout(par, regs->misc_output);
+
+	for (i = 0; i < NUM_CRT_REGS; i++) {
+		switch (i) {
+		case 0x0c:
+		case 0x0d:
+		case 0x19:
+		case 0x20 ... 0x40:
+			break;
+		default:
+			CRTCout(par, i, regs->crtc[i]);
+		}
+	}
+
+	for (i = 0; i < NUM_ATC_REGS; i++)
+		ATTRout(par, i, regs->attr[i]);
+
+	for (i = 0; i < NUM_GRC_REGS; i++)
+		GRAout(par, i, regs->gra[i]);
+
+	for (i = 0; i < NUM_SEQ_REGS; i++)
+		SEQout(par, i, regs->seq[i]);
+	tv_save_mode(regs->encoder_regs);
+}
+
+static inline unsigned long xbox_memory_size(void) {
+	/* make a guess on the xbox memory size. There are just
+	two possibilities */
+	if ((num_physpages << PAGE_SHIFT) > 64*1024*1024) {
+		return 128*1024*1024;
+	} else {
+		return 64*1024*1024;
+	}
+}
+
+static inline unsigned long available_framebuffer_memory(void) {
+	return xbox_memory_size() - (num_physpages << PAGE_SHIFT);
+}
+
+/**
+ * riva_load_video_mode - calculate timings
+ * @info: pointer to fb_info object containing info for current riva board
+ *
+ * DESCRIPTION:
+ * Calculate some timings and then send em off to riva_load_state().
+ *
+ * CALLED FROM:
+ * xboxfb_set_par()
+ */
+static void riva_load_video_mode(struct fb_info *info)
+{
+	int bpp, width, height, hDisplaySize, hStart, hTotal, vStart, vTotal;
+	int crtc_hDisplay, crtc_hStart, crtc_hEnd, crtc_hTotal;
+	int crtc_vDisplay, crtc_vStart, crtc_vEnd, crtc_vTotal, dotClock;
+	int crtc_hBlankStart, crtc_hBlankEnd, crtc_vBlankStart, crtc_vBlankEnd;
+	struct riva_par *par = (struct riva_par *) info->par;
+	struct riva_regs newmode;
+	int encoder_ok = 0;	
+	xbox_hdtv_mode hdtv_mode;
+	xbox_video_mode encoder_mode;
+	
+	/* time to calculate */
+	xboxfb_blank(1, info);
+
+	bpp = info->var.bits_per_pixel;
+	if (bpp == 16 && info->var.green.length == 5)
+		bpp = 15;
+	width = info->var.xres_virtual;
+	height = info->var.yres_virtual;
+	hDisplaySize = info->var.xres;
+	hStart = hDisplaySize + info->var.right_margin;
+	hTotal = hDisplaySize + info->var.right_margin +
+		  info->var.hsync_len + info->var.left_margin;
+	vStart = info->var.yres + info->var.lower_margin;
+	vTotal = info->var.yres + info->var.lower_margin +
+		 info->var.vsync_len + info->var.upper_margin;
+	
+	if (par->video_encoder==ENCODER_XCALIBUR) {
+		/* This info should be in the xcalibur.c file, but
+		* the HDTV api doesn't allow for it right now. */
+		hTotal = 779;
+		vTotal = 524;
+	}
+	
+	crtc_hDisplay = (hDisplaySize / 8) - 1;
+	crtc_hStart = (hTotal - 32) / 8;
+	/* crtc_hStart = hStart / 8 - 1; */
+	crtc_hEnd = crtc_hStart + 1;
+	/* crtc_hEnd = (hStart + info->var.hsync_len) / 8 - 1; */
+	crtc_hTotal = hTotal / 8 - 5;
+	crtc_hBlankStart = crtc_hDisplay;
+	crtc_hBlankEnd = crtc_hTotal + 4;
+	
+	crtc_vDisplay = info->var.yres - 1;
+	/* crtc_vStart = vStart - 1; */
+	crtc_vStart = vStart - 1;
+	/* crtc_vEnd = vStart + info->var.vsync_len - 1; */
+	crtc_vEnd = crtc_vStart + 2;
+	crtc_vTotal = vTotal + 2;
+	crtc_vDisplay = info->var.yres - 1;
+	crtc_vBlankStart = crtc_vDisplay;
+	crtc_vBlankEnd = crtc_vTotal + 1;
+	
+	dotClock = 1000000000 / info->var.pixclock;
+
+	memcpy(&newmode, &reg_template, sizeof(struct riva_regs));
+
+	if ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED)
+		vTotal |= 1;
+
+	if (par->FlatPanel) {
+		crtc_vStart = crtc_vTotal - 3;
+		crtc_vEnd = crtc_vTotal - 2;
+		crtc_vBlankStart = crtc_vStart;
+		crtc_hStart = crtc_hTotal - 3;
+		crtc_hEnd = crtc_hTotal - 2;
+		crtc_hBlankEnd = crtc_hTotal + 4;
+	}
+
+	newmode.ext.bpp = bpp;
+	newmode.ext.fb_start = par->riva_fb_start;
+
+	switch (par->av_type) {
+		case AV_HDTV:
+			if (info->var.yres > 800) {
+				hdtv_mode = HDTV_1080i;
+				crtc_vStart = vStart + 31;
+				crtc_vEnd = crtc_vStart + 2;
+			}
+			else if (info->var.yres > 600) {
+				hdtv_mode = HDTV_720p;
+			}
+			else hdtv_mode = HDTV_480p;
+
+			switch (par->video_encoder) {
+				case ENCODER_CONEXANT:
+					encoder_ok = conexant_calc_hdtv_mode(hdtv_mode, dotClock, &(newmode.encoder_regs));
+					break;
+				case ENCODER_FOCUS:
+					encoder_ok = focus_calc_hdtv_mode(hdtv_mode, dotClock, &(newmode.encoder_regs));
+					break;
+				case ENCODER_XCALIBUR:
+					encoder_ok = xcalibur_calc_hdtv_mode(hdtv_mode, dotClock, &(newmode.encoder_regs));
+					break;
+				default:
+					printk("Error - unknown encoder type detected\n");
+			}
+			newmode.ext.vend = info->var.yres - 1;
+			newmode.ext.vtotal = vTotal;
+			newmode.ext.vcrtc = info->var.yres - 1;
+			newmode.ext.vsyncstart = vStart;
+			newmode.ext.vsyncend = vStart + 3;
+			newmode.ext.vvalidstart = 0;
+			newmode.ext.vvalidend = info->var.yres - 1;
+			newmode.ext.hend = info->var.xres - 1;
+			newmode.ext.htotal = hTotal;
+			newmode.ext.hcrtc = info->var.xres - 1;
+			newmode.ext.hsyncstart = hStart;
+			newmode.ext.hsyncend = hStart + 32;
+			newmode.ext.hvalidstart = 0;
+			newmode.ext.hvalidend = info->var.xres - 1;
+			break;
+	
+		case AV_VGA:
+		case AV_VGA_SOG:
+			switch (par->video_encoder) {
+				case ENCODER_CONEXANT:
+					encoder_ok = conexant_calc_vga_mode(par->av_type, dotClock, &(newmode.encoder_regs));
+					break;
+				case ENCODER_FOCUS:
+					//No vga functions as yet - so set up for 480p otherwise we dont boot at all. 
+					encoder_ok = focus_calc_hdtv_mode(HDTV_480p, dotClock, &(newmode.encoder_regs));
+					break;
+				case ENCODER_XCALIBUR:
+					//No vga functions as yet - so set up for 480p otherwise we dont boot at all. 
+					encoder_ok = xcalibur_calc_hdtv_mode(HDTV_480p, dotClock, &(newmode.encoder_regs));
+					break;
+				default:
+					printk("Error - unknown encoder type detected\n");
+			}
+			newmode.ext.vend = info->var.yres - 1;
+			newmode.ext.vtotal = vTotal;
+			newmode.ext.vcrtc = info->var.yres - 1;
+			newmode.ext.vsyncstart = vStart;
+			newmode.ext.vsyncend = vStart + 3;
+			newmode.ext.vvalidstart = 0;
+			newmode.ext.vvalidend = info->var.yres - 1;
+			newmode.ext.hend = info->var.xres - 1;
+			newmode.ext.htotal = hTotal;
+			newmode.ext.hcrtc = info->var.xres - 1;
+			newmode.ext.hsyncstart = hStart;
+			newmode.ext.hsyncend = hStart + 32;
+			newmode.ext.hvalidstart = 0;
+			newmode.ext.hvalidend = info->var.xres - 1;
+			break;
+	
+		default:	
+			/* Normal composite */
+			encoder_mode.xres = info->var.xres;
+			encoder_mode.yres = info->var.yres;
+			encoder_mode.tv_encoding = par->tv_encoding;
+			encoder_mode.bpp = bpp;
+			encoder_mode.hoc = par->hoc;
+			encoder_mode.voc = par->voc;
+			encoder_mode.av_type = par->av_type;
+	
+			switch (par->video_encoder) {
+				case ENCODER_CONEXANT:
+					encoder_ok = conexant_calc_mode(&encoder_mode, &newmode);
+					break;
+				case ENCODER_FOCUS:
+					encoder_ok = focus_calc_mode(&encoder_mode, &newmode);
+					break;
+				case ENCODER_XCALIBUR:
+					encoder_ok = xcalibur_calc_mode(&encoder_mode, &newmode);
+					break;
+				default:
+					printk("Error - unknown encoder type detected\n");
+			}
+	
+			crtc_hDisplay = (newmode.ext.crtchdispend / 8) - 1;
+			crtc_hStart = (newmode.ext.htotal - 32) / 8;
+			crtc_hEnd = crtc_hStart + 1;
+			crtc_hTotal = (newmode.ext.htotal) / 8 - 5;
+			crtc_hBlankStart = crtc_hDisplay;
+			crtc_hBlankEnd = (newmode.ext.htotal) / 8 - 1;
+			
+			crtc_vDisplay = info->var.yres - 1;
+			crtc_vStart = newmode.ext.crtcvstart;
+			crtc_vEnd = newmode.ext.crtcvstart + 3;
+			crtc_vTotal = newmode.ext.crtcvtotal;
+			crtc_vBlankStart = crtc_vDisplay;
+			crtc_vBlankEnd = crtc_vTotal + 1;
+	}
+
+	if (encoder_ok) {
+		newmode.crtc[0x0] = Set8Bits (crtc_hTotal); 
+		newmode.crtc[0x1] = Set8Bits (crtc_hDisplay);
+		newmode.crtc[0x2] = Set8Bits (crtc_hBlankStart);
+		newmode.crtc[0x3] = SetBitField (crtc_hBlankEnd, 4: 0, 4:0) | SetBit (7);
+		newmode.crtc[0x4] = Set8Bits (crtc_hStart);
+		newmode.crtc[0x5] = SetBitField (crtc_hBlankEnd, 5: 5, 7:7)
+			| SetBitField (crtc_hEnd, 4: 0, 4:0);
+		newmode.crtc[0x6] = SetBitField (crtc_vTotal, 7: 0, 7:0);
+		newmode.crtc[0x7] = SetBitField (crtc_vTotal, 8: 8, 0:0)
+			| SetBitField (crtc_vDisplay, 8: 8, 1:1)
+			| SetBitField (crtc_vStart, 8: 8, 2:2)
+			| SetBitField (crtc_vBlankStart, 8: 8, 3:3)
+			| SetBit (4)
+			| SetBitField (crtc_vTotal, 9: 9, 5:5)
+			| SetBitField (crtc_vDisplay, 9: 9, 6:6)
+			| SetBitField (crtc_vStart, 9: 9, 7:7);
+		newmode.crtc[0x9] = SetBitField (crtc_vBlankStart, 9: 9, 5:5)
+			| SetBit (6);
+		newmode.crtc[0x10] = Set8Bits (crtc_vStart);
+		newmode.crtc[0x11] = SetBitField (crtc_vEnd, 3: 0, 3:0)
+			| SetBit (5);
+		newmode.crtc[0x12] = Set8Bits (crtc_vDisplay);
+		newmode.crtc[0x13] = (width / 8) * ((bpp + 1) / 8);
+		newmode.crtc[0x15] = Set8Bits (crtc_vBlankStart);
+		newmode.crtc[0x16] = Set8Bits (crtc_vBlankEnd);
+	
+		newmode.ext.screen = SetBitField(crtc_hBlankEnd,6:6,4:4)
+			| SetBitField(crtc_vBlankStart,10:10,3:3)
+			| SetBitField(crtc_vStart,10:10,2:2)
+			| SetBitField(crtc_vDisplay,10:10,1:1)
+			| SetBitField(crtc_vTotal,10:10,0:0);
+		newmode.ext.horiz  = SetBitField(crtc_hTotal,8:8,0:0) 
+			| SetBitField(crtc_hDisplay,8:8,1:1)
+			| SetBitField(crtc_hBlankStart,8:8,2:2)
+			| SetBitField(crtc_hStart,8:8,3:3);
+		newmode.ext.extra  = SetBitField(crtc_vTotal,11:11,0:0)
+			| SetBitField(crtc_vDisplay,11:11,2:2)
+			| SetBitField(crtc_vStart,11:11,4:4)
+			| SetBitField(crtc_vBlankStart,11:11,6:6); 
+	
+		if ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {
+			int tmp = (crtc_hTotal >> 1) & ~1;
+			newmode.ext.interlace = Set8Bits(tmp);
+			newmode.ext.horiz |= SetBitField(tmp, 8:8,4:4);
+		} else 
+			newmode.ext.interlace = 0xff; /* interlace off */
+	
+		if (par->riva.Architecture >= NV_ARCH_10)
+			/* use 2 KByte at top of framebuffer */
+			par->riva.CURSOR = (U032 *)(info->screen_base + info->fix.smem_len - 2 * 1024);
+	
+		if (info->var.sync & FB_SYNC_HOR_HIGH_ACT)
+			newmode.misc_output &= ~0x40;
+		else
+			newmode.misc_output |= 0x40;
+		if (info->var.sync & FB_SYNC_VERT_HIGH_ACT)
+			newmode.misc_output &= ~0x80;
+		else
+			newmode.misc_output |= 0x80;	
+	
+		par->riva.CalcStateExt(&par->riva, &newmode.ext, bpp, width,
+					hDisplaySize, height, dotClock);
+	
+		newmode.ext.scale = par->riva.PRAMDAC[0x00000848/4] & 0xfff000ff;
+		if (par->FlatPanel == 1) {
+			newmode.ext.pixel |= (1 << 7);
+			newmode.ext.scale |= (1 << 8);
+		}
+		if (par->SecondCRTC) {
+			newmode.ext.head  = par->riva.PCRTC0[0x00000860/4] & ~0x00001000;
+			newmode.ext.head2 = par->riva.PCRTC0[0x00002860/4] | 0x00001000;
+			newmode.ext.crtcOwner = 3;
+			newmode.ext.pllsel |= 0x20000800;
+			newmode.ext.vpll2 = newmode.ext.vpll;
+		} else if (par->riva.twoHeads) {
+			newmode.ext.head  =  par->riva.PCRTC0[0x00000860/4] | 0x00001000;
+			newmode.ext.head2 =  par->riva.PCRTC0[0x00002860/4] & ~0x00001000;
+			newmode.ext.crtcOwner = 0;
+			newmode.ext.vpll2 = par->riva.PRAMDAC0[0x00000520/4];
+		}
+		if (par->FlatPanel == 1) {
+			newmode.ext.pixel |= (1 << 7);
+			newmode.ext.scale |= (1 << 8);
+		}
+		newmode.ext.cursorConfig = 0x02000100;
+		par->current_state = newmode;
+		riva_load_state(par, &par->current_state);
+		tv_load_mode(newmode.encoder_regs);
+		par->riva.LockUnlock(&par->riva, 0); /* important for HW cursor */
+	}
+	else {
+		printk("Error: Unable to set encoder resolution %dx%d\n",info->var.xres, info->var.yres);
+	}
+	
+	xboxfb_blank(0, info);
+}
+
+static void riva_update_var(struct fb_var_screeninfo *var, struct fb_videomode *modedb)
+{
+	NVTRACE_ENTER();
+	var->xres = var->xres_virtual = modedb->xres;
+	var->yres = modedb->yres;
+        if (var->yres_virtual < var->yres)
+	    var->yres_virtual = var->yres;
+        var->xoffset = var->yoffset = 0;
+        var->pixclock = modedb->pixclock;
+        var->left_margin = modedb->left_margin;
+        var->right_margin = modedb->right_margin;
+        var->upper_margin = modedb->upper_margin;
+        var->lower_margin = modedb->lower_margin;
+        var->hsync_len = modedb->hsync_len;
+        var->vsync_len = modedb->vsync_len;
+        var->sync = modedb->sync;
+        var->vmode = modedb->vmode;
+	NVTRACE_LEAVE();
+}
+
+/**
+ * xboxfb_do_maximize - 
+ * @info: pointer to fb_info object containing info for current riva board
+ * @var:
+ * @nom:
+ * @den:
+ *
+ * DESCRIPTION:
+ * .
+ *
+ * RETURNS:
+ * -EINVAL on failure, 0 on success
+ * 
+ *
+ * CALLED FROM:
+ * xboxfb_check_var()
+ */
+static int xboxfb_do_maximize(struct fb_info *info,
+			      struct fb_var_screeninfo *var,
+			      int nom, int den)
+{
+	static struct {
+		int xres, yres;
+	} modes[] = {
+		{1600, 1280},
+		{1280, 1024},
+		{1024, 768},
+		{800, 600},
+		{640, 480},
+		{-1, -1}
+	};
+	int i;
+
+	NVTRACE_ENTER();
+	/* use highest possible virtual resolution */
+	if (var->xres_virtual == -1 && var->yres_virtual == -1) {
+#ifdef CONFIG_FB_RIVA_DEBUG
+		printk(KERN_WARNING PFX
+		       "using maximum available virtual resolution\n");
+#endif
+		for (i = 0; modes[i].xres != -1; i++) {
+			if (modes[i].xres * nom / den * modes[i].yres <
+			    info->fix.smem_len)
+				break;
+		}
+		if (modes[i].xres == -1) {
+#ifdef CONFIG_FB_RIVA_DEBUG
+		printk(KERN_ERR PFX
+			       "could not find a virtual resolution that fits into video memory!!\n");
+#endif
+			NVTRACE("EXIT - EINVAL error\n");
+			return -EINVAL;
+		}
+		var->xres_virtual = modes[i].xres;
+		var->yres_virtual = modes[i].yres;
+
+#ifdef CONFIG_FB_RIVA_DEBUG
+		printk(KERN_INFO PFX
+		       "virtual resolution set to maximum of %dx%d\n",
+		       var->xres_virtual, var->yres_virtual);
+#endif
+	} else if (var->xres_virtual == -1) {
+		var->xres_virtual = (info->fix.smem_len * den /
+			(nom * var->yres_virtual)) & ~15;
+#ifdef CONFIG_FB_RIVA_DEBUG
+		printk(KERN_WARNING PFX
+		       "setting virtual X resolution to %d\n", var->xres_virtual);
+#endif
+	} else if (var->yres_virtual == -1) {
+		var->xres_virtual = (var->xres_virtual + 15) & ~15;
+		var->yres_virtual = info->fix.smem_len * den /
+			(nom * var->xres_virtual);
+#ifdef CONFIG_FB_RIVA_DEBUG
+		printk(KERN_WARNING PFX
+		       "setting virtual Y resolution to %d\n", var->yres_virtual);
+#endif
+	} else {
+		var->xres_virtual = (var->xres_virtual + 15) & ~15;
+		if (var->xres_virtual * nom / den * var->yres_virtual > info->fix.smem_len) {
+#ifdef CONFIG_FB_RIVA_DEBUG
+			printk(KERN_ERR PFX
+			       "mode %dx%dx%d rejected...resolution too high to fit into video memory!\n",
+			       var->xres, var->yres, var->bits_per_pixel);
+#endif
+			NVTRACE("EXIT - EINVAL error\n");
+			return -EINVAL;
+		}
+	}
+	
+	if (var->xres_virtual * nom / den >= 8192) {
+#ifdef CONFIG_FB_RIVA_DEBUG
+		printk(KERN_WARNING PFX
+		       "virtual X resolution (%d) is too high, lowering to %d\n",
+		       var->xres_virtual, 8192 * den / nom - 16);
+#endif
+		var->xres_virtual = 8192 * den / nom - 16;
+	}
+	
+	if (var->xres_virtual < var->xres) {
+#ifdef CONFIG_FB_RIVA_DEBUG
+		printk(KERN_ERR PFX
+		       "virtual X resolution (%d) is smaller than real\n", var->xres_virtual);
+#endif
+		return -EINVAL;
+	}
+
+	if (var->yres_virtual < var->yres) {
+#ifdef CONFIG_FB_RIVA_DEBUG
+		printk(KERN_ERR PFX
+		       "virtual Y resolution (%d) is smaller than real\n", var->yres_virtual);
+#endif
+		return -EINVAL;
+	}
+	if (var->yres_virtual > 0x7fff/nom)
+		var->yres_virtual = 0x7fff/nom;
+	if (var->xres_virtual > 0x7fff/nom)
+		var->xres_virtual = 0x7fff/nom;
+	NVTRACE_LEAVE();
+	return 0;
+}
+
+static void
+riva_set_pattern(struct riva_par *par, int clr0, int clr1, int pat0, int pat1)
+{
+	RIVA_FIFO_FREE(par->riva, Patt, 4);
+	NV_WR32(&par->riva.Patt->Color0, 0, clr0);
+	NV_WR32(&par->riva.Patt->Color1, 0, clr1);
+	NV_WR32(par->riva.Patt->Monochrome, 0, pat0);
+	NV_WR32(par->riva.Patt->Monochrome, 4, pat1);
+}
+
+/* acceleration routines */
+inline void wait_for_idle(struct riva_par *par)
+{
+	while (par->riva.Busy(&par->riva));
+}
+
+/*
+ * Set ROP.  Translate X rop into ROP3.  Internal routine.
+ */
+static void
+riva_set_rop_solid(struct riva_par *par, int rop)
+{
+	riva_set_pattern(par, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);
+        RIVA_FIFO_FREE(par->riva, Rop, 1);
+        NV_WR32(&par->riva.Rop->Rop3, 0, rop);
+
+}
+
+void riva_setup_accel(struct fb_info *info)
+{
+	struct riva_par *par = (struct riva_par *) info->par;
+
+	RIVA_FIFO_FREE(par->riva, Clip, 2);
+	NV_WR32(&par->riva.Clip->TopLeft, 0, 0x0);
+	NV_WR32(&par->riva.Clip->WidthHeight, 0,
+		(info->var.xres_virtual & 0xffff) |
+		(info->var.yres_virtual << 16));
+	riva_set_rop_solid(par, 0xcc);
+	wait_for_idle(par);
+}
+
+/**
+ * riva_get_cmap_len - query current color map length
+ * @var: standard kernel fb changeable data
+ *
+ * DESCRIPTION:
+ * Get current color map length.
+ *
+ * RETURNS:
+ * Length of color map
+ *
+ * CALLED FROM:
+ * xboxfb_setcolreg()
+ */
+static int riva_get_cmap_len(const struct fb_var_screeninfo *var)
+{
+	int rc = 256;		/* reasonable default */
+
+	switch (var->green.length) {
+	case 8:
+		rc = 256;	/* 256 entries (2^8), 8 bpp and RGB8888 */
+		break;
+	case 5:
+		rc = 32;	/* 32 entries (2^5), 16 bpp, RGB555 */
+		break;
+	case 6:
+		rc = 64;	/* 64 entries (2^6), 16 bpp, RGB565 */
+		break;		
+	default:
+		/* should not occur */
+		break;
+	}
+	return rc;
+}
+
+/* ------------------------------------------------------------------------- *
+ *
+ * Backlight operations
+ *
+ * ------------------------------------------------------------------------- */
+
+#ifdef CONFIG_PMAC_BACKLIGHT
+static int riva_set_backlight_enable(int on, int level, void *data)
+{
+	struct riva_par *par = (struct riva_par *)data;
+	U032 tmp_pcrt, tmp_pmc;
+
+	tmp_pmc = par->riva.PMC[0x10F0/4] & 0x0000FFFF;
+	tmp_pcrt = par->riva.PCRTC0[0x081C/4] & 0xFFFFFFFC;
+	if(on && (level > BACKLIGHT_OFF)) {
+		tmp_pcrt |= 0x1;
+		tmp_pmc |= (1 << 31); // backlight bit
+		tmp_pmc |= riva_backlight_levels[level-1] << 16; // level
+	}
+	par->riva.PCRTC0[0x081C/4] = tmp_pcrt;
+	par->riva.PMC[0x10F0/4] = tmp_pmc;
+	return 0;
+}
+
+static int riva_set_backlight_level(int level, void *data)
+{
+	return riva_set_backlight_enable(1, level, data);
+}
+#endif /* CONFIG_PMAC_BACKLIGHT */
+
+/* ------------------------------------------------------------------------- *
+ *
+ * framebuffer operations
+ *
+ * ------------------------------------------------------------------------- */
+
+static int xboxfb_open(struct fb_info *info, int user)
+{
+	struct riva_par *par = (struct riva_par *) info->par;
+	int cnt = atomic_read(&par->ref_count);
+
+	if (!cnt) {
+		memset(&par->state, 0, sizeof(struct vgastate));
+		par->state.flags = VGA_SAVE_MODE  | VGA_SAVE_FONTS;
+		/* save the DAC for Riva128 */
+		if (par->riva.Architecture == NV_ARCH_03)
+			par->state.flags |= VGA_SAVE_CMAP;
+		save_vga(&par->state);
+
+		RivaGetConfig(&par->riva, par->Chipset);
+		par->riva.CURSOR = (U032*)(info->screen_base + info->fix.smem_len);
+		par->riva.PCRTC[0x00000800/4] = par->riva_fb_start;
+		par->riva.PGRAPH[0x00000820/4] = par->riva_fb_start;
+		par->riva.PGRAPH[0x00000824/4] = par->riva_fb_start;
+		par->riva.PGRAPH[0x00000828/4] = par->riva_fb_start;
+		par->riva.PGRAPH[0x0000082c/4] = par->riva_fb_start;
+		
+		par->riva.PGRAPH[0x00000684/4] = par->riva.RamAmountKBytes * 1024 - 1;
+		par->riva.PGRAPH[0x00000688/4] = par->riva.RamAmountKBytes * 1024 - 1;
+		par->riva.PGRAPH[0x0000068c/4] = par->riva.RamAmountKBytes * 1024 - 1;
+		par->riva.PGRAPH[0x00000690/4] = par->riva.RamAmountKBytes * 1024 - 1;
+		par->riva.PMC[0x00008908/4] = par->riva.RamAmountKBytes * 1024 - 1;
+		par->riva.PMC[0x0000890c/4] = par->riva.RamAmountKBytes * 1024 - 1;
+		
+		/* vgaHWunlock() + riva unlock (0x7F) */		
+		CRTCout(par, 0x11, 0xFF);
+		par->riva.LockUnlock(&par->riva, 0);
+	
+		riva_save_state(par, &par->initial_state);
+	}
+	atomic_inc(&par->ref_count);
+	return 0;
+}
+
+static int xboxfb_release(struct fb_info *info, int user)
+{
+	struct riva_par *par = (struct riva_par *) info->par;
+	int cnt = atomic_read(&par->ref_count);
+
+	if (!cnt)
+		return -EINVAL;
+	if (cnt == 1) {
+		par->riva.LockUnlock(&par->riva, 0);
+		par->riva.LoadStateExt(&par->riva, &par->initial_state.ext);
+		riva_load_state(par, &par->initial_state);
+#ifdef CONFIG_X86
+		restore_vga(&par->state);
+#endif
+		par->riva.LockUnlock(&par->riva, 1);
+	}
+	atomic_dec(&par->ref_count);
+	return 0;
+}
+
+static int xboxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct fb_videomode *mode;
+	struct riva_par *par = (struct riva_par *) info->par;
+	int nom, den;		/* translating from pixels->bytes */
+	int mode_valid = 0;
+	
+	NVTRACE_ENTER();
+	switch (var->bits_per_pixel) {
+	case 1 ... 8:
+		var->red.offset = var->green.offset = var->blue.offset = 0;
+		var->red.length = var->green.length = var->blue.length = 8;
+		var->bits_per_pixel = 8;
+		nom = den = 1;
+		break;
+	case 9 ... 15:
+		var->green.length = 5;
+		/* fall through */
+	case 16:
+		var->bits_per_pixel = 16;
+		/* The Riva128 supports RGB555 only */
+		if (par->riva.Architecture == NV_ARCH_03)
+			var->green.length = 5;
+		if (var->green.length == 5) {
+			/* 0rrrrrgg gggbbbbb */
+			var->red.offset = 10;
+			var->green.offset = 5;
+			var->blue.offset = 0;
+			var->red.length = 5;
+			var->green.length = 5;
+			var->blue.length = 5;
+		} else {
+			/* rrrrrggg gggbbbbb */
+			var->red.offset = 11;
+			var->green.offset = 5;
+			var->blue.offset = 0;
+			var->red.length = 5;
+			var->green.length = 6;
+			var->blue.length = 5;
+		}
+		nom = 2;
+		den = 1;
+		break;
+	case 17 ... 32:
+		var->red.length = var->green.length = var->blue.length = 8;
+		var->bits_per_pixel = 32;
+		var->red.offset = 16;
+		var->green.offset = 8;
+		var->blue.offset = 0;
+		nom = 4;
+		den = 1;
+		break;
+	default:
+		printk(KERN_ERR PFX
+		       "mode %dx%dx%d rejected...color depth not supported.\n",
+		       var->xres, var->yres, var->bits_per_pixel);
+		NVTRACE("EXIT, returning -EINVAL\n");
+		return -EINVAL;
+	}
+
+	if (!strictmode) {
+		if (!info->monspecs.vfmax || !info->monspecs.hfmax ||
+		    !info->monspecs.dclkmax || !fb_validate_mode(var, info))
+			mode_valid = 1;
+	}
+
+	/* calculate modeline if supported by monitor */
+	if (!mode_valid && info->monspecs.gtf) {
+		if (!fb_get_mode(FB_MAXTIMINGS, 0, var, info))
+			mode_valid = 1;
+	}
+
+	if (!mode_valid) {
+		mode = fb_find_best_mode(var, &info->modelist);
+		if (mode) {
+			riva_update_var(var, mode);
+			mode_valid = 1;
+		}
+	}
+
+	if (!mode_valid && info->monspecs.modedb_len)
+		return -EINVAL;
+
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->yres_virtual <= var->yres)
+		var->yres_virtual = -1;
+	if (xboxfb_do_maximize(info, var, nom, den) < 0)
+		return -EINVAL;
+
+	if (var->xoffset < 0)
+		var->xoffset = 0;
+	if (var->yoffset < 0)
+		var->yoffset = 0;
+
+	/* truncate xoffset and yoffset to maximum if too high */
+	if (var->xoffset > var->xres_virtual - var->xres)
+		var->xoffset = var->xres_virtual - var->xres - 1;
+
+	if (var->yoffset > var->yres_virtual - var->yres)
+		var->yoffset = var->yres_virtual - var->yres - 1;
+
+	var->red.msb_right = 
+	    var->green.msb_right =
+	    var->blue.msb_right =
+	    var->transp.offset = var->transp.length = var->transp.msb_right = 0;
+	NVTRACE_LEAVE();
+	return 0;
+}
+
+static int xboxfb_set_par(struct fb_info *info)
+{
+	struct riva_par *par = (struct riva_par *) info->par;
+
+	NVTRACE_ENTER();
+	/* vgaHWunlock() + riva unlock (0x7F) */
+	CRTCout(par, 0x11, 0xFF);
+	par->riva.LockUnlock(&par->riva, 0);
+	riva_load_video_mode(info);
+	if(!(info->flags & FBINFO_HWACCEL_DISABLED))
+		riva_setup_accel(info);
+	
+	par->cursor_reset = 1;
+	info->fix.line_length = (info->var.xres_virtual * (info->var.bits_per_pixel >> 3));
+	info->fix.visual = (info->var.bits_per_pixel == 8) ?
+				FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;
+
+	if (info->flags & FBINFO_HWACCEL_DISABLED)
+		info->pixmap.scan_align = 1;
+	else
+		info->pixmap.scan_align = 4;
+	NVTRACE_LEAVE();
+	return 0;
+}
+
+/**
+ * xboxfb_pan_display
+ * @var: standard kernel fb changeable data
+ * @con: TODO
+ * @info: pointer to fb_info object containing info for current riva board
+ *
+ * DESCRIPTION:
+ * Pan (or wrap, depending on the `vmode' field) the display using the
+ * `xoffset' and `yoffset' fields of the `var' structure.
+ * If the values don't fit, return -EINVAL.
+ *
+ * This call looks only at xoffset, yoffset and the FB_VMODE_YWRAP flag
+ */
+static int xboxfb_pan_display(struct fb_var_screeninfo *var,
+			      struct fb_info *info)
+{
+	struct riva_par *par = (struct riva_par *)info->par;
+	unsigned int base;
+
+	NVTRACE_ENTER();
+	if (var->xoffset > (var->xres_virtual - var->xres))
+		return -EINVAL;
+	if (var->yoffset > (var->yres_virtual - var->yres))
+		return -EINVAL;
+
+	if (var->vmode & FB_VMODE_YWRAP) {
+		if (var->yoffset < 0
+		    || var->yoffset >= info->var.yres_virtual
+		    || var->xoffset) return -EINVAL;
+	} else {
+		if (var->xoffset + info->var.xres > info->var.xres_virtual ||
+		    var->yoffset + info->var.yres > info->var.yres_virtual)
+			return -EINVAL;
+	}
+
+	base = var->yoffset * info->fix.line_length + var->xoffset;
+	base += par->riva_fb_start;
+
+	par->riva.SetStartAddress(&par->riva, base);
+
+	info->var.xoffset = var->xoffset;
+	info->var.yoffset = var->yoffset;
+
+	if (var->vmode & FB_VMODE_YWRAP)
+		info->var.vmode |= FB_VMODE_YWRAP;
+	else
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+	NVTRACE_LEAVE();
+	return 0;
+}
+
+static int xboxfb_blank(int blank, struct fb_info *info)
+{
+	struct riva_par *par= (struct riva_par *)info->par;
+	unsigned char tmp, vesa;
+
+	tmp = SEQin(par, 0x01) & ~0x20;	/* screen on/off */
+	vesa = CRTCin(par, 0x1a) & ~0xc0;	/* sync on/off */
+
+	NVTRACE_ENTER();
+
+	if (blank)
+		tmp |= 0x20;
+
+	switch (blank) {
+	case FB_BLANK_UNBLANK:
+	case FB_BLANK_NORMAL:
+		break;
+	case FB_BLANK_VSYNC_SUSPEND:
+		vesa |= 0x80;
+		break;
+	case FB_BLANK_HSYNC_SUSPEND:
+		vesa |= 0x40;
+		break;
+	case FB_BLANK_POWERDOWN:
+		vesa |= 0xc0;
+		break;
+	}
+
+	SEQout(par, 0x01, tmp);
+	CRTCout(par, 0x1a, vesa);
+
+#ifdef CONFIG_PMAC_BACKLIGHT
+	if ( par->FlatPanel && _machine == _MACH_Pmac) {
+		set_backlight_enable(!blank);
+	}
+#endif
+
+	NVTRACE_LEAVE();
+
+	return 0;
+}
+
+/**
+ * xboxfb_setcolreg
+ * @regno: register index
+ * @red: red component
+ * @green: green component
+ * @blue: blue component
+ * @transp: transparency
+ * @info: pointer to fb_info object containing info for current riva board
+ *
+ * DESCRIPTION:
+ * Set a single color register. The values supplied have a 16 bit
+ * magnitude.
+ *
+ * RETURNS:
+ * Return != 0 for invalid regno.
+ *
+ * CALLED FROM:
+ * fbcmap.c:fb_set_cmap()
+ */
+static int xboxfb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			  unsigned blue, unsigned transp,
+			  struct fb_info *info)
+{
+	struct riva_par *par = (struct riva_par *)info->par;
+	RIVA_HW_INST *chip = &par->riva;
+	int i;
+
+	if (regno >= riva_get_cmap_len(&info->var))
+			return -EINVAL;
+
+	if (info->var.grayscale) {
+		/* gray = 0.30*R + 0.59*G + 0.11*B */
+		red = green = blue =
+		    (red * 77 + green * 151 + blue * 28) >> 8;
+	}
+
+	if (regno < 16 && info->fix.visual == FB_VISUAL_DIRECTCOLOR) {
+		((u32 *) info->pseudo_palette)[regno] =
+			(regno << info->var.red.offset) |
+			(regno << info->var.green.offset) |
+			(regno << info->var.blue.offset);
+		/*
+		 * The Riva128 2D engine requires color information in
+		 * TrueColor format even if framebuffer is in DirectColor
+		 */
+		if (par->riva.Architecture == NV_ARCH_03) {
+			switch (info->var.bits_per_pixel) {
+			case 16:
+				par->palette[regno] = ((red & 0xf800) >> 1) |
+					((green & 0xf800) >> 6) |
+					((blue & 0xf800) >> 11);
+				break;
+			case 32:
+				par->palette[regno] = ((red & 0xff00) << 8) |
+					((green & 0xff00)) |
+					((blue & 0xff00) >> 8);
+				break;
+			}
+		}
+	}
+
+	switch (info->var.bits_per_pixel) {
+	case 8:
+		/* "transparent" stuff is completely ignored. */
+		riva_wclut(chip, regno, red >> 8, green >> 8, blue >> 8);
+		break;
+	case 16:
+		if (info->var.green.length == 5) {
+			for (i = 0; i < 8; i++) {
+				riva_wclut(chip, regno*8+i, red >> 8,
+					   green >> 8, blue >> 8);
+			}
+		} else {
+			u8 r, g, b;
+
+			if (regno < 32) {
+				for (i = 0; i < 8; i++) {
+					riva_wclut(chip, regno*8+i,
+						   red >> 8, green >> 8,
+						   blue >> 8);
+				}
+			}
+			riva_rclut(chip, regno*4, &r, &g, &b);
+			for (i = 0; i < 4; i++)
+				riva_wclut(chip, regno*4+i, r,
+					   green >> 8, b);
+		}
+		break;
+	case 32:
+		riva_wclut(chip, regno, red >> 8, green >> 8, blue >> 8);
+		break;
+	default:
+		/* do nothing */
+		break;
+	}
+	return 0;
+}
+
+/**
+ * xboxfb_fillrect - hardware accelerated color fill function
+ * @info: pointer to fb_info structure
+ * @rect: pointer to fb_fillrect structure
+ *
+ * DESCRIPTION:
+ * This function fills up a region of framebuffer memory with a solid
+ * color with a choice of two different ROP's, copy or invert.
+ *
+ * CALLED FROM:
+ * framebuffer hook
+ */
+static void xboxfb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)
+{
+	struct riva_par *par = (struct riva_par *) info->par;
+	u_int color, rop = 0;
+
+	if ((info->flags & FBINFO_HWACCEL_DISABLED)) {
+		cfb_fillrect(info, rect);
+		return;
+	}
+
+	if (info->var.bits_per_pixel == 8)
+		color = rect->color;
+	else {
+		if (par->riva.Architecture != NV_ARCH_03)
+			color = ((u32 *)info->pseudo_palette)[rect->color];
+		else
+			color = par->palette[rect->color];
+	}
+
+	switch (rect->rop) {
+	case ROP_XOR:
+		rop = 0x66;
+		break;
+	case ROP_COPY:
+	default:
+		rop = 0xCC;
+		break;
+	}
+
+	riva_set_rop_solid(par, rop);
+
+	RIVA_FIFO_FREE(par->riva, Bitmap, 1);
+	NV_WR32(&par->riva.Bitmap->Color1A, 0, color);
+
+	RIVA_FIFO_FREE(par->riva, Bitmap, 2);
+	NV_WR32(&par->riva.Bitmap->UnclippedRectangle[0].TopLeft, 0,
+		(rect->dx << 16) | rect->dy);
+	mb();
+	NV_WR32(&par->riva.Bitmap->UnclippedRectangle[0].WidthHeight, 0,
+		(rect->width << 16) | rect->height);
+	mb();
+	riva_set_rop_solid(par, 0xcc);
+
+}
+
+/**
+ * xboxfb_copyarea - hardware accelerated blit function
+ * @info: pointer to fb_info structure
+ * @region: pointer to fb_copyarea structure
+ *
+ * DESCRIPTION:
+ * This copies an area of pixels from one location to another
+ *
+ * CALLED FROM:
+ * framebuffer hook
+ */
+static void xboxfb_copyarea(struct fb_info *info, const struct fb_copyarea *region)
+{
+	struct riva_par *par = (struct riva_par *) info->par;
+
+	if ((info->flags & FBINFO_HWACCEL_DISABLED)) {
+		cfb_copyarea(info, region);
+		return;
+	}
+
+	RIVA_FIFO_FREE(par->riva, Blt, 3);
+	NV_WR32(&par->riva.Blt->TopLeftSrc, 0,
+		(region->sy << 16) | region->sx);
+	NV_WR32(&par->riva.Blt->TopLeftDst, 0,
+		(region->dy << 16) | region->dx);
+	mb();
+	NV_WR32(&par->riva.Blt->WidthHeight, 0,
+		(region->height << 16) | region->width);
+	mb();
+}
+
+static inline void convert_bgcolor_16(u32 *col)
+{
+	*col = ((*col & 0x0000F800) << 8)
+		| ((*col & 0x00007E0) << 5)
+		| ((*col & 0x0000001F) << 3)
+		|	   0xFF000000;
+	mb();
+}
+
+/**
+ * xboxfb_imageblit: hardware accelerated color expand function
+ * @info: pointer to fb_info structure
+ * @image: pointer to fb_image structure
+ *
+ * DESCRIPTION:
+ * If the source is a monochrome bitmap, the function fills up a a region
+ * of framebuffer memory with pixels whose color is determined by the bit
+ * setting of the bitmap, 1 - foreground, 0 - background.
+ *
+ * If the source is not a monochrome bitmap, color expansion is not done.
+ * In this case, it is channeled to a software function.
+ *
+ * CALLED FROM:
+ * framebuffer hook
+ */
+static void xboxfb_imageblit(struct fb_info *info, 
+			     const struct fb_image *image)
+{
+	struct riva_par *par = (struct riva_par *) info->par;
+	u32 fgx = 0, bgx = 0, width, tmp;
+	u8 *cdat = (u8 *) image->data;
+	volatile u32 __iomem *d;
+	int i, size;
+
+	if ((info->flags & FBINFO_HWACCEL_DISABLED) || image->depth != 1) {
+		cfb_imageblit(info, image);
+		return;
+	}
+
+	switch (info->var.bits_per_pixel) {
+	case 8:
+		fgx = image->fg_color;
+		bgx = image->bg_color;
+		break;
+	case 16:
+	case 32:
+		if (par->riva.Architecture != NV_ARCH_03) {
+			fgx = ((u32 *)info->pseudo_palette)[image->fg_color];
+			bgx = ((u32 *)info->pseudo_palette)[image->bg_color];
+		} else {
+			fgx = par->palette[image->fg_color];
+			bgx = par->palette[image->bg_color];
+		}
+		if (info->var.green.length == 6)
+			convert_bgcolor_16(&bgx);	
+		break;
+	}
+
+	RIVA_FIFO_FREE(par->riva, Bitmap, 7);
+	NV_WR32(&par->riva.Bitmap->ClipE.TopLeft, 0,
+		(image->dy << 16) | (image->dx & 0xFFFF));
+	NV_WR32(&par->riva.Bitmap->ClipE.BottomRight, 0,
+		(((image->dy + image->height) << 16) |
+		 ((image->dx + image->width) & 0xffff)));
+	NV_WR32(&par->riva.Bitmap->Color0E, 0, bgx);
+	NV_WR32(&par->riva.Bitmap->Color1E, 0, fgx);
+	NV_WR32(&par->riva.Bitmap->WidthHeightInE, 0,
+		(image->height << 16) | ((image->width + 31) & ~31));
+	NV_WR32(&par->riva.Bitmap->WidthHeightOutE, 0,
+		(image->height << 16) | ((image->width + 31) & ~31));
+	NV_WR32(&par->riva.Bitmap->PointE, 0,
+		(image->dy << 16) | (image->dx & 0xFFFF));
+
+	d = &par->riva.Bitmap->MonochromeData01E;
+
+	width = (image->width + 31)/32;
+	size = width * image->height;
+	while (size >= 16) {
+		RIVA_FIFO_FREE(par->riva, Bitmap, 16);
+		for (i = 0; i < 16; i++) {
+			tmp = *((u32 *)cdat);
+			cdat = (u8 *)((u32 *)cdat + 1);
+			reverse_order(&tmp);
+			NV_WR32(d, i*4, tmp);
+		}
+		size -= 16;
+	}
+	if (size) {
+		RIVA_FIFO_FREE(par->riva, Bitmap, size);
+		for (i = 0; i < size; i++) {
+			tmp = *((u32 *) cdat);
+			cdat = (u8 *)((u32 *)cdat + 1);
+			reverse_order(&tmp);
+			NV_WR32(d, i*4, tmp);
+		}
+	}
+}
+
+/**
+ * xboxfb_cursor - hardware cursor function
+ * @info: pointer to info structure
+ * @cursor: pointer to fbcursor structure
+ *
+ * DESCRIPTION:
+ * A cursor function that supports displaying a cursor image via hardware.
+ * Within the kernel, copy and invert rops are supported.  If exported
+ * to user space, only the copy rop will be supported.
+ *
+ * CALLED FROM
+ * framebuffer hook
+ */
+static int xboxfb_cursor(struct fb_info *info, struct fb_cursor *cursor)
+{
+	struct riva_par *par = (struct riva_par *) info->par;
+	u8 data[MAX_CURS * MAX_CURS/8];
+	u16 fg, bg;
+	int i, set = cursor->set;
+
+	if (cursor->image.width > MAX_CURS ||
+	    cursor->image.height > MAX_CURS)
+		return -ENXIO;
+
+	par->riva.ShowHideCursor(&par->riva, 0);
+
+	if (par->cursor_reset) {
+		set = FB_CUR_SETALL;
+		par->cursor_reset = 0;
+	}
+
+	if (set & FB_CUR_SETSIZE)
+		memset_io(par->riva.CURSOR, 0, MAX_CURS * MAX_CURS * 2);
+
+	if (set & FB_CUR_SETPOS) {
+		u32 xx, yy, temp;
+
+		yy = cursor->image.dy - info->var.yoffset;
+		xx = cursor->image.dx - info->var.xoffset;
+		temp = xx & 0xFFFF;
+		temp |= yy << 16;
+
+		NV_WR32(par->riva.PRAMDAC, 0x0000300, temp);
+	}
+
+
+	if (set & (FB_CUR_SETSHAPE | FB_CUR_SETCMAP | FB_CUR_SETIMAGE)) {
+		u32 bg_idx = cursor->image.bg_color;
+		u32 fg_idx = cursor->image.fg_color;
+		u32 s_pitch = (cursor->image.width+7) >> 3;
+		u32 d_pitch = MAX_CURS/8;
+		u8 *dat = (u8 *) cursor->image.data;
+		u8 *msk = (u8 *) cursor->mask;
+		u8 *src;
+		
+		src = kmalloc(s_pitch * cursor->image.height, GFP_ATOMIC);
+
+		if (src) {
+			switch (cursor->rop) {
+			case ROP_XOR:
+				for (i = 0; i < s_pitch * cursor->image.height;
+				     i++)
+					src[i] = dat[i] ^ msk[i];
+				break;
+			case ROP_COPY:
+			default:
+				for (i = 0; i < s_pitch * cursor->image.height;
+				     i++)
+					src[i] = dat[i] & msk[i];
+				break;
+			}
+
+			fb_pad_aligned_buffer(data, d_pitch, src, s_pitch,
+					       cursor->image.height);
+
+			bg = ((info->cmap.red[bg_idx] & 0xf8) << 7) |
+				((info->cmap.green[bg_idx] & 0xf8) << 2) |
+				((info->cmap.blue[bg_idx] & 0xf8) >> 3) |
+				1 << 15;
+
+			fg = ((info->cmap.red[fg_idx] & 0xf8) << 7) |
+				((info->cmap.green[fg_idx] & 0xf8) << 2) |
+				((info->cmap.blue[fg_idx] & 0xf8) >> 3) |
+				1 << 15;
+
+			par->riva.LockUnlock(&par->riva, 0);
+
+			xboxfb_load_cursor_image(par, data, bg, fg,
+						 cursor->image.width,
+						 cursor->image.height);
+			kfree(src);
+		}
+	}
+
+	if (cursor->enable)
+		par->riva.ShowHideCursor(&par->riva, 1);
+
+	return 0;
+}
+
+static int xboxfb_sync(struct fb_info *info)
+{
+	struct riva_par *par = (struct riva_par *)info->par;
+
+	wait_for_idle(par);
+	return 0;
+}
+
+static int xboxfb_ioctl(struct fb_info *info, unsigned int cmd,
+		unsigned long arg)
+{
+	struct riva_par *par = (struct riva_par *) info->par;
+	
+	xbox_overscan overscan;
+	xboxfb_config config;
+	xbox_tv_encoding encoding;
+	int ret = 0;
+
+	switch (cmd) {
+	case FBIO_XBOX_SET_OVERSCAN:
+		if(!copy_from_user(&overscan, (xbox_overscan*)arg, sizeof(overscan))) {
+			par->hoc = overscan.hoc;
+			par->voc = overscan.voc;
+			riva_load_video_mode (info);
+			if(!(info->flags & FBINFO_HWACCEL_DISABLED)) {
+				riva_setup_accel(info);
+			}
+		}
+		else {
+			ret = -EFAULT;
+		}
+	break;
+	case FBIO_XBOX_GET_OVERSCAN:
+		overscan.hoc = par->hoc;
+		overscan.voc = par->voc;
+		if (copy_to_user((xbox_overscan*)arg, &overscan, sizeof(overscan))) {
+			ret = -EFAULT;
+		}
+	break;
+	case FBIO_XBOX_GET_CONFIG:
+		config.av_type = par->av_type;
+		config.encoder_type = par->video_encoder;
+		if (copy_to_user((xboxfb_config*)arg, &config, sizeof(config))) {
+			ret = -EFAULT;
+		}
+	break;
+	case FBIO_XBOX_GET_TV_ENCODING:
+		encoding = par->tv_encoding;
+		if (copy_to_user((xbox_tv_encoding*)arg, &encoding, sizeof(encoding))) {
+			ret = -EFAULT;
+		}
+	break;
+	case FBIO_XBOX_SET_TV_ENCODING:
+		if(!copy_from_user(&encoding, (xbox_tv_encoding*)arg, sizeof(encoding))) {
+			par->tv_encoding = encoding;
+			riva_load_video_mode (info);
+			if(!(info->flags & FBINFO_HWACCEL_DISABLED)) {
+				riva_setup_accel(info);
+			}
+		}
+		else {
+			ret = -EFAULT;
+		}
+	break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+
+/* ------------------------------------------------------------------------- *
+ *
+ * initialization helper functions
+ *
+ * ------------------------------------------------------------------------- */
+
+/* kernel interface */
+static struct fb_ops riva_fb_ops = {
+	.owner 		= THIS_MODULE,
+	.fb_open	= xboxfb_open,
+	.fb_release	= xboxfb_release,
+	.fb_check_var 	= xboxfb_check_var,
+	.fb_set_par 	= xboxfb_set_par,
+	.fb_setcolreg 	= xboxfb_setcolreg,
+	.fb_pan_display	= xboxfb_pan_display,
+	.fb_blank 	= xboxfb_blank,
+	.fb_fillrect 	= xboxfb_fillrect,
+	.fb_copyarea 	= xboxfb_copyarea,
+	.fb_imageblit 	= xboxfb_imageblit,
+	.fb_cursor	= xboxfb_cursor,
+	.fb_sync 	= xboxfb_sync,
+	.fb_ioctl	= xboxfb_ioctl,
+};
+
+static int __devinit riva_set_fbinfo(struct fb_info *info)
+{
+	struct riva_par *par = (struct riva_par *) info->par;
+	unsigned int cmap_len;
+
+	info->flags = FBINFO_FLAG_DEFAULT;
+	info->var = xboxfb_default_var;
+	info->fix = xboxfb_fix;
+	info->fbops = &riva_fb_ops;
+	info->pseudo_palette = pseudo_palette;
+
+#ifndef MODULE
+	if (mode_option)
+	{
+		if (!strncmp(mode_option, "480p", 4)) {
+			info->var = xboxfb_mode_480p;
+		}
+		else if (!strncmp(mode_option, "720p", 4)) {
+			info->var = xboxfb_mode_720p;
+		}
+		else {
+			fb_find_mode(&info->var, info, mode_option,
+				NULL, 0, NULL, 8);
+		}
+	}
+#endif
+	if (par->use_default_var)
+		/* We will use the modified default var */
+		info->var = xboxfb_default_var;
+
+	cmap_len = riva_get_cmap_len(&info->var);
+	fb_alloc_cmap(&info->cmap, cmap_len, 0);	
+
+	info->pixmap.size = 64 * 1024;
+	info->pixmap.buf_align = 4;
+	info->pixmap.scan_align = 4;
+	info->pixmap.flags = FB_PIXMAP_SYSTEM;
+	return 0;
+}
+
+#ifdef CONFIG_PPC_OF
+static int riva_get_EDID_OF(struct fb_info *info, struct pci_dev *pd)
+{
+	struct riva_par *par = (struct riva_par *) info->par;
+	struct device_node *dp;
+	unsigned char *pedid = NULL;
+
+	dp = pci_device_to_OF_node(pd);
+	pedid = (unsigned char *)get_property(dp, "EDID,B", 0);
+
+	if (pedid) {
+		par->EDID = pedid;
+		return 1;
+	} else
+		return 0;
+}
+#endif /* CONFIG_PPC_OF */
+
+static int riva_dfp_parse_EDID(struct riva_par *par)
+{
+	unsigned char *block = par->EDID;
+
+	if (!block)
+		return 0;
+
+	/* jump to detailed timing block section */
+	block += 54;
+
+	par->clock = (block[0] + (block[1] << 8));
+	par->panel_xres = (block[2] + ((block[4] & 0xf0) << 4));
+	par->hblank = (block[3] + ((block[4] & 0x0f) << 8));
+	par->panel_yres = (block[5] + ((block[7] & 0xf0) << 4));
+	par->vblank = (block[6] + ((block[7] & 0x0f) << 8));
+	par->hOver_plus = (block[8] + ((block[11] & 0xc0) << 2));
+	par->hSync_width = (block[9] + ((block[11] & 0x30) << 4));
+	par->vOver_plus = ((block[10] >> 4) + ((block[11] & 0x0c) << 2));
+	par->vSync_width = ((block[10] & 0x0f) + ((block[11] & 0x03) << 4));
+	par->interlaced = ((block[17] & 0x80) >> 7);
+	par->synct = ((block[17] & 0x18) >> 3);
+	par->misc = ((block[17] & 0x06) >> 1);
+	par->hAct_high = par->vAct_high = 0;
+	if (par->synct == 3) {
+		if (par->misc & 2)
+			par->hAct_high = 1;
+		if (par->misc & 1)
+			par->vAct_high = 1;
+	}
+
+	printk(KERN_INFO PFX
+			"detected DFP panel size from EDID: %dx%d\n", 
+			par->panel_xres, par->panel_yres);
+	par->got_dfpinfo = 1;
+	return 1;
+}
+
+static void riva_update_default_var(struct fb_info *info)
+{
+	struct fb_var_screeninfo *var = &xboxfb_default_var;
+	struct riva_par *par = (struct riva_par *) info->par;
+
+        var->xres = par->panel_xres;
+        var->yres = par->panel_yres;
+        var->xres_virtual = par->panel_xres;
+        var->yres_virtual = par->panel_yres;
+        var->xoffset = var->yoffset = 0;
+        var->bits_per_pixel = 8;
+        var->pixclock = 100000000 / par->clock;
+        var->left_margin = (par->hblank - par->hOver_plus - par->hSync_width);
+        var->right_margin = par->hOver_plus;
+        var->upper_margin = (par->vblank - par->vOver_plus - par->vSync_width);
+        var->lower_margin = par->vOver_plus;
+        var->hsync_len = par->hSync_width;
+        var->vsync_len = par->vSync_width;
+        var->sync = 0;
+
+        if (par->synct == 3) {
+                if (par->hAct_high)
+                        var->sync |= FB_SYNC_HOR_HIGH_ACT;
+                if (par->vAct_high)
+                        var->sync |= FB_SYNC_VERT_HIGH_ACT;
+        }
+ 
+        var->vmode = 0;
+        if (par->interlaced)
+                var->vmode |= FB_VMODE_INTERLACED;
+
+	var->accel_flags |= FB_ACCELF_TEXT;
+        
+        par->use_default_var = 1;
+}
+
+
+static void riva_get_EDID(struct fb_info *info, struct pci_dev *pdev)
+{
+#ifdef CONFIG_PPC_OF
+	if (!riva_get_EDID_OF(info, pdev))
+		printk("xboxfb: could not retrieve EDID from OF\n");
+#else
+	/* XXX use other methods later */
+#endif
+}
+
+
+static void riva_get_dfpinfo(struct fb_info *info)
+{
+	struct riva_par *par = (struct riva_par *) info->par;
+
+	if (riva_dfp_parse_EDID(par))
+		riva_update_default_var(info);
+
+	/* if user specified flatpanel, we respect that */
+	if (par->got_dfpinfo == 1)
+		par->FlatPanel = 1;
+}
+
+/* ------------------------------------------------------------------------- *
+ *
+ * PCI bus
+ *
+ * ------------------------------------------------------------------------- */
+
+static int __devinit xboxfb_probe(struct pci_dev *pd,
+			     	const struct pci_device_id *ent)
+{
+	struct riva_chip_info *rci = &riva_chip_info[ent->driver_data];
+	struct riva_par *default_par;
+	struct fb_info *info;
+	unsigned long fb_start;
+	unsigned long fb_size;
+
+	assert(pd != NULL);
+	assert(rci != NULL);
+
+	info = kmalloc(sizeof(struct fb_info), GFP_KERNEL);
+	if (!info)
+		goto err_out;
+
+	default_par = kmalloc(sizeof(struct riva_par), GFP_KERNEL);
+	if (!default_par)
+		goto err_out_kfree;
+
+	memset(info, 0, sizeof(struct fb_info));
+	memset(default_par, 0, sizeof(struct riva_par));
+
+	info->pixmap.addr = kmalloc(64 * 1024, GFP_KERNEL);
+	if (info->pixmap.addr == NULL)
+		goto err_out_kfree1;
+	memset(info->pixmap.addr, 0, 64 * 1024);
+
+	strcat(xboxfb_fix.id, rci->name);
+	default_par->riva.Architecture = rci->arch_rev;
+
+	default_par->Chipset = (pd->vendor << 16) | pd->device;
+	printk(KERN_INFO PFX "nVidia device/chipset %X\n",default_par->Chipset);
+	
+	default_par->FlatPanel = flatpanel;
+	if (flatpanel == 1)
+		printk(KERN_INFO PFX "flatpanel support enabled\n");
+	default_par->forceCRTC = forceCRTC;
+	
+	xboxfb_fix.mmio_len = pci_resource_len(pd, 0);
+
+	{
+		/* enable IO and mem if not already done */
+		unsigned short cmd;
+
+		pci_read_config_word(pd, PCI_COMMAND, &cmd);
+		cmd |= (PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
+		pci_write_config_word(pd, PCI_COMMAND, cmd);
+	}
+	
+	xboxfb_fix.mmio_start = pci_resource_start(pd, 0);
+	xboxfb_fix.smem_start = pci_resource_start(pd, 1);
+	
+        if (xbox_memory_size() == 64*1024*1024) printk(KERN_INFO PFX "Detected 64MB of system RAM\n");
+	else printk(KERN_INFO PFX "Detected 128MB of system RAM\n");
+	
+	fb_size = available_framebuffer_memory();
+	fb_start = xbox_memory_size() - fb_size;
+	printk(KERN_INFO PFX "Using %dM framebuffer memory\n", (int)(fb_size/(1024*1024)));
+	default_par->riva_fb_start = fb_start;
+	xboxfb_fix.smem_start += fb_start;
+	xboxfb_fix.smem_len = fb_size; 
+	tv_init();
+	if (tv_encoding == TV_ENC_INVALID) {
+		tv_encoding = get_tv_encoding();
+		printk(KERN_INFO PFX "Setting TV mode from EEPROM (%s)\n", tvEncodingNames[tv_encoding]);
+	}
+	default_par->tv_encoding = tv_encoding;
+	default_par->video_encoder = tv_get_video_encoder();
+	switch(default_par->video_encoder) {
+		case ENCODER_CONEXANT:
+			printk(KERN_INFO PFX "detected conexant encoder\n");
+			break;
+		case ENCODER_FOCUS:
+			printk(KERN_INFO PFX "detected focus encoder\n");
+			break;
+		case ENCODER_XCALIBUR:
+			printk(KERN_INFO PFX "detected Xcalibur encoder\n");
+			break;
+		default: 
+			printk(KERN_INFO PFX "detected unknown encoder\n");
+	}
+	
+	
+	if (av_type == AV_INVALID) {
+		av_type = detect_av_type();
+		printk(KERN_INFO PFX "Setting cable type from AVIP ID: %s\n", avTypeNames[av_type]);
+	}
+	default_par->av_type = av_type;
+	if ((hoc < 0) || (hoc > 20)) {
+		hoc = 10;
+	}
+	default_par->hoc = hoc / 100.0;
+	if ((voc < 0) || (voc > 20)) {
+		voc = 10;
+	}
+	default_par->voc = voc / 100.0;
+	
+	if (!request_mem_region(xboxfb_fix.mmio_start,
+				xboxfb_fix.mmio_len, "xboxfb")) {
+		printk(KERN_ERR PFX "cannot reserve MMIO region\n");
+		goto err_out_kfree2;
+	}
+
+	default_par->ctrl_base = ioremap(xboxfb_fix.mmio_start,
+					 xboxfb_fix.mmio_len);
+	if (!default_par->ctrl_base) {
+		printk(KERN_ERR PFX "cannot ioremap MMIO base\n");
+		goto err_out_free_base0;
+	}
+
+	info->par = default_par;
+
+	riva_get_EDID(info, pd);
+
+	riva_get_dfpinfo(info);
+
+	switch (default_par->riva.Architecture) {
+	case NV_ARCH_03:
+		/* Riva128's PRAMIN is in the "framebuffer" space
+		 * Since these cards were never made with more than 8 megabytes
+		 * we can safely allocate this separately.
+		 */
+		if (!request_mem_region(xboxfb_fix.smem_start + 0x00C00000,
+					 0x00008000, "xboxfb")) {
+			printk(KERN_ERR PFX "cannot reserve PRAMIN region\n");
+			goto err_out_iounmap_ctrl;
+		}
+		default_par->riva.PRAMIN = ioremap(xboxfb_fix.smem_start + 0x00C00000, 0x00008000);
+		if (!default_par->riva.PRAMIN) {
+			printk(KERN_ERR PFX "cannot ioremap PRAMIN region\n");
+			goto err_out_free_nv3_pramin;
+		}
+		xboxfb_fix.accel = FB_ACCEL_NV3;
+		break;
+	case NV_ARCH_04:
+	case NV_ARCH_10:
+	case NV_ARCH_20:
+		default_par->riva.PCRTC0 = (unsigned *)(default_par->ctrl_base + 0x00600000);
+		default_par->riva.PRAMIN = (unsigned *)(default_par->ctrl_base + 0x00710000);
+		xboxfb_fix.accel = FB_ACCEL_NV4;
+		break;
+	}
+
+	riva_common_setup(default_par);
+
+	if (default_par->riva.Architecture == NV_ARCH_03) {
+		default_par->riva.PCRTC = default_par->riva.PCRTC0 = default_par->riva.PGRAPH;
+	}
+
+	/* xboxfb_fix.smem_len = riva_get_memlen(default_par) * 1024; */
+	default_par->dclk_max = riva_get_maxdclk(default_par) * 1000;
+
+	if (!request_mem_region(xboxfb_fix.smem_start, xboxfb_fix.smem_len, "xboxfb")) {
+		printk(KERN_ERR PFX "cannot reserve FB region\n");
+		goto err_out_iounmap_nv3_pramin;
+	}
+	
+	info->screen_base = ioremap(xboxfb_fix.smem_start, fb_size);
+	if (!info->screen_base) {
+		printk(KERN_ERR PFX "cannot ioremap FB base\n");
+		goto err_out_free_base1;
+	}
+
+#ifdef CONFIG_MTRR
+	if (!nomtrr) {
+		default_par->mtrr.vram = mtrr_add(xboxfb_fix.smem_start, fb_size,
+			MTRR_TYPE_WRCOMB, 1);
+		if (default_par->mtrr.vram < 0) {
+			printk(KERN_ERR PFX "unable to setup MTRR\n");
+		} else {
+			default_par->mtrr.vram_valid = 1;
+			/* let there be speed */
+			printk(KERN_INFO PFX "RIVA MTRR set to ON\n");
+		}
+	}
+#endif /* CONFIG_MTRR */
+
+	if (riva_set_fbinfo(info) < 0) {
+		printk(KERN_ERR PFX "error setting initial video mode\n");
+		goto err_out_iounmap_fb;
+	}
+
+	if (register_framebuffer(info) < 0) {
+		printk(KERN_ERR PFX
+			"error registering riva framebuffer\n");
+		goto err_out_iounmap_fb;
+	}
+
+	pci_set_drvdata(pd, info);
+
+	printk(KERN_INFO PFX
+		"PCI nVidia NV%x framebuffer ver %s (%s, %ldMB @ 0x%lX)\n",
+		default_par->riva.Architecture,
+		XBOXFB_VERSION,
+		info->fix.id,
+		fb_size / (1024 * 1024),
+		info->fix.smem_start);
+	return 0;
+
+err_out_iounmap_fb:
+	iounmap(info->screen_base);
+err_out_free_base1:
+	release_mem_region(xboxfb_fix.smem_start, fb_size);
+err_out_iounmap_nv3_pramin:
+	if (default_par->riva.Architecture == NV_ARCH_03) 
+		iounmap((caddr_t)default_par->riva.PRAMIN);
+err_out_free_nv3_pramin:
+	if (default_par->riva.Architecture == NV_ARCH_03)
+		release_mem_region(xboxfb_fix.smem_start + 0x00C00000, 0x00008000);
+err_out_iounmap_ctrl:
+	iounmap(default_par->ctrl_base);
+err_out_free_base0:
+	release_mem_region(xboxfb_fix.mmio_start, xboxfb_fix.mmio_len);
+err_out_kfree2:
+	kfree(info->pixmap.addr);
+err_out_kfree1:
+	kfree(default_par);
+err_out_kfree:
+	kfree(info);
+err_out:
+	return -ENODEV;
+}
+
+static void __exit xboxfb_remove(struct pci_dev *pd)
+{
+	struct fb_info *info = pci_get_drvdata(pd);
+	struct riva_par *par = (struct riva_par *) info->par;
+	
+	if (!info)
+		return;
+
+	unregister_framebuffer(info);
+#ifdef CONFIG_MTRR
+	if (par->mtrr.vram_valid)
+		mtrr_del(par->mtrr.vram, info->fix.smem_start, info->fix.smem_len);
+#endif /* CONFIG_MTRR */
+
+	iounmap(par->ctrl_base);
+	iounmap(info->screen_base);
+
+	release_mem_region(info->fix.mmio_start,
+			   info->fix.mmio_len);
+	release_mem_region(info->fix.smem_start, info->fix.smem_len);
+
+	if (par->riva.Architecture == NV_ARCH_03) {
+		iounmap((caddr_t)par->riva.PRAMIN);
+		release_mem_region(info->fix.smem_start + 0x00C00000, 0x00008000);
+	}
+	kfree(info->pixmap.addr);
+	kfree(par);
+	kfree(info);
+	pci_set_drvdata(pd, NULL);
+}
+
+/* ------------------------------------------------------------------------- *
+ *
+ * initialization
+ *
+ * ------------------------------------------------------------------------- */
+
+int __init xboxfb_setup(char *options)
+{
+	char *this_opt;
+
+	if (!options || !*options)
+		return 0;
+
+	while ((this_opt = strsep(&options, ",")) != NULL) {
+		if (!strncmp(this_opt, "forceCRTC", 9)) {
+			char *p;
+			
+			p = this_opt + 9;
+			if (!*p || !*(++p)) continue; 
+			forceCRTC = *p - '0';
+			if (forceCRTC < 0 || forceCRTC > 1) 
+				forceCRTC = -1;
+		} else if (!strncmp(this_opt, "flatpanel", 9)) {
+			flatpanel = 1;
+#ifdef CONFIG_MTRR
+		} else if (!strncmp(this_opt, "nomtrr", 6)) {
+			nomtrr = 1;
+#endif
+		} else if (!strncmp(this_opt, "strictmode", 10)) {
+			strictmode = 1;
+		} else if (!strncmp(this_opt, "noaccel", 7)) {
+			noaccel = 1;
+		} else if (!strncmp(this_opt, "tv=", 3)) {
+				if(!strncmp(this_opt + 3, "PAL", 3)) {
+						tv_encoding = TV_ENC_PALBDGHI;
+				}
+				else if(!strncmp(this_opt + 3, "NTSC", 4)) {
+						tv_encoding = TV_ENC_NTSC;
+				}
+				else if(!strncmp(this_opt + 3, "VGA", 3)) {
+						av_type = AV_VGA_SOG;
+				}
+		} else if (!strncmp(this_opt, "hoc=", 4)) {
+				sscanf(this_opt+4, "%d", &hoc);
+		} else if (!strncmp(this_opt, "voc=", 4)) {
+				sscanf(this_opt+4, "%d", &voc);
+		} else
+			mode_option = this_opt;
+	}
+	return 0;
+}
+
+static struct pci_driver xboxfb_driver = {
+	.name		= "xboxfb",
+	.id_table	= xboxfb_pci_tbl,
+	.probe		= xboxfb_probe,
+	.remove		= __exit_p(xboxfb_remove),
+};
+
+
+
+/* ------------------------------------------------------------------------- *
+ *
+ * modularization
+ *
+ * ------------------------------------------------------------------------- */
+
+int __devinit xboxfb_init(void)
+{
+        char *option = NULL;
+
+	//Ignore error here, vesafb does!
+	fb_get_options("xboxfb", &option);
+//        if (fb_get_options("xboxfb", &option))
+//		return -ENODEV;
+	xboxfb_setup(option);
+	
+	return pci_register_driver(&xboxfb_driver);
+}
+
+module_init(xboxfb_init);
+
+#ifdef MODULE
+static void __exit xboxfb_exit(void)
+{
+	pci_unregister_driver(&xboxfb_driver);
+}
+
+module_exit(xboxfb_exit);
+
+module_param(noaccel, bool, 0);
+MODULE_PARM_DESC(noaccel, "bool: disable acceleration");
+module_param(flatpanel, int, 0);
+MODULE_PARM_DESC(flatpanel, "Enables experimental flat panel support for some chipsets. (0 or 1=enabled) (default=0)");
+module_param(forceCRTC, int, 0);
+MODULE_PARM_DESC(forceCRTC, "Forces usage of a particular CRTC in case autodetection fails. (0 or 1) (default=autodetect)");
+
+#ifdef CONFIG_MTRR
+module_param(nomtrr, bool, 0);
+MODULE_PARM_DESC(nomtrr, "Disables MTRR support (0 or 1=disabled) (default=0)");
+#endif
+module_param(strictmode, bool, 0);
+MODULE_PARM_DESC(strictmode, "Only use video modes from EDID");
+
+static char *tv = "NTSC";
+module_param(tv, charp, 0);
+MODULE_PARM_DESC(tv, "Specifies the TV encoding (\"PAL\", \"NTSC\" or \"VGA\").");
+module_param(hoc, int, 0);
+MODULE_PARM_DESC(hoc, "Horizontal overscan compensation ratio, in % (0-20)");
+module_param(voc, int, 0);
+MODULE_PARM_DESC(voc, "Vertical overscan compensation ratio, in % (0-20)");
+
+#endif /* MODULE */
+
+MODULE_AUTHOR("Oliver Schwartz");
+MODULE_DESCRIPTION("Framebuffer driver for Xbox");
+MODULE_LICENSE("GPL");
diff -uprN a/drivers/video/xbox/focus.c b/drivers/video/xbox/focus.c
--- a/drivers/video/xbox/focus.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/focus.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,405 @@
+/*
+ * linux/drivers/video/riva/focus.c - Xbox driver for Focus encoder
+ *
+ * Maintainer: David Pye (dmp) <dmp@davidmpye.dyndns.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * Known bugs and issues:
+ *
+ * VGA SoG/internal sync not yet implemented
+*/
+#include "focus.h"
+#include "encoder.h"
+
+typedef struct _focus_pll_settings{
+	long dotclock;
+	int vga_htotal;
+	int vga_vtotal;
+	int tv_htotal;
+	int tv_vtotal;
+} focus_pll_settings;
+
+static const unsigned char focus_defaults[0xc4] = {
+	/*0x00*/ 0x00,0x00,0x00,0x00,0x80,0x02,0xaa,0x0a,
+	/*0x08*/ 0x00,0x10,0x00,0x00,0x03,0x21,0x15,0x04,
+	/*0x10*/ 0x00,0xe9,0x07,0x00,0x80,0xf5,0x20,0x00,
+	/*0x18*/ 0xef,0x21,0x1f,0x00,0x03,0x03,0x00,0x00,
+	/*0x20*/ 0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,
+	/*0x28*/ 0x0c,0x01,0x00,0x00,0x00,0x00,0x08,0x11,
+	/*0x30*/ 0x00,0x0f,0x05,0xfe,0x0b,0x80,0x00,0x00,
+	/*0x38*/ 0xa4,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	/*0x40*/ 0x2a,0x09,0x8a,0xcb,0x00,0x00,0x8d,0x00,
+	/*0x48*/ 0x7c,0x3c,0x9a,0x2f,0x21,0x01,0x3f,0x00,
+	/*0x50*/ 0x3e,0x03,0x17,0x21,0x1b,0x1b,0x24,0x9c,
+	/*0x58*/ 0x01,0x3e,0x0f,0x0f,0x60,0x05,0xc8,0x00,
+	/*0x60*/ 0x9d,0x04,0x9d,0x01,0x02,0x00,0x0a,0x05,
+	/*0x68*/ 0x00,0x1a,0xff,0x03,0x1e,0x0f,0x78,0x00,
+	/*0x70*/ 0x00,0xb1,0x04,0x15,0x49,0x10,0x00,0xa3,
+	/*0x78*/ 0xc8,0x15,0x05,0x15,0x3e,0x03,0x00,0x20,
+	/*0x80*/ 0x57,0x2f,0x07,0x00,0x00,0x08,0x00,0x00,
+	/*0x88*/ 0x08,0x16,0x16,0x9c,0x03,0x00,0x00,0x00,
+	/*0x90*/ 0x00,0x00,0xc4,0x48,0x00,0x00,0x00,0x00,
+	/*0x98*/ 0x00,0x00,0x00,0x80,0x00,0x00,0xe4,0x00,
+	/*0xa0*/ 0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
+	/*0xa8*/ 0xFF,0x00,0xFF,0x00,0xFF,0x00,0x00,0x00,
+	/*0xb0*/ 0x00,0x00,0xd7,0x05,0x00,0x00,0xf0,0x00,
+	/*0xb8*/ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	/*0xc0*/ 0x00,0x00,0xee,0x00
+};
+
+
+int focus_calc_pll_settings(focus_pll_settings *settings, char *regs);
+
+int focus_calc_hdtv_mode(
+	xbox_hdtv_mode hdtv_mode,
+	unsigned char pll_int,
+	void **encoder_regs
+	){
+	unsigned char *regs;
+	
+	//This can be reduced
+	*encoder_regs = kmalloc(256*sizeof(char), GFP_KERNEL);
+	regs=(unsigned char*)*encoder_regs;
+	memcpy(regs,focus_defaults,sizeof(focus_defaults));	
+	/* Uncomment for HDTV 480p colour bars */
+	//regs[0x0d]|=0x02;
+	
+	/* Turn on bridge bypass */
+	regs[0x0a] |= 0x10;
+	/* Turn on the HDTV clock, and turn off the SDTV one */	
+	regs[0xa1] = 0x04;
+	
+	/* HDTV Hor start */
+	regs[0xb8] = 0xbe;
+	
+	/*Set up video mode to HDTV, progressive, 
+	 * and disable YUV matrix bypass */
+	regs[0x92] = 0x1a;	
+	regs[0x93] &= ~0x40;
+	
+	switch (hdtv_mode) {
+		case HDTV_480p:
+			/* PLL settings */
+			regs[0x10] = 0x00;
+			regs[0x11] = 0x00;
+			regs[0x12] = 0x00;
+			regs[0x13] = 0x00;
+			regs[0x14] = 0x00;
+			regs[0x15] = 0x00;
+			regs[0x16] = 0x00;
+			regs[0x17] = 0x00;
+			regs[0x18] = 0xD7;
+			regs[0x19] = 0x03;
+			regs[0x1A] = 0x7C;
+			regs[0x1B] = 0x00;
+			regs[0x1C] = 0x07;
+			regs[0x1D] = 0x07;
+			/* Porches/HSync width/Luma offset */
+			regs[0x94] = 0x3F;
+			regs[0x95] = 0x2D;
+			regs[0x96] = 0x3B;
+			regs[0x97] = 0x00;
+			regs[0x98] = 0x1B;
+			regs[0x99] = 0x03;
+			/* Colour scaling */
+			regs[0xA2] = 0x4D;
+			regs[0xA4] = 0x96;
+			regs[0xA6] = 0x1D;
+			regs[0xA8] = 0x58;
+			regs[0xAA] = 0x8A;
+			regs[0xAC] = 0x4A;
+			break;
+		case HDTV_720p:
+			/* PLL settings */
+			regs[0x10] = 0x00;
+			regs[0x11] = 0x00;
+			regs[0x12] = 0x00;
+			regs[0x13] = 0x00;
+			regs[0x14] = 0x00;
+			regs[0x15] = 0x00;
+			regs[0x16] = 0x00;
+			regs[0x17] = 0x00;
+			regs[0x18] = 0x3B;
+			regs[0x19] = 0x04;
+			regs[0x1A] = 0xC7;
+			regs[0x1B] = 0x00;
+			regs[0x1C] = 0x01;
+			regs[0x1D] = 0x01;
+			/* Porches/HSync width/Luma offset */
+			regs[0x94] = 0x28;
+			regs[0x95] = 0x46;
+			regs[0x96] = 0xDC;
+			regs[0x97] = 0x00;
+			regs[0x98] = 0x2C;
+			regs[0x99] = 0x06;
+			/* Colour scaling */
+			regs[0xA2] = 0x36;
+			regs[0xA4] = 0xB7;
+			regs[0xA6] = 0x13;
+			regs[0xA8] = 0x58;
+			regs[0xAA] = 0x8A;
+			regs[0xAC] = 0x4A;
+			/* HSync timing invert - needed to centre picture */
+			regs[0x93] |= 0x01;
+			
+			break;
+		case HDTV_1080i:
+			/* PLL settings */
+			regs[0x10] = 0x00;
+			regs[0x11] = 0x00;
+			regs[0x12] = 0x00;
+			regs[0x13] = 0x00;
+			regs[0x14] = 0x00;
+			regs[0x15] = 0x00;
+			regs[0x16] = 0x00;
+			regs[0x17] = 0x00;
+			regs[0x18] = 0x3B;
+			regs[0x19] = 0x04;
+			regs[0x1A] = 0xC7;
+			regs[0x1B] = 0x00;
+			regs[0x1C] = 0x01;
+			regs[0x1D] = 0x01;
+			/* Porches/HSync width/Luma offset */
+			regs[0x94] = 0x2C;
+			regs[0x95] = 0x2C;
+			regs[0x96] = 0x58;
+			regs[0x97] = 0x00;
+			regs[0x98] = 0x6C;
+			regs[0x99] = 0x08;
+			/* Colour scaling */
+			regs[0xA2] = 0x36;
+			regs[0xA4] = 0xB7;
+			regs[0xA6] = 0x13;
+			regs[0xA8] = 0x58;
+			regs[0xAA] = 0x8A;
+			regs[0xAC] = 0x4A;
+			/* Set mode to interlaced */
+			regs[0x92] |= 0x80;
+			break;
+	}
+	return 1;
+}
+
+int focus_calc_mode(xbox_video_mode * mode, struct riva_regs * riva_out)
+{
+	unsigned char b;
+	
+	unsigned char* regs;
+	int tv_htotal, tv_vtotal, tv_vactive, tv_hactive;
+	int vga_htotal, vga_vtotal;
+	int vsc, hsc;
+	long dotclock;
+	focus_pll_settings pll_settings;
+
+	riva_out->encoder_regs=kmalloc(256*sizeof(char),GFP_KERNEL);
+	regs=(unsigned char *)riva_out->encoder_regs;
+	
+	memcpy(regs,focus_defaults,sizeof(focus_defaults));
+	
+	/* Uncomment for SDTV colour bars */
+	//regs[0x45]=0x02;
+	
+	switch(mode->tv_encoding) {
+		case TV_ENC_NTSC:
+			tv_vtotal=525;
+			tv_vactive=480;			
+			tv_hactive = 710;
+			tv_htotal  = 858;
+			regs[0x0d] &= ~0x01;
+			regs[0x40] = 0x21;
+			regs[0x41] = 0xF0;
+			regs[0x42] = 0x7C;
+			regs[0x43] = 0x1F;
+			regs[0x49] = 0x44;
+			regs[0x4a] = 0x76;
+			regs[0x4b] = 0x3B;
+			regs[0x4c] = 0x00;
+			regs[0x60] = 0x89;
+			regs[0x62] = 0x89;
+			regs[0x69] = 0x16;
+			regs[0x6C] = 0x20;
+			regs[0x74] = 0x04;		
+			regs[0x75] = 0x10;
+			regs[0x80] = 0x67; 
+			regs[0x81] = 0x21; 
+			regs[0x82] = 0x0C;
+			regs[0x83] = 0x18;
+			regs[0x86] = 0x18;
+			regs[0x89] = 0x13;
+			regs[0x8A] = 0x13;
+			break;
+		case TV_ENC_PALBDGHI:
+			tv_vtotal = 625;
+			tv_vactive = 576;
+			tv_hactive = 702;
+			tv_htotal = 864;
+			break;
+		default:
+			/* Default to PAL */
+			tv_vtotal = 625;
+			tv_vactive = 576;
+			tv_hactive = 702;
+			tv_htotal = 864;
+			break;
+	}
+
+	/* Video control  - set to RGB input*/
+	b = (regs[0x92] &= ~0x04);
+	regs[0x92] = (b|= 0x01);
+	regs[0x93] &= ~0x40;
+	/* Colour scaling */
+	regs[0xA2] = 0x4D;
+	regs[0xA4] = 0x96;
+	regs[0xA6] = 0x1D;
+	regs[0xA8] = 0xA0;
+	regs[0xAA] = 0xDB;
+	regs[0xAC] = 0x7E;
+
+	switch(mode->av_type) {
+		case AV_SVIDEO:
+			/* COMP_YUV - set to 1 to output YUV */	
+			regs[0x47] |= 0x04;
+			/* VID_MODE to 0 - SVIDEO */
+			regs[0x92] &= ~0x01;
+			break;
+		default:
+			/*Nothing as yet */
+			break;
+	}
+	
+	tv_vactive = tv_vactive * (1.0f-mode->voc);
+	vga_vtotal = mode->yres * ((float)tv_vtotal/tv_vactive);
+	vga_htotal = mode->xres * 1.25f;
+	tv_hactive = tv_hactive * (1.0f-mode->hoc);
+
+	regs[0x04] = (mode->xres+64)&0xFF;
+	regs[0x05] = ((mode->xres+64)>>8)&0xFF;
+
+	if (tv_vtotal>vga_vtotal) {
+		/* Upscaling */
+		vsc = ((((float)tv_vtotal/(float)vga_vtotal)-1)*65536);
+		/* For upscaling, adjust FIFO_LAT (FIFO latency) */
+		regs[0x38] = 0x82;
+	}
+	else {
+		/* Downscaling */
+		vsc = ((((float)tv_vtotal/(float)vga_vtotal))*65536);
+	}
+	regs[0x06] = (vsc)&0xFF;
+	regs[0x07] = (vsc>>8)&0xFF;
+
+	hsc = 128*((float)tv_hactive/(float)mode->xres-1);
+	if (tv_hactive > mode->xres) {
+		/* Upscaling */
+		regs[0x08] = 0;
+		regs[0x09] = hsc&0xFF;
+	}
+	else {  /* Downscaling */
+		hsc = 256 + hsc;
+		regs[0x08] = hsc&0xFF;
+		regs[0x09] = 0;
+	}
+
+	//PLL calculations
+	if (mode->tv_encoding==TV_ENC_NTSC) dotclock = vga_htotal * vga_vtotal * 59.94;
+	else dotclock = vga_htotal * vga_vtotal * 50;
+
+	pll_settings.dotclock = dotclock;
+	pll_settings.vga_htotal = vga_htotal;
+	pll_settings.vga_vtotal = vga_vtotal;
+	pll_settings.tv_htotal = tv_htotal;
+	pll_settings.tv_vtotal = tv_vtotal;
+	
+	if (!focus_calc_pll_settings(&pll_settings,regs)) {
+		//Unable to calculate a valid PLL solution	
+		return 1;
+	}
+
+	/* Guesswork */
+	riva_out->ext.vsyncstart = vga_vtotal * 0.95;
+	riva_out->ext.hsyncstart = vga_htotal * 0.95;
+	
+	riva_out->ext.width = mode->xres;
+	riva_out->ext.height = mode->yres;
+	riva_out->ext.htotal = vga_htotal - 1;
+	riva_out->ext.vend = mode->yres - 1;
+	riva_out->ext.vtotal = vga_vtotal- 1;
+	riva_out->ext.vcrtc = mode->yres - 1;
+	riva_out->ext.vsyncend = riva_out->ext.vsyncstart + 3;
+        riva_out->ext.vvalidstart = 0;
+	riva_out->ext.vvalidend = mode->yres - 1;
+	riva_out->ext.hend = mode->xres + 7 ;
+	riva_out->ext.hcrtc = mode->xres - 1;
+        riva_out->ext.hsyncend = riva_out->ext.hsyncstart + 32;
+        riva_out->ext.hvalidstart = 0;
+        riva_out->ext.hvalidend = mode->xres - 1;
+	riva_out->ext.crtchdispend = mode->xres;
+        riva_out->ext.crtcvstart = mode->yres + 32;
+	//increased from 32
+	riva_out->ext.crtcvtotal = mode->yres + 64;
+
+	return 1;
+}
+
+int focus_calc_pll_settings(focus_pll_settings *settings, char *regs) {
+        int m, n;
+	long dotclock = (*settings).dotclock;
+	int pll_multiplier;
+	long ncon, ncod;
+	
+	ncon = (*settings).vga_htotal * (*settings).vga_vtotal;
+
+	//Multipliers between 1 and 6 are the limit as output clock cant be >150MHz
+	//The lower the multiplier, the more stable the PLL (theoretically)
+	for (pll_multiplier=4; pll_multiplier<6; pll_multiplier++) {
+		long nco_out_clk;
+		ncod = (*settings).tv_htotal * (*settings).tv_vtotal * pll_multiplier;
+		//NCO output clock is the reference clock (27MHz) multiplied by
+		//the ncon/ncod fraction.
+		nco_out_clk = 27000000*(ncon/(float)ncod);
+		for (n=2; n<270;++n) {
+			//PLL input clock is NCO output clock divided by N
+			//Valid range is 100kHz to 1000kHz
+			long pll_in_clk = nco_out_clk/n;
+			if ( pll_in_clk >=100000 && pll_in_clk <=1000000) {
+				for (m=2; m<3000;++m) {
+					//PLL output clock is PLL input clock multiplied
+					//by M. Valid range is 100MHz to 300MHz
+					long pll_out_clk = pll_in_clk * m;
+					if (pll_out_clk >=100000000 && pll_out_clk <= 300000000) {
+						//Output clocks are PLL output clock divided by P.
+						//Valid range is anything LESS than 150MHz, but
+						//it must match the incoming pixel clock rate.
+						long output_clk = pll_out_clk/pll_multiplier;
+						if (output_clk == dotclock || output_clk+1 == dotclock || output_clk-1 == dotclock) {
+							//Got it - the pll is now correctly aligned
+							//Set up the PLL registers
+							regs[0x10] = (ncon)&0xFF;
+							regs[0x11] = (ncon>>8)&0xFF ;
+							regs[0x12] = (ncon>>16)&0xFF ;
+							regs[0x13] = (ncon>>24)&0xFF ;
+							regs[0x14] = (ncod)&0xFF ;
+							regs[0x15] = (ncod>>8)&0xFF ;
+							regs[0x16] = (ncod>>16)&0xFF ;
+							regs[0x17] = (ncod>>24)&0xFF ;
+
+							regs[0x18] = (m-17)&0xFF;
+							regs[0x19] = ((m-17)>>8)&0xFF;
+							regs[0x1A] = (n-1)&0xFF ;
+							regs[0x1B] = ((n-1)>>8)&0xFF ;
+							regs[0x1C] = (pll_multiplier-1)&0xFF;
+							regs[0x1D] = (pll_multiplier-1)&0xFF;
+							return 1;
+						}
+					}
+				}
+			}
+		}	
+	}
+	//Seems no valid solution was possible 
+	return 0;
+}
+
diff -uprN a/drivers/video/xbox/focus.h b/drivers/video/xbox/focus.h
--- a/drivers/video/xbox/focus.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/focus.h	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,25 @@
+/*
+ * linux/drivers/video/riva/focus.c - Xbox driver for Focus encoder
+ *
+ * Maintainer: David Pye (dmp) <dmp@davidmpye.dyndns.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * Known bugs and issues:
+ *
+ * none
+ */
+
+
+#ifndef focus_h_
+#define focus_h_
+
+#include <linux/slab.h>
+#include "encoder.h"
+#include "xboxfb.h"
+
+int focus_calc_mode(xbox_video_mode * mode, struct riva_regs * riva_out );
+int focus_calc_hdtv_mode(xbox_hdtv_mode hdtv_mode, unsigned char pll_int, void **encoder_regs);
+#endif
diff -uprN a/drivers/video/xbox/nv_driver.c b/drivers/video/xbox/nv_driver.c
--- a/drivers/video/xbox/nv_driver.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/nv_driver.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,364 @@
+/* $XConsortium: nv_driver.c /main/3 1996/10/28 05:13:37 kaleb $ */
+/*
+ * Copyright 1996-1997  David J. McKay
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * DAVID J. MCKAY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * GPL licensing note -- nVidia is allowing a liberal interpretation of
+ * the documentation restriction above, to merely say that this nVidia's
+ * copyright and disclaimer should be included with all code derived
+ * from this source.  -- Jeff Garzik <jgarzik@pobox.com>, 01/Nov/99 
+ */
+
+/* Hacked together from mga driver and 3.3.4 NVIDIA driver by Jarno Paananen
+   <jpaana@s2.org> */
+
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/nv_setup.c,v 1.18 2002/08/0
+5 20:47:06 mvojkovi Exp $ */
+
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include "nv_type.h"
+#include "xboxfb.h"
+#include "nvreg.h"
+
+
+#ifndef CONFIG_PCI		/* sanity check */
+#error This driver requires PCI support.
+#endif
+
+#define PFX "rivafb: "
+
+static inline unsigned char MISCin(struct riva_par *par)
+{
+	return (VGA_RD08(par->riva.PVIO, 0x3cc));
+}
+
+static Bool 
+riva_is_connected(struct riva_par *par, Bool second)
+{
+	volatile U032 *PRAMDAC = par->riva.PRAMDAC0;
+	U032 reg52C, reg608;
+	Bool present;
+
+	if(second) PRAMDAC += 0x800;
+
+	reg52C = PRAMDAC[0x052C/4];
+	reg608 = PRAMDAC[0x0608/4];
+
+	PRAMDAC[0x0608/4] = reg608 & ~0x00010000;
+
+	PRAMDAC[0x052C/4] = reg52C & 0x0000FEEE;
+	mdelay(1); 
+	PRAMDAC[0x052C/4] |= 1;
+
+	par->riva.PRAMDAC0[0x0610/4] = 0x94050140;
+	par->riva.PRAMDAC0[0x0608/4] |= 0x00001000;
+
+	mdelay(1);
+
+	present = (PRAMDAC[0x0608/4] & (1 << 28)) ? TRUE : FALSE;
+
+	par->riva.PRAMDAC0[0x0608/4] &= 0x0000EFFF;
+
+	PRAMDAC[0x052C/4] = reg52C;
+	PRAMDAC[0x0608/4] = reg608;
+
+	return present;
+}
+
+static void
+riva_override_CRTC(struct riva_par *par)
+{
+	printk(KERN_INFO PFX
+		"Detected CRTC controller %i being used\n",
+		par->SecondCRTC ? 1 : 0);
+
+	if(par->forceCRTC != -1) {
+		printk(KERN_INFO PFX
+			"Forcing usage of CRTC %i\n", par->forceCRTC);
+		par->SecondCRTC = par->forceCRTC;
+	}
+}
+
+static void
+riva_is_second(struct riva_par *par)
+{
+	if (par->FlatPanel == 1) {
+		switch(par->Chipset) {
+		case NV_CHIP_GEFORCE4_440_GO:
+		case NV_CHIP_GEFORCE4_440_GO_M64:
+		case NV_CHIP_GEFORCE4_420_GO:
+		case NV_CHIP_GEFORCE4_420_GO_M32:
+		case NV_CHIP_QUADRO4_500_GOGL:
+			par->SecondCRTC = TRUE;
+			break;
+		default:
+			par->SecondCRTC = FALSE;
+			break;
+		}
+	} else {
+		if(riva_is_connected(par, 0)) {
+			if(par->riva.PRAMDAC0[0x0000052C/4] & 0x100)
+				par->SecondCRTC = TRUE;
+			else
+				par->SecondCRTC = FALSE;
+		} else 
+		if (riva_is_connected(par, 1)) {
+			if(par->riva.PRAMDAC0[0x0000252C/4] & 0x100)
+				par->SecondCRTC = TRUE;
+			else
+				par->SecondCRTC = FALSE;
+		} else /* default */
+			par->SecondCRTC = FALSE;
+	}
+	riva_override_CRTC(par);
+}
+
+unsigned long riva_get_memlen(struct riva_par *par)
+{
+	RIVA_HW_INST *chip = &par->riva;
+	unsigned long memlen = 0;
+	unsigned int chipset = par->Chipset;
+	struct pci_dev* dev;
+	int amt;
+
+	switch (chip->Architecture) {
+	case NV_ARCH_03:
+		if (chip->PFB[0x00000000/4] & 0x00000020) {
+			if (((chip->PMC[0x00000000/4] & 0xF0) == 0x20)
+			    && ((chip->PMC[0x00000000/4] & 0x0F) >= 0x02)) {
+				/*
+				 * SDRAM 128 ZX.
+				 */
+				switch (chip->PFB[0x00000000/4] & 0x03) {
+				case 2:
+					memlen = 1024 * 4;
+					break;
+				case 1:
+					memlen = 1024 * 2;
+					break;
+				default:
+					memlen = 1024 * 8;
+					break;
+				}
+			} else {
+				memlen = 1024 * 8;
+			}            
+		} else 	{
+			/*
+			 * SGRAM 128.
+			 */
+			switch (chip->PFB[0x00000000/4] & 0x00000003) {
+			case 0:
+				memlen = 1024 * 8;
+				break;
+			case 2:
+				memlen = 1024 * 4;
+				break;
+			default:
+				memlen = 1024 * 2;
+				break;
+			}
+		}        
+		break;
+	case NV_ARCH_04:
+		if (chip->PFB[0x00000000/4] & 0x00000100) {
+			memlen = ((chip->PFB[0x00000000/4] >> 12) & 0x0F) * 
+				1024 * 2 + 1024 * 2;
+		} else {
+			switch (chip->PFB[0x00000000/4] & 0x00000003) {
+			case 0:
+				memlen = 1024 * 32;
+				break;
+			case 1:
+				memlen = 1024 * 4;
+				break;
+			case 2:
+				memlen = 1024 * 8;
+				break;
+			case 3:
+			default:
+				memlen = 1024 * 16;
+				break;
+			}
+		}
+		break;
+	case NV_ARCH_10:
+	case NV_ARCH_20:
+		if(chipset == NV_CHIP_IGEFORCE2) {
+
+			dev = pci_find_slot(0, 1);
+			pci_read_config_dword(dev, 0x7C, &amt);
+			memlen = (((amt >> 6) & 31) + 1) * 1024;
+		} else if (chipset == NV_CHIP_0x01F0) {
+			dev = pci_find_slot(0, 1);
+			pci_read_config_dword(dev, 0x84, &amt);
+			memlen = (((amt >> 4) & 127) + 1) * 1024;
+		} else {
+			switch ((chip->PFB[0x0000020C/4] >> 20) & 0x000000FF){
+			case 0x02:
+				memlen = 1024 * 2;
+				break;
+			case 0x04:
+				memlen = 1024 * 4;
+				break;
+			case 0x08:
+				memlen = 1024 * 8;
+				break;
+			case 0x10:
+				memlen = 1024 * 16;
+				break;
+			case 0x20:
+				memlen = 1024 * 32;
+				break;
+			case 0x40:
+				memlen = 1024 * 64;
+				break;
+			case 0x80:
+				memlen = 1024 * 128;
+				break;
+			default:
+				memlen = 1024 * 16;
+				break;
+			}
+		}
+		break;
+	}
+	return memlen;
+}
+
+unsigned long riva_get_maxdclk(struct riva_par *par)
+{
+	RIVA_HW_INST *chip = &par->riva;
+	unsigned long dclk = 0;
+
+	switch (chip->Architecture) {
+	case NV_ARCH_03:
+		if (chip->PFB[0x00000000/4] & 0x00000020) {
+			if (((chip->PMC[0x00000000/4] & 0xF0) == 0x20)
+			    && ((chip->PMC[0x00000000/4] & 0x0F) >= 0x02)) {   
+				/*
+				 * SDRAM 128 ZX.
+				 */
+				dclk = 800000;
+			} else {
+				dclk = 1000000;
+			}            
+		} else {
+			/*
+			 * SGRAM 128.
+			 */
+			dclk = 1000000;
+		} 
+		break;
+	case NV_ARCH_04:
+	case NV_ARCH_10:
+	case NV_ARCH_20:
+		switch ((chip->PFB[0x00000000/4] >> 3) & 0x00000003) {
+		case 3:
+			dclk = 800000;
+			break;
+		default:
+			dclk = 1000000;
+			break;
+		}
+		break;
+	}
+	return dclk;
+}
+
+void
+riva_common_setup(struct riva_par *par)
+{
+	par->riva.EnableIRQ = 0;
+	par->riva.PRAMDAC0 = (unsigned *)(par->ctrl_base + 0x00680000);
+	par->riva.PFB = (unsigned *)(par->ctrl_base + 0x00100000);
+	par->riva.PFIFO = (unsigned *)(par->ctrl_base + 0x00002000);
+	par->riva.PGRAPH = (unsigned *)(par->ctrl_base + 0x00400000);
+	par->riva.PEXTDEV = (unsigned *)(par->ctrl_base + 0x00101000);
+	par->riva.PTIMER = (unsigned *)(par->ctrl_base + 0x00009000);
+	par->riva.PMC = (unsigned *)(par->ctrl_base + 0x00000000);
+	par->riva.FIFO = (unsigned *)(par->ctrl_base + 0x00800000);
+	par->riva.PCIO0 = (U008 *)(par->ctrl_base + 0x00601000);
+	par->riva.PDIO0 = (U008 *)(par->ctrl_base + 0x00681000);
+	par->riva.PVIO = (U008 *)(par->ctrl_base + 0x000C0000);
+
+	par->riva.IO = (MISCin(par) & 0x01) ? 0x3D0 : 0x3B0;
+	
+	if (par->FlatPanel == -1) {
+		switch (par->Chipset) {
+		case NV_CHIP_GEFORCE4_440_GO:
+		case NV_CHIP_GEFORCE4_440_GO_M64:
+		case NV_CHIP_GEFORCE4_420_GO:
+		case NV_CHIP_GEFORCE4_420_GO_M32:
+		case NV_CHIP_QUADRO4_500_GOGL:
+		case NV_CHIP_GEFORCE2_GO:
+			printk(KERN_INFO PFX 
+				"On a laptop.  Assuming Digital Flat Panel\n");
+			par->FlatPanel = 1;
+			break;
+		default:
+			break;
+		}
+	}
+	
+	switch (par->Chipset & 0x0ff0) {
+	case 0x0110:
+		if (par->Chipset == NV_CHIP_GEFORCE2_GO)
+			par->SecondCRTC = TRUE; 
+#if defined(__powerpc__)
+		if (par->FlatPanel == 1)
+			par->SecondCRTC = TRUE;
+#endif
+		riva_override_CRTC(par);
+		break;
+	case 0x0170:
+	case 0x0180:
+	case 0x01F0:
+	case 0x0250:
+	case 0x0280:
+		riva_is_second(par);
+		break;
+	default:
+		break;
+	}
+
+	if (par->SecondCRTC) {
+		par->riva.PCIO = par->riva.PCIO0 + 0x2000;
+		par->riva.PCRTC = par->riva.PCRTC0 + 0x800;
+		par->riva.PRAMDAC = par->riva.PRAMDAC0 + 0x800;
+		par->riva.PDIO = par->riva.PDIO0 + 0x2000;
+	} else {
+		par->riva.PCIO = par->riva.PCIO0;
+		par->riva.PCRTC = par->riva.PCRTC0;
+		par->riva.PRAMDAC = par->riva.PRAMDAC0;
+		par->riva.PDIO = par->riva.PDIO0;
+	}
+
+	if (par->FlatPanel == -1) {
+		/* Fix me, need x86 DDC code */
+		par->FlatPanel = 0;
+	}
+	par->riva.flatPanel = (par->FlatPanel > 0) ? TRUE : FALSE;
+}
+
diff -uprN a/drivers/video/xbox/nv_type.h b/drivers/video/xbox/nv_type.h
--- a/drivers/video/xbox/nv_type.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/nv_type.h	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,58 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/nv_type.h,v 1.35 2002/08/05 20:47:06 mvojkovi Exp $ */
+
+#ifndef __NV_STRUCT_H__
+#define __NV_STRUCT_H__
+
+#define NV_CHIP_RIVA_128            ((PCI_VENDOR_ID_NVIDIA_SGS << 16)| PCI_DEVICE_ID_NVIDIA_RIVA128)
+#define NV_CHIP_TNT                 ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_TNT)
+#define NV_CHIP_TNT2                ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_TNT2)
+#define NV_CHIP_UTNT2               ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_UTNT2)
+#define NV_CHIP_VTNT2               ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_VTNT2)
+#define NV_CHIP_UVTNT2              ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_UVTNT2)
+#define NV_CHIP_ITNT2               ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_ITNT2)
+#define NV_CHIP_GEFORCE_256         ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_GEFORCE_256)
+#define NV_CHIP_GEFORCE_DDR         ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_GEFORCE_DDR)
+#define NV_CHIP_QUADRO              ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_QUADRO)
+#define NV_CHIP_GEFORCE2_MX         ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX)
+#define NV_CHIP_GEFORCE2_MX_100     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX_100)
+#define NV_CHIP_QUADRO2_MXR         ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO2_MXR)
+#define NV_CHIP_GEFORCE2_GO         ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE2_GO)
+#define NV_CHIP_GEFORCE2_GTS        ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS)
+#define NV_CHIP_GEFORCE2_TI         ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE2_TI)
+#define NV_CHIP_GEFORCE2_ULTRA      ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE2_ULTRA)
+#define NV_CHIP_QUADRO2_PRO         ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO2_PRO)
+#define NV_CHIP_GEFORCE4_MX_460     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_460)
+#define NV_CHIP_GEFORCE4_MX_440     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_440)
+#define NV_CHIP_GEFORCE4_MX_420     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_420)
+#define NV_CHIP_GEFORCE4_440_GO     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_440_GO)
+#define NV_CHIP_GEFORCE4_420_GO     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_420_GO)
+#define NV_CHIP_GEFORCE4_420_GO_M32 ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_420_GO_M32)
+#define NV_CHIP_QUADRO4_500XGL      ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO4_500XGL)
+#define NV_CHIP_GEFORCE4_440_GO_M64 ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_440_GO_M64)
+#define NV_CHIP_QUADRO4_200         ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO4_200)
+#define NV_CHIP_QUADRO4_550XGL      ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO4_550XGL)
+#define NV_CHIP_QUADRO4_500_GOGL    ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO4_500_GOGL)
+#define NV_CHIP_0x0180              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0180)
+#define NV_CHIP_0x0181              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0181)
+#define NV_CHIP_0x0182              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0182)
+#define NV_CHIP_0x0188              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0188)
+#define NV_CHIP_0x018A              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x018A)
+#define NV_CHIP_0x018B              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x018B)
+#define NV_CHIP_IGEFORCE2           ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_IGEFORCE2)
+#define NV_CHIP_0x01F0              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x01F0)
+#define NV_CHIP_GEFORCE3            ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE3)
+#define NV_CHIP_GEFORCE3_TI_200     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE3_TI_200)
+#define NV_CHIP_GEFORCE3_TI_500     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE3_TI_500)
+#define NV_CHIP_QUADRO_DCC          ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO_DCC)
+#define NV_CHIP_GEFORCE4_TI_4600    ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4600)
+#define NV_CHIP_GEFORCE4_TI_4400    ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4400)
+#define NV_CHIP_GEFORCE4_TI_4200    ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4200)
+#define NV_CHIP_QUADRO4_900XGL      ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO4_900XGL)
+#define NV_CHIP_QUADRO4_750XGL      ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO4_750XGL)
+#define NV_CHIP_QUADRO4_700XGL      ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO4_700XGL)
+#define NV_CHIP_0x0280              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0280)
+#define NV_CHIP_0x0281              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0281)
+#define NV_CHIP_0x0288              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0288)
+#define NV_CHIP_0x0289              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0289)
+
+#endif /* __NV_STRUCT_H__ */
diff -uprN a/drivers/video/xbox/nvreg.h b/drivers/video/xbox/nvreg.h
--- a/drivers/video/xbox/nvreg.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/nvreg.h	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,188 @@
+/* $XConsortium: nvreg.h /main/2 1996/10/28 05:13:41 kaleb $ */
+/*
+ * Copyright 1996-1997  David J. McKay
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * DAVID J. MCKAY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvreg.h,v 3.2.2.1 1998/01/18 10:35:36 hohndel Exp $ */
+
+#ifndef __NVREG_H_
+#define __NVREG_H_
+
+/* Little macro to construct bitmask for contiguous ranges of bits */
+#define BITMASK(t,b) (((unsigned)(1U << (((t)-(b)+1)))-1)  << (b))
+#define MASKEXPAND(mask) BITMASK(1?mask,0?mask)
+
+/* Macro to set specific bitfields (mask has to be a macro x:y) ! */
+#define SetBF(mask,value) ((value) << (0?mask))
+#define GetBF(var,mask) (((unsigned)((var) & MASKEXPAND(mask))) >> (0?mask) )
+
+#define MaskAndSetBF(var,mask,value) (var)=(((var)&(~MASKEXPAND(mask)) \
+                                             | SetBF(mask,value)))
+
+#define DEVICE_BASE(device) (0?NV##_##device)
+#define DEVICE_SIZE(device) ((1?NV##_##device) - DEVICE_BASE(device)+1)
+
+/* This is where we will have to have conditional compilation */
+#define DEVICE_ACCESS(device,reg) \
+  nvCONTROL[(NV_##device##_##reg)/4]
+
+#define DEVICE_WRITE(device,reg,value) DEVICE_ACCESS(device,reg)=(value)
+#define DEVICE_READ(device,reg)        DEVICE_ACCESS(device,reg)
+#define DEVICE_PRINT(device,reg) \
+  ErrorF("NV_"#device"_"#reg"=#%08lx\n",DEVICE_ACCESS(device,reg))
+#define DEVICE_DEF(device,mask,value) \
+  SetBF(NV_##device##_##mask,NV_##device##_##mask##_##value)
+#define DEVICE_VALUE(device,mask,value) SetBF(NV_##device##_##mask,value)
+#define DEVICE_MASK(device,mask) MASKEXPAND(NV_##device##_##mask)
+
+#define PDAC_Write(reg,value)           DEVICE_WRITE(PDAC,reg,value)
+#define PDAC_Read(reg)                  DEVICE_READ(PDAC,reg)
+#define PDAC_Print(reg)                 DEVICE_PRINT(PDAC,reg)
+#define PDAC_Def(mask,value)            DEVICE_DEF(PDAC,mask,value)
+#define PDAC_Val(mask,value)            DEVICE_VALUE(PDAC,mask,value)
+#define PDAC_Mask(mask)                 DEVICE_MASK(PDAC,mask)
+
+#define PFB_Write(reg,value)            DEVICE_WRITE(PFB,reg,value)
+#define PFB_Read(reg)                   DEVICE_READ(PFB,reg)
+#define PFB_Print(reg)                  DEVICE_PRINT(PFB,reg)
+#define PFB_Def(mask,value)             DEVICE_DEF(PFB,mask,value)
+#define PFB_Val(mask,value)             DEVICE_VALUE(PFB,mask,value)
+#define PFB_Mask(mask)                  DEVICE_MASK(PFB,mask)
+
+#define PRM_Write(reg,value)            DEVICE_WRITE(PRM,reg,value)
+#define PRM_Read(reg)                   DEVICE_READ(PRM,reg)
+#define PRM_Print(reg)                  DEVICE_PRINT(PRM,reg)
+#define PRM_Def(mask,value)             DEVICE_DEF(PRM,mask,value)
+#define PRM_Val(mask,value)             DEVICE_VALUE(PRM,mask,value)
+#define PRM_Mask(mask)                  DEVICE_MASK(PRM,mask)
+
+#define PGRAPH_Write(reg,value)         DEVICE_WRITE(PGRAPH,reg,value)
+#define PGRAPH_Read(reg)                DEVICE_READ(PGRAPH,reg)
+#define PGRAPH_Print(reg)               DEVICE_PRINT(PGRAPH,reg)
+#define PGRAPH_Def(mask,value)          DEVICE_DEF(PGRAPH,mask,value)
+#define PGRAPH_Val(mask,value)          DEVICE_VALUE(PGRAPH,mask,value)
+#define PGRAPH_Mask(mask)               DEVICE_MASK(PGRAPH,mask)
+
+#define PDMA_Write(reg,value)           DEVICE_WRITE(PDMA,reg,value)
+#define PDMA_Read(reg)                  DEVICE_READ(PDMA,reg)
+#define PDMA_Print(reg)                 DEVICE_PRINT(PDMA,reg)
+#define PDMA_Def(mask,value)            DEVICE_DEF(PDMA,mask,value)
+#define PDMA_Val(mask,value)            DEVICE_VALUE(PDMA,mask,value)
+#define PDMA_Mask(mask)                 DEVICE_MASK(PDMA,mask)
+
+#define PTIMER_Write(reg,value)         DEVICE_WRITE(PTIMER,reg,value)
+#define PTIMER_Read(reg)                DEVICE_READ(PTIMER,reg)
+#define PTIMER_Print(reg)               DEVICE_PRINT(PTIMER,reg)
+#define PTIMER_Def(mask,value)          DEVICE_DEF(PTIMER,mask,value)
+#define PTIMER_Val(mask,value)          DEVICE_VALUE(PTIEMR,mask,value)
+#define PTIMER_Mask(mask)               DEVICE_MASK(PTIMER,mask)
+
+#define PEXTDEV_Write(reg,value)         DEVICE_WRITE(PEXTDEV,reg,value)
+#define PEXTDEV_Read(reg)                DEVICE_READ(PEXTDEV,reg)
+#define PEXTDEV_Print(reg)               DEVICE_PRINT(PEXTDEV,reg)
+#define PEXTDEV_Def(mask,value)          DEVICE_DEF(PEXTDEV,mask,value)
+#define PEXTDEV_Val(mask,value)          DEVICE_VALUE(PEXTDEV,mask,value)
+#define PEXTDEV_Mask(mask)               DEVICE_MASK(PEXTDEV,mask)
+
+#define PFIFO_Write(reg,value)          DEVICE_WRITE(PFIFO,reg,value)
+#define PFIFO_Read(reg)                 DEVICE_READ(PFIFO,reg)
+#define PFIFO_Print(reg)                DEVICE_PRINT(PFIFO,reg)
+#define PFIFO_Def(mask,value)           DEVICE_DEF(PFIFO,mask,value)
+#define PFIFO_Val(mask,value)           DEVICE_VALUE(PFIFO,mask,value)
+#define PFIFO_Mask(mask)                DEVICE_MASK(PFIFO,mask)
+
+#define PRAM_Write(reg,value)           DEVICE_WRITE(PRAM,reg,value)
+#define PRAM_Read(reg)                  DEVICE_READ(PRAM,reg)
+#define PRAM_Print(reg)                 DEVICE_PRINT(PRAM,reg)
+#define PRAM_Def(mask,value)            DEVICE_DEF(PRAM,mask,value)
+#define PRAM_Val(mask,value)            DEVICE_VALUE(PRAM,mask,value)
+#define PRAM_Mask(mask)                 DEVICE_MASK(PRAM,mask)
+
+#define PRAMFC_Write(reg,value)         DEVICE_WRITE(PRAMFC,reg,value)
+#define PRAMFC_Read(reg)                DEVICE_READ(PRAMFC,reg)
+#define PRAMFC_Print(reg)               DEVICE_PRINT(PRAMFC,reg)
+#define PRAMFC_Def(mask,value)          DEVICE_DEF(PRAMFC,mask,value)
+#define PRAMFC_Val(mask,value)          DEVICE_VALUE(PRAMFC,mask,value)
+#define PRAMFC_Mask(mask)               DEVICE_MASK(PRAMFC,mask)
+
+#define PMC_Write(reg,value)            DEVICE_WRITE(PMC,reg,value)
+#define PMC_Read(reg)                   DEVICE_READ(PMC,reg)
+#define PMC_Print(reg)                  DEVICE_PRINT(PMC,reg)
+#define PMC_Def(mask,value)             DEVICE_DEF(PMC,mask,value)
+#define PMC_Val(mask,value)             DEVICE_VALUE(PMC,mask,value)
+#define PMC_Mask(mask)                  DEVICE_MASK(PMC,mask)
+
+#define PMC_Write(reg,value)            DEVICE_WRITE(PMC,reg,value)
+#define PMC_Read(reg)                   DEVICE_READ(PMC,reg)
+#define PMC_Print(reg)                  DEVICE_PRINT(PMC,reg)
+#define PMC_Def(mask,value)             DEVICE_DEF(PMC,mask,value)
+#define PMC_Val(mask,value)             DEVICE_VALUE(PMC,mask,value)
+#define PMC_Mask(mask)                  DEVICE_MASK(PMC,mask)
+
+
+#define PBUS_Write(reg,value)         DEVICE_WRITE(PBUS,reg,value)
+#define PBUS_Read(reg)                DEVICE_READ(PBUS,reg)
+#define PBUS_Print(reg)               DEVICE_PRINT(PBUS,reg)
+#define PBUS_Def(mask,value)          DEVICE_DEF(PBUS,mask,value)
+#define PBUS_Val(mask,value)          DEVICE_VALUE(PBUS,mask,value)
+#define PBUS_Mask(mask)               DEVICE_MASK(PBUS,mask)
+
+
+#define PRAMDAC_Write(reg,value)         DEVICE_WRITE(PRAMDAC,reg,value)
+#define PRAMDAC_Read(reg)                DEVICE_READ(PRAMDAC,reg)
+#define PRAMDAC_Print(reg)               DEVICE_PRINT(PRAMDAC,reg)
+#define PRAMDAC_Def(mask,value)          DEVICE_DEF(PRAMDAC,mask,value)
+#define PRAMDAC_Val(mask,value)          DEVICE_VALUE(PRAMDAC,mask,value)
+#define PRAMDAC_Mask(mask)               DEVICE_MASK(PRAMDAC,mask)
+
+
+#define PDAC_ReadExt(reg) \
+  ((PDAC_Write(INDEX_LO,(NV_PDAC_EXT_##reg) & 0xff)),\
+  (PDAC_Write(INDEX_HI,((NV_PDAC_EXT_##reg) >> 8) & 0xff)),\
+  (PDAC_Read(INDEX_DATA)))
+
+#define PDAC_WriteExt(reg,value)\
+  ((PDAC_Write(INDEX_LO,(NV_PDAC_EXT_##reg) & 0xff)),\
+  (PDAC_Write(INDEX_HI,((NV_PDAC_EXT_##reg) >> 8) & 0xff)),\
+  (PDAC_Write(INDEX_DATA,(value))))
+
+#define CRTC_Write(index,value) outb((index), 0x3d4); outb(value, 0x3d5)
+#define CRTC_Read(index) (outb(index, 0x3d4),inb(0x3d5))
+
+#define PCRTC_Write(index,value) CRTC_Write(NV_PCRTC_##index,value)
+#define PCRTC_Read(index) CRTC_Read(NV_PCRTC_##index)
+
+#define PCRTC_Def(mask,value)          DEVICE_DEF(PCRTC,mask,value)
+#define PCRTC_Val(mask,value)          DEVICE_VALUE(PCRTC,mask,value)
+#define PCRTC_Mask(mask)               DEVICE_MASK(PCRTC,mask)
+
+#define SR_Write(index,value) outb(0x3c4,(index));outb(0x3c5,value)
+#define SR_Read(index) (outb(0x3c4,index),inb(0x3c5))
+
+extern volatile unsigned  *nvCONTROL;
+
+typedef enum {NV1,NV3,NV4,NumNVChips} NVChipType;
+
+NVChipType GetChipType(void);
+
+#endif
+
+
diff -uprN a/drivers/video/xbox/riva_hw.c b/drivers/video/xbox/riva_hw.c
--- a/drivers/video/xbox/riva_hw.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/riva_hw.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,2463 @@
+ /***************************************************************************\
+|*                                                                           *|
+|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
+|*                                                                           *|
+|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
+|*     international laws.  Users and possessors of this source code are     *|
+|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
+|*     use this code in individual and commercial software.                  *|
+|*                                                                           *|
+|*     Any use of this source code must include,  in the user documenta-     *|
+|*     tion and  internal comments to the code,  notices to the end user     *|
+|*     as follows:                                                           *|
+|*                                                                           *|
+|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
+|*                                                                           *|
+|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
+|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
+|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
+|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
+|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
+|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
+|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
+|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
+|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
+|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
+|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
+|*                                                                           *|
+|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
+|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
+|*     consisting  of "commercial  computer  software"  and  "commercial     *|
+|*     computer  software  documentation,"  as such  terms  are  used in     *|
+|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
+|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
+|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
+|*     all U.S. Government End Users  acquire the source code  with only     *|
+|*     those rights set forth herein.                                        *|
+|*                                                                           *|
+ \***************************************************************************/
+
+/*
+ * GPL licensing note -- nVidia is allowing a liberal interpretation of
+ * the documentation restriction above, to merely say that this nVidia's
+ * copyright and disclaimer should be included with all code derived
+ * from this source.  -- Jeff Garzik <jgarzik@pobox.com>, 01/Nov/99 
+ */
+
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/riva_hw.c,v 1.33 2002/08/05 20:47:06 mvojkovi Exp $ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include "riva_hw.h"
+#include "riva_tbl.h"
+#include "nv_type.h"
+
+/*
+ * This file is an OS-agnostic file used to make RIVA 128 and RIVA TNT
+ * operate identically (except TNT has more memory and better 3D quality.
+ */
+static int nv3Busy
+(
+    RIVA_HW_INST *chip
+)
+{
+    return ((NV_RD32(&chip->Rop->FifoFree, 0) < chip->FifoEmptyCount) ||
+	    NV_RD32(&chip->PGRAPH[0x000006B0/4], 0) & 0x01);
+}
+static int nv4Busy
+(
+    RIVA_HW_INST *chip
+)
+{
+    return ((NV_RD32(&chip->Rop->FifoFree, 0) < chip->FifoEmptyCount) ||
+	    NV_RD32(&chip->PGRAPH[0x00000700/4], 0) & 0x01);
+}
+static int nv10Busy
+(
+    RIVA_HW_INST *chip
+)
+{
+    return ((NV_RD32(&chip->Rop->FifoFree, 0) < chip->FifoEmptyCount) ||
+	    NV_RD32(&chip->PGRAPH[0x00000700/4], 0) & 0x01);
+}
+
+static void vgaLockUnlock
+(
+    RIVA_HW_INST *chip,
+    int           Lock
+)
+{
+    U008 cr11;
+    VGA_WR08(chip->PCIO, 0x3D4, 0x11);
+    cr11 = VGA_RD08(chip->PCIO, 0x3D5);
+    if(Lock) cr11 |= 0x80;
+    else cr11 &= ~0x80;
+    VGA_WR08(chip->PCIO, 0x3D5, cr11);
+}
+static void nv3LockUnlock
+(
+    RIVA_HW_INST *chip,
+    int           Lock
+)
+{
+    VGA_WR08(chip->PVIO, 0x3C4, 0x06);
+    VGA_WR08(chip->PVIO, 0x3C5, Lock ? 0x99 : 0x57);
+    vgaLockUnlock(chip, Lock);
+}
+static void nv4LockUnlock
+(
+    RIVA_HW_INST *chip,
+    int           Lock
+)
+{
+    VGA_WR08(chip->PCIO, 0x3D4, 0x1F);
+    VGA_WR08(chip->PCIO, 0x3D5, Lock ? 0x99 : 0x57);
+    vgaLockUnlock(chip, Lock);
+}
+
+static int ShowHideCursor
+(
+    RIVA_HW_INST *chip,
+    int           ShowHide
+)
+{
+    int cursor;
+    cursor                      =  chip->CurrentState->cursor1;
+    chip->CurrentState->cursor1 = (chip->CurrentState->cursor1 & 0xFE) |
+                                  (ShowHide & 0x01);
+    VGA_WR08(chip->PCIO, 0x3D4, 0x31);
+    VGA_WR08(chip->PCIO, 0x3D5, chip->CurrentState->cursor1);
+    return (cursor & 0x01);
+}
+
+/* -- XBOX --- */
+static int nv10ShowHideCursor
+(
+    RIVA_HW_INST *chip,
+    int           ShowHide
+)
+{
+    unsigned int cursor;
+    cursor                           =  chip->CurrentState->cursorConfig;
+    chip->CurrentState->cursorConfig = (NV_RD32(chip->PCRTC, 0x00000810) & 0xFFFFFFFE) |
+                                  (ShowHide & 0x01);
+    NV_WR32(chip->PCRTC, 0x00000810, chip->CurrentState->cursorConfig);
+    return (cursor & 0x01);
+}
+
+
+/****************************************************************************\
+*                                                                            *
+* The video arbitration routines calculate some "magic" numbers.  Fixes      *
+* the snow seen when accessing the framebuffer without it.                   *
+* It just works (I hope).                                                    *
+*                                                                            *
+\****************************************************************************/
+
+#define DEFAULT_GR_LWM 100
+#define DEFAULT_VID_LWM 100
+#define DEFAULT_GR_BURST_SIZE 256
+#define DEFAULT_VID_BURST_SIZE 128
+#define VIDEO		0
+#define GRAPHICS	1
+#define MPORT		2
+#define ENGINE		3
+#define GFIFO_SIZE	320
+#define GFIFO_SIZE_128	256
+#define MFIFO_SIZE	120
+#define VFIFO_SIZE	256
+
+typedef struct {
+  int gdrain_rate;
+  int vdrain_rate;
+  int mdrain_rate;
+  int gburst_size;
+  int vburst_size;
+  char vid_en;
+  char gr_en;
+  int wcmocc, wcgocc, wcvocc, wcvlwm, wcglwm;
+  int by_gfacc;
+  char vid_only_once;
+  char gr_only_once;
+  char first_vacc;
+  char first_gacc;
+  char first_macc;
+  int vocc;
+  int gocc;
+  int mocc;
+  char cur;
+  char engine_en;
+  char converged;
+  int priority;
+} nv3_arb_info;
+typedef struct {
+  int graphics_lwm;
+  int video_lwm;
+  int graphics_burst_size;
+  int video_burst_size;
+  int graphics_hi_priority;
+  int media_hi_priority;
+  int rtl_values;
+  int valid;
+} nv3_fifo_info;
+typedef struct {
+  char pix_bpp;
+  char enable_video;
+  char gr_during_vid;
+  char enable_mp;
+  int memory_width;
+  int video_scale;
+  int pclk_khz;
+  int mclk_khz;
+  int mem_page_miss;
+  int mem_latency;
+  char mem_aligned;
+} nv3_sim_state;
+typedef struct {
+  int graphics_lwm;
+  int video_lwm;
+  int graphics_burst_size;
+  int video_burst_size;
+  int valid;
+} nv4_fifo_info;
+typedef struct {
+  int pclk_khz;
+  int mclk_khz;
+  int nvclk_khz;
+  char mem_page_miss;
+  char mem_latency;
+  int memory_width;
+  char enable_video;
+  char gr_during_vid;
+  char pix_bpp;
+  char mem_aligned;
+  char enable_mp;
+} nv4_sim_state;
+typedef struct {
+  int graphics_lwm;
+  int video_lwm;
+  int graphics_burst_size;
+  int video_burst_size;
+  int valid;
+} nv10_fifo_info;
+typedef struct {
+  int pclk_khz;
+  int mclk_khz;
+  int nvclk_khz;
+  char mem_page_miss;
+  char mem_latency;
+  int memory_type;
+  int memory_width;
+  char enable_video;
+  char gr_during_vid;
+  char pix_bpp;
+  char mem_aligned;
+  char enable_mp;
+} nv10_sim_state;
+static int nv3_iterate(nv3_fifo_info *res_info, nv3_sim_state * state, nv3_arb_info *ainfo)
+{
+    int iter = 0;
+    int tmp;
+    int vfsize, mfsize, gfsize;
+    int mburst_size = 32;
+    int mmisses, gmisses, vmisses;
+    int misses;
+    int vlwm, glwm, mlwm;
+    int last, next, cur;
+    int max_gfsize ;
+    long ns;
+
+    vlwm = 0;
+    glwm = 0;
+    mlwm = 0;
+    vfsize = 0;
+    gfsize = 0;
+    cur = ainfo->cur;
+    mmisses = 2;
+    gmisses = 2;
+    vmisses = 2;
+    if (ainfo->gburst_size == 128) max_gfsize = GFIFO_SIZE_128;
+    else  max_gfsize = GFIFO_SIZE;
+    max_gfsize = GFIFO_SIZE;
+    while (1)
+    {
+        if (ainfo->vid_en)
+        {
+            if (ainfo->wcvocc > ainfo->vocc) ainfo->wcvocc = ainfo->vocc;
+            if (ainfo->wcvlwm > vlwm) ainfo->wcvlwm = vlwm ;
+            ns = 1000000 * ainfo->vburst_size/(state->memory_width/8)/state->mclk_khz;
+            vfsize = ns * ainfo->vdrain_rate / 1000000;
+            vfsize =  ainfo->wcvlwm - ainfo->vburst_size + vfsize;
+        }
+        if (state->enable_mp)
+        {
+            if (ainfo->wcmocc > ainfo->mocc) ainfo->wcmocc = ainfo->mocc;
+        }
+        if (ainfo->gr_en)
+        {
+            if (ainfo->wcglwm > glwm) ainfo->wcglwm = glwm ;
+            if (ainfo->wcgocc > ainfo->gocc) ainfo->wcgocc = ainfo->gocc;
+            ns = 1000000 * (ainfo->gburst_size/(state->memory_width/8))/state->mclk_khz;
+            gfsize = (ns * (long) ainfo->gdrain_rate)/1000000;
+            gfsize = ainfo->wcglwm - ainfo->gburst_size + gfsize;
+        }
+        mfsize = 0;
+        if (!state->gr_during_vid && ainfo->vid_en)
+            if (ainfo->vid_en && (ainfo->vocc < 0) && !ainfo->vid_only_once)
+                next = VIDEO;
+            else if (ainfo->mocc < 0)
+                next = MPORT;
+            else if (ainfo->gocc< ainfo->by_gfacc)
+                next = GRAPHICS;
+            else return (0);
+        else switch (ainfo->priority)
+            {
+                case VIDEO:
+                    if (ainfo->vid_en && ainfo->vocc<0 && !ainfo->vid_only_once)
+                        next = VIDEO;
+                    else if (ainfo->gr_en && ainfo->gocc<0 && !ainfo->gr_only_once)
+                        next = GRAPHICS;
+                    else if (ainfo->mocc<0)
+                        next = MPORT;
+                    else    return (0);
+                    break;
+                case GRAPHICS:
+                    if (ainfo->gr_en && ainfo->gocc<0 && !ainfo->gr_only_once)
+                        next = GRAPHICS;
+                    else if (ainfo->vid_en && ainfo->vocc<0 && !ainfo->vid_only_once)
+                        next = VIDEO;
+                    else if (ainfo->mocc<0)
+                        next = MPORT;
+                    else    return (0);
+                    break;
+                default:
+                    if (ainfo->mocc<0)
+                        next = MPORT;
+                    else if (ainfo->gr_en && ainfo->gocc<0 && !ainfo->gr_only_once)
+                        next = GRAPHICS;
+                    else if (ainfo->vid_en && ainfo->vocc<0 && !ainfo->vid_only_once)
+                        next = VIDEO;
+                    else    return (0);
+                    break;
+            }
+        last = cur;
+        cur = next;
+        iter++;
+        switch (cur)
+        {
+            case VIDEO:
+                if (last==cur)    misses = 0;
+                else if (ainfo->first_vacc)   misses = vmisses;
+                else    misses = 1;
+                ainfo->first_vacc = 0;
+                if (last!=cur)
+                {
+                    ns =  1000000 * (vmisses*state->mem_page_miss + state->mem_latency)/state->mclk_khz; 
+                    vlwm = ns * ainfo->vdrain_rate/ 1000000;
+                    vlwm = ainfo->vocc - vlwm;
+                }
+                ns = 1000000*(misses*state->mem_page_miss + ainfo->vburst_size)/(state->memory_width/8)/state->mclk_khz;
+                ainfo->vocc = ainfo->vocc + ainfo->vburst_size - ns*ainfo->vdrain_rate/1000000;
+                ainfo->gocc = ainfo->gocc - ns*ainfo->gdrain_rate/1000000;
+                ainfo->mocc = ainfo->mocc - ns*ainfo->mdrain_rate/1000000;
+                break;
+            case GRAPHICS:
+                if (last==cur)    misses = 0;
+                else if (ainfo->first_gacc)   misses = gmisses;
+                else    misses = 1;
+                ainfo->first_gacc = 0;
+                if (last!=cur)
+                {
+                    ns = 1000000*(gmisses*state->mem_page_miss + state->mem_latency)/state->mclk_khz ;
+                    glwm = ns * ainfo->gdrain_rate/1000000;
+                    glwm = ainfo->gocc - glwm;
+                }
+                ns = 1000000*(misses*state->mem_page_miss + ainfo->gburst_size/(state->memory_width/8))/state->mclk_khz;
+                ainfo->vocc = ainfo->vocc + 0 - ns*ainfo->vdrain_rate/1000000;
+                ainfo->gocc = ainfo->gocc + ainfo->gburst_size - ns*ainfo->gdrain_rate/1000000;
+                ainfo->mocc = ainfo->mocc + 0 - ns*ainfo->mdrain_rate/1000000;
+                break;
+            default:
+                if (last==cur)    misses = 0;
+                else if (ainfo->first_macc)   misses = mmisses;
+                else    misses = 1;
+                ainfo->first_macc = 0;
+                ns = 1000000*(misses*state->mem_page_miss + mburst_size/(state->memory_width/8))/state->mclk_khz;
+                ainfo->vocc = ainfo->vocc + 0 - ns*ainfo->vdrain_rate/1000000;
+                ainfo->gocc = ainfo->gocc + 0 - ns*ainfo->gdrain_rate/1000000;
+                ainfo->mocc = ainfo->mocc + mburst_size - ns*ainfo->mdrain_rate/1000000;
+                break;
+        }
+        if (iter>100)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        ns = 1000000*ainfo->gburst_size/(state->memory_width/8)/state->mclk_khz;
+        tmp = ns * ainfo->gdrain_rate/1000000;
+        if (abs(ainfo->gburst_size) + ((abs(ainfo->wcglwm) + 16 ) & ~0x7) - tmp > max_gfsize)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        ns = 1000000*ainfo->vburst_size/(state->memory_width/8)/state->mclk_khz;
+        tmp = ns * ainfo->vdrain_rate/1000000;
+        if (abs(ainfo->vburst_size) + (abs(ainfo->wcvlwm + 32) & ~0xf)  - tmp> VFIFO_SIZE)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        if (abs(ainfo->gocc) > max_gfsize)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        if (abs(ainfo->vocc) > VFIFO_SIZE)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        if (abs(ainfo->mocc) > MFIFO_SIZE)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        if (abs(vfsize) > VFIFO_SIZE)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        if (abs(gfsize) > max_gfsize)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        if (abs(mfsize) > MFIFO_SIZE)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+    }
+}
+static char nv3_arb(nv3_fifo_info * res_info, nv3_sim_state * state,  nv3_arb_info *ainfo) 
+{
+    long ens, vns, mns, gns;
+    int mmisses, gmisses, vmisses, eburst_size, mburst_size;
+    int refresh_cycle;
+
+    refresh_cycle = 0;
+    refresh_cycle = 2*(state->mclk_khz/state->pclk_khz) + 5;
+    mmisses = 2;
+    if (state->mem_aligned) gmisses = 2;
+    else    gmisses = 3;
+    vmisses = 2;
+    eburst_size = state->memory_width * 1;
+    mburst_size = 32;
+    gns = 1000000 * (gmisses*state->mem_page_miss + state->mem_latency)/state->mclk_khz;
+    ainfo->by_gfacc = gns*ainfo->gdrain_rate/1000000;
+    ainfo->wcmocc = 0;
+    ainfo->wcgocc = 0;
+    ainfo->wcvocc = 0;
+    ainfo->wcvlwm = 0;
+    ainfo->wcglwm = 0;
+    ainfo->engine_en = 1;
+    ainfo->converged = 1;
+    if (ainfo->engine_en)
+    {
+        ens =  1000000*(state->mem_page_miss + eburst_size/(state->memory_width/8) +refresh_cycle)/state->mclk_khz;
+        ainfo->mocc = state->enable_mp ? 0-ens*ainfo->mdrain_rate/1000000 : 0;
+        ainfo->vocc = ainfo->vid_en ? 0-ens*ainfo->vdrain_rate/1000000 : 0;
+        ainfo->gocc = ainfo->gr_en ? 0-ens*ainfo->gdrain_rate/1000000 : 0;
+        ainfo->cur = ENGINE;
+        ainfo->first_vacc = 1;
+        ainfo->first_gacc = 1;
+        ainfo->first_macc = 1;
+        nv3_iterate(res_info, state,ainfo);
+    }
+    if (state->enable_mp)
+    {
+        mns = 1000000 * (mmisses*state->mem_page_miss + mburst_size/(state->memory_width/8) + refresh_cycle)/state->mclk_khz;
+        ainfo->mocc = state->enable_mp ? 0 : mburst_size - mns*ainfo->mdrain_rate/1000000;
+        ainfo->vocc = ainfo->vid_en ? 0 : 0- mns*ainfo->vdrain_rate/1000000;
+        ainfo->gocc = ainfo->gr_en ? 0: 0- mns*ainfo->gdrain_rate/1000000;
+        ainfo->cur = MPORT;
+        ainfo->first_vacc = 1;
+        ainfo->first_gacc = 1;
+        ainfo->first_macc = 0;
+        nv3_iterate(res_info, state,ainfo);
+    }
+    if (ainfo->gr_en)
+    {
+        ainfo->first_vacc = 1;
+        ainfo->first_gacc = 0;
+        ainfo->first_macc = 1;
+        gns = 1000000*(gmisses*state->mem_page_miss + ainfo->gburst_size/(state->memory_width/8) + refresh_cycle)/state->mclk_khz;
+        ainfo->gocc = ainfo->gburst_size - gns*ainfo->gdrain_rate/1000000;
+        ainfo->vocc = ainfo->vid_en? 0-gns*ainfo->vdrain_rate/1000000 : 0;
+        ainfo->mocc = state->enable_mp ?  0-gns*ainfo->mdrain_rate/1000000: 0;
+        ainfo->cur = GRAPHICS;
+        nv3_iterate(res_info, state,ainfo);
+    }
+    if (ainfo->vid_en)
+    {
+        ainfo->first_vacc = 0;
+        ainfo->first_gacc = 1;
+        ainfo->first_macc = 1;
+        vns = 1000000*(vmisses*state->mem_page_miss + ainfo->vburst_size/(state->memory_width/8) + refresh_cycle)/state->mclk_khz;
+        ainfo->vocc = ainfo->vburst_size - vns*ainfo->vdrain_rate/1000000;
+        ainfo->gocc = ainfo->gr_en? (0-vns*ainfo->gdrain_rate/1000000) : 0;
+        ainfo->mocc = state->enable_mp? 0-vns*ainfo->mdrain_rate/1000000 :0 ;
+        ainfo->cur = VIDEO;
+        nv3_iterate(res_info, state, ainfo);
+    }
+    if (ainfo->converged)
+    {
+        res_info->graphics_lwm = (int)abs(ainfo->wcglwm) + 16;
+        res_info->video_lwm = (int)abs(ainfo->wcvlwm) + 32;
+        res_info->graphics_burst_size = ainfo->gburst_size;
+        res_info->video_burst_size = ainfo->vburst_size;
+        res_info->graphics_hi_priority = (ainfo->priority == GRAPHICS);
+        res_info->media_hi_priority = (ainfo->priority == MPORT);
+        if (res_info->video_lwm > 160)
+        {
+            res_info->graphics_lwm = 256;
+            res_info->video_lwm = 128;
+            res_info->graphics_burst_size = 64;
+            res_info->video_burst_size = 64;
+            res_info->graphics_hi_priority = 0;
+            res_info->media_hi_priority = 0;
+            ainfo->converged = 0;
+            return (0);
+        }
+        if (res_info->video_lwm > 128)
+        {
+            res_info->video_lwm = 128;
+        }
+        return (1);
+    }
+    else
+    {
+        res_info->graphics_lwm = 256;
+        res_info->video_lwm = 128;
+        res_info->graphics_burst_size = 64;
+        res_info->video_burst_size = 64;
+        res_info->graphics_hi_priority = 0;
+        res_info->media_hi_priority = 0;
+        return (0);
+    }
+}
+static char nv3_get_param(nv3_fifo_info *res_info, nv3_sim_state * state, nv3_arb_info *ainfo)
+{
+    int done, g,v, p;
+    
+    done = 0;
+    for (p=0; p < 2; p++)
+    {
+        for (g=128 ; g > 32; g= g>> 1)
+        {
+            for (v=128; v >=32; v = v>> 1)
+            {
+                ainfo->priority = p;
+                ainfo->gburst_size = g;     
+                ainfo->vburst_size = v;
+                done = nv3_arb(res_info, state,ainfo);
+                if (done && (g==128))
+                    if ((res_info->graphics_lwm + g) > 256)
+                        done = 0;
+                if (done)
+                    goto Done;
+            }
+        }
+    }
+
+ Done:
+    return done;
+}
+static void nv3CalcArbitration 
+(
+    nv3_fifo_info * res_info,
+    nv3_sim_state * state
+)
+{
+    nv3_fifo_info save_info;
+    nv3_arb_info ainfo;
+    char   res_gr, res_vid;
+
+    ainfo.gr_en = 1;
+    ainfo.vid_en = state->enable_video;
+    ainfo.vid_only_once = 0;
+    ainfo.gr_only_once = 0;
+    ainfo.gdrain_rate = (int) state->pclk_khz * (state->pix_bpp/8);
+    ainfo.vdrain_rate = (int) state->pclk_khz * 2;
+    if (state->video_scale != 0)
+        ainfo.vdrain_rate = ainfo.vdrain_rate/state->video_scale;
+    ainfo.mdrain_rate = 33000;
+    res_info->rtl_values = 0;
+    if (!state->gr_during_vid && state->enable_video)
+    {
+        ainfo.gr_only_once = 1;
+        ainfo.gr_en = 1;
+        ainfo.gdrain_rate = 0;
+        res_vid = nv3_get_param(res_info, state,  &ainfo);
+        res_vid = ainfo.converged;
+        save_info.video_lwm = res_info->video_lwm;
+        save_info.video_burst_size = res_info->video_burst_size;
+        ainfo.vid_en = 1;
+        ainfo.vid_only_once = 1;
+        ainfo.gr_en = 1;
+        ainfo.gdrain_rate = (int) state->pclk_khz * (state->pix_bpp/8);
+        ainfo.vdrain_rate = 0;
+        res_gr = nv3_get_param(res_info, state,  &ainfo);
+        res_gr = ainfo.converged;
+        res_info->video_lwm = save_info.video_lwm;
+        res_info->video_burst_size = save_info.video_burst_size;
+        res_info->valid = res_gr & res_vid;
+    }
+    else
+    {
+        if (!ainfo.gr_en) ainfo.gdrain_rate = 0;
+        if (!ainfo.vid_en) ainfo.vdrain_rate = 0;
+        res_gr = nv3_get_param(res_info, state,  &ainfo);
+        res_info->valid = ainfo.converged;
+    }
+}
+static void nv3UpdateArbitrationSettings
+(
+    unsigned      VClk, 
+    unsigned      pixelDepth, 
+    unsigned     *burst,
+    unsigned     *lwm,
+    RIVA_HW_INST *chip
+)
+{
+    nv3_fifo_info fifo_data;
+    nv3_sim_state sim_data;
+    unsigned int M, N, P, pll, MClk;
+    
+    pll = NV_RD32(&chip->PRAMDAC0[0x00000504/4], 0);
+    M = (pll >> 0) & 0xFF; N = (pll >> 8) & 0xFF; P = (pll >> 16) & 0x0F;
+    MClk = (N * chip->CrystalFreqKHz / M) >> P;
+    sim_data.pix_bpp        = (char)pixelDepth;
+    sim_data.enable_video   = 0;
+    sim_data.enable_mp      = 0;
+    sim_data.video_scale    = 1;
+    sim_data.memory_width   = (NV_RD32(&chip->PEXTDEV[0x00000000/4], 0) & 0x10) ?
+	128 : 64;
+    sim_data.memory_width   = 128;
+
+    sim_data.mem_latency    = 9;
+    sim_data.mem_aligned    = 1;
+    sim_data.mem_page_miss  = 11;
+    sim_data.gr_during_vid  = 0;
+    sim_data.pclk_khz       = VClk;
+    sim_data.mclk_khz       = MClk;
+    nv3CalcArbitration(&fifo_data, &sim_data);
+    if (fifo_data.valid)
+    {
+        int  b = fifo_data.graphics_burst_size >> 4;
+        *burst = 0;
+        while (b >>= 1)
+	    (*burst)++;
+        *lwm   = fifo_data.graphics_lwm >> 3;
+    }
+    else
+    {
+        *lwm   = 0x24;
+        *burst = 0x2;
+    }
+}
+static void nv4CalcArbitration 
+(
+    nv4_fifo_info *fifo,
+    nv4_sim_state *arb
+)
+{
+    int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
+    int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
+    int found, mclk_extra, mclk_loop, cbs, m1, p1;
+    int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
+    int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
+    int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
+    int craw, vraw;
+
+    fifo->valid = 1;
+    pclk_freq = arb->pclk_khz;
+    mclk_freq = arb->mclk_khz;
+    nvclk_freq = arb->nvclk_khz;
+    pagemiss = arb->mem_page_miss;
+    cas = arb->mem_latency;
+    width = arb->memory_width >> 6;
+    video_enable = arb->enable_video;
+    color_key_enable = arb->gr_during_vid;
+    bpp = arb->pix_bpp;
+    align = arb->mem_aligned;
+    mp_enable = arb->enable_mp;
+    clwm = 0;
+    vlwm = 0;
+    cbs = 128;
+    pclks = 2;
+    nvclks = 2;
+    nvclks += 2;
+    nvclks += 1;
+    mclks = 5;
+    mclks += 3;
+    mclks += 1;
+    mclks += cas;
+    mclks += 1;
+    mclks += 1;
+    mclks += 1;
+    mclks += 1;
+    mclk_extra = 3;
+    nvclks += 2;
+    nvclks += 1;
+    nvclks += 1;
+    nvclks += 1;
+    if (mp_enable)
+        mclks+=4;
+    nvclks += 0;
+    pclks += 0;
+    found = 0;
+    vbs = 0;
+    while (found != 1)
+    {
+        fifo->valid = 1;
+        found = 1;
+        mclk_loop = mclks+mclk_extra;
+        us_m = mclk_loop *1000*1000 / mclk_freq;
+        us_n = nvclks*1000*1000 / nvclk_freq;
+        us_p = nvclks*1000*1000 / pclk_freq;
+        if (video_enable)
+        {
+            video_drain_rate = pclk_freq * 2;
+            crtc_drain_rate = pclk_freq * bpp/8;
+            vpagemiss = 2;
+            vpagemiss += 1;
+            crtpagemiss = 2;
+            vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;
+            if (nvclk_freq * 2 > mclk_freq * width)
+                video_fill_us = cbs*1000*1000 / 16 / nvclk_freq ;
+            else
+                video_fill_us = cbs*1000*1000 / (8 * width) / mclk_freq;
+            us_video = vpm_us + us_m + us_n + us_p + video_fill_us;
+            vlwm = us_video * video_drain_rate/(1000*1000);
+            vlwm++;
+            vbs = 128;
+            if (vlwm > 128) vbs = 64;
+            if (vlwm > (256-64)) vbs = 32;
+            if (nvclk_freq * 2 > mclk_freq * width)
+                video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
+            else
+                video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;
+            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
+            us_crt =
+            us_video
+            +video_fill_us
+            +cpm_us
+            +us_m + us_n +us_p
+            ;
+            clwm = us_crt * crtc_drain_rate/(1000*1000);
+            clwm++;
+        }
+        else
+        {
+            crtc_drain_rate = pclk_freq * bpp/8;
+            crtpagemiss = 2;
+            crtpagemiss += 1;
+            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
+            us_crt =  cpm_us + us_m + us_n + us_p ;
+            clwm = us_crt * crtc_drain_rate/(1000*1000);
+            clwm++;
+        }
+        m1 = clwm + cbs - 512;
+        p1 = m1 * pclk_freq / mclk_freq;
+        p1 = p1 * bpp / 8;
+        if ((p1 < m1) && (m1 > 0))
+        {
+            fifo->valid = 0;
+            found = 0;
+            if (mclk_extra ==0)   found = 1;
+            mclk_extra--;
+        }
+        else if (video_enable)
+        {
+            if ((clwm > 511) || (vlwm > 255))
+            {
+                fifo->valid = 0;
+                found = 0;
+                if (mclk_extra ==0)   found = 1;
+                mclk_extra--;
+            }
+        }
+        else
+        {
+            if (clwm > 519)
+            {
+                fifo->valid = 0;
+                found = 0;
+                if (mclk_extra ==0)   found = 1;
+                mclk_extra--;
+            }
+        }
+        craw = clwm;
+        vraw = vlwm;
+        if (clwm < 384) clwm = 384;
+        if (vlwm < 128) vlwm = 128;
+        data = (int)(clwm);
+        fifo->graphics_lwm = data;
+        fifo->graphics_burst_size = 128;
+        data = (int)((vlwm+15));
+        fifo->video_lwm = data;
+        fifo->video_burst_size = vbs;
+    }
+}
+static void nv4UpdateArbitrationSettings
+(
+    unsigned      VClk, 
+    unsigned      pixelDepth, 
+    unsigned     *burst,
+    unsigned     *lwm,
+    RIVA_HW_INST *chip
+)
+{
+    nv4_fifo_info fifo_data;
+    nv4_sim_state sim_data;
+    unsigned int M, N, P, pll, MClk, NVClk, cfg1;
+
+    pll = NV_RD32(&chip->PRAMDAC0[0x00000504/4], 0);
+    M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;
+    MClk  = (N * chip->CrystalFreqKHz / M) >> P;
+    pll = NV_RD32(&chip->PRAMDAC0[0x00000500/4], 0);
+    M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;
+    NVClk  = (N * chip->CrystalFreqKHz / M) >> P;
+    cfg1 = NV_RD32(&chip->PFB[0x00000204/4], 0);
+    sim_data.pix_bpp        = (char)pixelDepth;
+    sim_data.enable_video   = 0;
+    sim_data.enable_mp      = 0;
+    sim_data.memory_width   = (NV_RD32(&chip->PEXTDEV[0x00000000/4], 0) & 0x10) ?
+	128 : 64;
+    sim_data.mem_latency    = (char)cfg1 & 0x0F;
+    sim_data.mem_aligned    = 1;
+    sim_data.mem_page_miss  = (char)(((cfg1 >> 4) &0x0F) + ((cfg1 >> 31) & 0x01));
+    sim_data.gr_during_vid  = 0;
+    sim_data.pclk_khz       = VClk;
+    sim_data.mclk_khz       = MClk;
+    sim_data.nvclk_khz      = NVClk;
+    nv4CalcArbitration(&fifo_data, &sim_data);
+    if (fifo_data.valid)
+    {
+        int  b = fifo_data.graphics_burst_size >> 4;
+        *burst = 0;
+        while (b >>= 1)
+	    (*burst)++;
+        *lwm   = fifo_data.graphics_lwm >> 3;
+    }
+}
+static void nv10CalcArbitration 
+(
+    nv10_fifo_info *fifo,
+    nv10_sim_state *arb
+)
+{
+    int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
+    int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
+    int nvclk_fill, us_extra;
+    int found, mclk_extra, mclk_loop, cbs, m1;
+    int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
+    int us_m, us_m_min, us_n, us_p, video_drain_rate, crtc_drain_rate;
+    int vus_m, vus_n, vus_p;
+    int vpm_us, us_video, vlwm, cpm_us, us_crt,clwm;
+    int clwm_rnd_down;
+    int craw, m2us, us_pipe, us_pipe_min, vus_pipe, p1clk, p2;
+    int pclks_2_top_fifo, min_mclk_extra;
+    int us_min_mclk_extra;
+
+    fifo->valid = 1;
+    pclk_freq = arb->pclk_khz; /* freq in KHz */
+    mclk_freq = arb->mclk_khz;
+    nvclk_freq = arb->nvclk_khz;
+    pagemiss = arb->mem_page_miss;
+    cas = arb->mem_latency;
+    width = arb->memory_width/64;
+    video_enable = arb->enable_video;
+    color_key_enable = arb->gr_during_vid;
+    bpp = arb->pix_bpp;
+    align = arb->mem_aligned;
+    mp_enable = arb->enable_mp;
+    clwm = 0;
+    vlwm = 1024;
+
+    cbs = 512;
+    vbs = 512;
+
+    pclks = 4; /* lwm detect. */
+
+    nvclks = 3; /* lwm -> sync. */
+    nvclks += 2; /* fbi bus cycles (1 req + 1 busy) */
+
+    mclks  = 1;   /* 2 edge sync.  may be very close to edge so just put one. */
+
+    mclks += 1;   /* arb_hp_req */
+    mclks += 5;   /* ap_hp_req   tiling pipeline */
+
+    mclks += 2;    /* tc_req     latency fifo */
+    mclks += 2;    /* fb_cas_n_  memory request to fbio block */
+    mclks += 7;    /* sm_d_rdv   data returned from fbio block */
+
+    /* fb.rd.d.Put_gc   need to accumulate 256 bits for read */
+    if (arb->memory_type == 0)
+      if (arb->memory_width == 64) /* 64 bit bus */
+        mclks += 4;
+      else
+        mclks += 2;
+    else
+      if (arb->memory_width == 64) /* 64 bit bus */
+        mclks += 2;
+      else
+        mclks += 1;
+
+    if ((!video_enable) && (arb->memory_width == 128))
+    {  
+      mclk_extra = (bpp == 32) ? 31 : 42; /* Margin of error */
+      min_mclk_extra = 17;
+    }
+    else
+    {
+      mclk_extra = (bpp == 32) ? 8 : 4; /* Margin of error */
+      /* mclk_extra = 4; */ /* Margin of error */
+      min_mclk_extra = 18;
+    }
+
+    nvclks += 1; /* 2 edge sync.  may be very close to edge so just put one. */
+    nvclks += 1; /* fbi_d_rdv_n */
+    nvclks += 1; /* Fbi_d_rdata */
+    nvclks += 1; /* crtfifo load */
+
+    if(mp_enable)
+      mclks+=4; /* Mp can get in with a burst of 8. */
+    /* Extra clocks determined by heuristics */
+
+    nvclks += 0;
+    pclks += 0;
+    found = 0;
+    while(found != 1) {
+      fifo->valid = 1;
+      found = 1;
+      mclk_loop = mclks+mclk_extra;
+      us_m = mclk_loop *1000*1000 / mclk_freq; /* Mclk latency in us */
+      us_m_min = mclks * 1000*1000 / mclk_freq; /* Minimum Mclk latency in us */
+      us_min_mclk_extra = min_mclk_extra *1000*1000 / mclk_freq;
+      us_n = nvclks*1000*1000 / nvclk_freq;/* nvclk latency in us */
+      us_p = pclks*1000*1000 / pclk_freq;/* nvclk latency in us */
+      us_pipe = us_m + us_n + us_p;
+      us_pipe_min = us_m_min + us_n + us_p;
+      us_extra = 0;
+
+      vus_m = mclk_loop *1000*1000 / mclk_freq; /* Mclk latency in us */
+      vus_n = (4)*1000*1000 / nvclk_freq;/* nvclk latency in us */
+      vus_p = 0*1000*1000 / pclk_freq;/* pclk latency in us */
+      vus_pipe = vus_m + vus_n + vus_p;
+
+      if(video_enable) {
+        video_drain_rate = pclk_freq * 4; /* MB/s */
+        crtc_drain_rate = pclk_freq * bpp/8; /* MB/s */
+
+        vpagemiss = 1; /* self generating page miss */
+        vpagemiss += 1; /* One higher priority before */
+
+        crtpagemiss = 2; /* self generating page miss */
+        if(mp_enable)
+            crtpagemiss += 1; /* if MA0 conflict */
+
+        vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;
+
+        us_video = vpm_us + vus_m; /* Video has separate read return path */
+
+        cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
+        us_crt =
+          us_video  /* Wait for video */
+          +cpm_us /* CRT Page miss */
+          +us_m + us_n +us_p /* other latency */
+          ;
+
+        clwm = us_crt * crtc_drain_rate/(1000*1000);
+        clwm++; /* fixed point <= float_point - 1.  Fixes that */
+      } else {
+        crtc_drain_rate = pclk_freq * bpp/8; /* bpp * pclk/8 */
+
+        crtpagemiss = 1; /* self generating page miss */
+        crtpagemiss += 1; /* MA0 page miss */
+        if(mp_enable)
+            crtpagemiss += 1; /* if MA0 conflict */
+        cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
+        us_crt =  cpm_us + us_m + us_n + us_p ;
+        clwm = us_crt * crtc_drain_rate/(1000*1000);
+        clwm++; /* fixed point <= float_point - 1.  Fixes that */
+
+  /*
+          //
+          // Another concern, only for high pclks so don't do this
+          // with video:
+          // What happens if the latency to fetch the cbs is so large that
+          // fifo empties.  In that case we need to have an alternate clwm value
+          // based off the total burst fetch
+          //
+          us_crt = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
+          us_crt = us_crt + us_m + us_n + us_p + (4 * 1000 * 1000)/mclk_freq;
+          clwm_mt = us_crt * crtc_drain_rate/(1000*1000);
+          clwm_mt ++;
+          if(clwm_mt > clwm)
+              clwm = clwm_mt;
+  */
+          /* Finally, a heuristic check when width == 64 bits */
+          if(width == 1){
+              nvclk_fill = nvclk_freq * 8;
+              if(crtc_drain_rate * 100 >= nvclk_fill * 102)
+                      clwm = 0xfff; /*Large number to fail */
+
+              else if(crtc_drain_rate * 100  >= nvclk_fill * 98) {
+                  clwm = 1024;
+                  cbs = 512;
+                  us_extra = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
+              }
+          }
+      }
+
+
+      /*
+        Overfill check:
+
+        */
+
+      clwm_rnd_down = ((int)clwm/8)*8;
+      if (clwm_rnd_down < clwm)
+          clwm += 8;
+
+      m1 = clwm + cbs -  1024; /* Amount of overfill */
+      m2us = us_pipe_min + us_min_mclk_extra;
+      pclks_2_top_fifo = (1024-clwm)/(8*width);
+
+      /* pclk cycles to drain */
+      p1clk = m2us * pclk_freq/(1000*1000); 
+      p2 = p1clk * bpp / 8; /* bytes drained. */
+
+      if((p2 < m1) && (m1 > 0)) {
+          fifo->valid = 0;
+          found = 0;
+          if(min_mclk_extra == 0)   {
+            if(cbs <= 32) {
+              found = 1; /* Can't adjust anymore! */
+            } else {
+              cbs = cbs/2;  /* reduce the burst size */
+            }
+          } else {
+            min_mclk_extra--;
+          }
+      } else {
+        if (clwm > 1023){ /* Have some margin */
+          fifo->valid = 0;
+          found = 0;
+          if(min_mclk_extra == 0)   
+              found = 1; /* Can't adjust anymore! */
+          else 
+              min_mclk_extra--;
+        }
+      }
+      craw = clwm;
+
+      if(clwm < (1024-cbs+8)) clwm = 1024-cbs+8;
+      data = (int)(clwm);
+      /*  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data ); */
+      fifo->graphics_lwm = data;   fifo->graphics_burst_size = cbs;
+
+      /*  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs ); */
+      fifo->video_lwm = 1024;  fifo->video_burst_size = 512;
+    }
+}
+static void nv10UpdateArbitrationSettings
+(
+    unsigned      VClk, 
+    unsigned      pixelDepth, 
+    unsigned     *burst,
+    unsigned     *lwm,
+    RIVA_HW_INST *chip
+)
+{
+    nv10_fifo_info fifo_data;
+    nv10_sim_state sim_data;
+    unsigned int M, N, P, pll, MClk, NVClk, cfg1;
+
+    pll = NV_RD32(&chip->PRAMDAC0[0x00000504/4], 0);
+    M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;
+    MClk  = (N * chip->CrystalFreqKHz / M) >> P;
+    pll = NV_RD32(&chip->PRAMDAC0[0x00000500/4], 0);
+    M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;
+    NVClk  = (N * chip->CrystalFreqKHz / M) >> P;
+    cfg1 = NV_RD32(&chip->PFB[0x00000204/4], 0);
+    sim_data.pix_bpp        = (char)pixelDepth;
+    sim_data.enable_video   = 0;
+    sim_data.enable_mp      = 0;
+    sim_data.memory_type    = (NV_RD32(&chip->PFB[0x00000200/4], 0) & 0x01) ?
+	1 : 0;
+    sim_data.memory_width   = (NV_RD32(&chip->PEXTDEV[0x00000000/4], 0) & 0x10) ?
+	128 : 64;
+    sim_data.mem_latency    = (char)cfg1 & 0x0F;
+    sim_data.mem_aligned    = 1;
+    sim_data.mem_page_miss  = (char)(((cfg1 >> 4) &0x0F) + ((cfg1 >> 31) & 0x01));
+    sim_data.gr_during_vid  = 0;
+    sim_data.pclk_khz       = VClk;
+    sim_data.mclk_khz       = MClk;
+    sim_data.nvclk_khz      = NVClk;
+    nv10CalcArbitration(&fifo_data, &sim_data);
+    if (fifo_data.valid)
+    {
+        int  b = fifo_data.graphics_burst_size >> 4;
+        *burst = 0;
+        while (b >>= 1)
+	    (*burst)++;
+        *lwm   = fifo_data.graphics_lwm >> 3;
+    }
+}
+
+static void nForceUpdateArbitrationSettings
+(
+    unsigned      VClk,
+    unsigned      pixelDepth,
+    unsigned     *burst,
+    unsigned     *lwm,
+    RIVA_HW_INST *chip
+)
+{
+    nv10_fifo_info fifo_data;
+    nv10_sim_state sim_data;
+    unsigned int M, N, P, pll, MClk, NVClk;
+    unsigned int uMClkPostDiv;
+    struct pci_dev *dev;
+
+    dev = pci_find_slot(0, 3);
+    pci_read_config_dword(dev, 0x6C, &uMClkPostDiv);
+    uMClkPostDiv = (uMClkPostDiv >> 8) & 0xf;
+
+    if(!uMClkPostDiv) uMClkPostDiv = 4;
+    MClk = 400000 / uMClkPostDiv;
+
+    pll = NV_RD32(&chip->PRAMDAC0[0x00000500/4], 0);
+    M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;
+    NVClk  = (N * chip->CrystalFreqKHz / M) >> P;
+    sim_data.pix_bpp        = (char)pixelDepth;
+    sim_data.enable_video   = 0;
+    sim_data.enable_mp      = 0;
+
+    dev = pci_find_slot(0, 1);
+    pci_read_config_dword(dev, 0x7C, &sim_data.memory_type);
+    sim_data.memory_type    = (sim_data.memory_type >> 12) & 1;
+
+    sim_data.memory_width   = 64;
+    sim_data.mem_latency    = 3;
+    sim_data.mem_aligned    = 1;
+    sim_data.mem_page_miss  = 10;
+    sim_data.gr_during_vid  = 0;
+    sim_data.pclk_khz       = VClk;
+    sim_data.mclk_khz       = MClk;
+    sim_data.nvclk_khz      = NVClk;
+    nv10CalcArbitration(&fifo_data, &sim_data);
+    if (fifo_data.valid)
+    {
+        int  b = fifo_data.graphics_burst_size >> 4;
+        *burst = 0;
+        while (b >>= 1)
+	    (*burst)++;
+        *lwm   = fifo_data.graphics_lwm >> 3;
+    }
+}
+
+/****************************************************************************\
+*                                                                            *
+*                          RIVA Mode State Routines                          *
+*                                                                            *
+\****************************************************************************/
+
+/*
+ * Calculate the Video Clock parameters for the PLL.
+ */
+static int CalcVClock
+(
+    int           clockIn,
+    int          *clockOut,
+    int          *mOut,
+    int          *nOut,
+    int          *pOut,
+    RIVA_HW_INST *chip
+)
+{
+    unsigned lowM, highM, highP;
+    unsigned DeltaNew, DeltaOld;
+    unsigned VClk, Freq;
+    unsigned M, N, P;
+    
+    DeltaOld = 0xFFFFFFFF;
+
+    VClk     = (unsigned)clockIn;
+    
+    if (chip->CrystalFreqKHz == 13500)
+    {
+        lowM  = 7;
+        highM = 13 - (chip->Architecture == NV_ARCH_03);
+    }
+    else
+    {
+        lowM  = 8;
+        highM = 14 - (chip->Architecture == NV_ARCH_03);
+    }                      
+
+    highP = 4 - (chip->Architecture == NV_ARCH_03);
+    for (P = 0; P <= highP; P ++)
+    {
+        Freq = VClk << P;
+        if ((Freq >= 128000) && (Freq <= chip->MaxVClockFreqKHz))
+        {
+            for (M = lowM; M <= highM; M++)
+            {
+                N    = (VClk << P) * M / chip->CrystalFreqKHz;
+                if(N <= 255) {
+                Freq = (chip->CrystalFreqKHz * N / M) >> P;
+                if (Freq > VClk)
+                    DeltaNew = Freq - VClk;
+                else
+                    DeltaNew = VClk - Freq;
+                if (DeltaNew < DeltaOld)
+                {
+                    *mOut     = M;
+                    *nOut     = N;
+                    *pOut     = P;
+                    *clockOut = Freq;
+                    DeltaOld  = DeltaNew;
+                }
+            }
+        }
+    }
+    }
+    return (DeltaOld != 0xFFFFFFFF);
+}
+/*
+ * Calculate extended mode parameters (SVGA) and save in a 
+ * mode state structure.
+ */
+static void CalcStateExt
+(
+    RIVA_HW_INST  *chip,
+    RIVA_HW_STATE *state,
+    int            bpp,
+    int            width,
+    int            hDisplaySize,
+    int            height,
+    int            dotClock
+)
+{
+    int pixelDepth, VClk, m, n, p;
+    /*
+     * Save mode parameters.
+     */
+    state->bpp    = bpp;    /* this is not bitsPerPixel, it's 8,15,16,32 */
+    state->width  = width;
+    state->height = height;
+    /*
+     * Extended RIVA registers.
+     */
+    pixelDepth = (bpp + 1)/8;
+    CalcVClock(dotClock, &VClk, &m, &n, &p, chip);
+
+    switch (chip->Architecture)
+    {
+        case NV_ARCH_03:
+            nv3UpdateArbitrationSettings(VClk, 
+                                         pixelDepth * 8, 
+                                        &(state->arbitration0),
+                                        &(state->arbitration1),
+                                         chip);
+            state->cursor0  = 0x00;
+            state->cursor1  = 0x78;
+            state->cursor2  = 0x00000000;
+            state->pllsel   = 0x10010100;
+            state->config   = ((width + 31)/32)
+                            | (((pixelDepth > 2) ? 3 : pixelDepth) << 8)
+                            | 0x1000;
+            state->general  = 0x00100100;
+            state->repaint1 = hDisplaySize < 1280 ? 0x06 : 0x02;
+            break;
+        case NV_ARCH_04:
+            nv4UpdateArbitrationSettings(VClk, 
+                                         pixelDepth * 8, 
+                                        &(state->arbitration0),
+                                        &(state->arbitration1),
+                                         chip);
+            state->cursor0  = 0x00;
+            state->cursor1  = 0xFC;
+            state->cursor2  = 0x00000000;
+            state->pllsel   = 0x10000700;
+            state->config   = 0x00001114;
+            state->general  = bpp == 16 ? 0x00101100 : 0x00100100;
+            state->repaint1 = hDisplaySize < 1280 ? 0x04 : 0x00;
+            break;
+        case NV_ARCH_10:
+        case NV_ARCH_20:
+        case NV_ARCH_30:
+            if((chip->Chipset == NV_CHIP_IGEFORCE2) ||
+               (chip->Chipset == NV_CHIP_0x01F0))
+            {
+                nForceUpdateArbitrationSettings(VClk,
+                                          pixelDepth * 8,
+                                         &(state->arbitration0),
+                                         &(state->arbitration1),
+                                          chip);
+            } else {
+                nv10UpdateArbitrationSettings(VClk, 
+                                          pixelDepth * 8, 
+                                         &(state->arbitration0),
+                                         &(state->arbitration1),
+                                          chip);
+            }
+/*          --- XBOX ---
+            state->cursor0  = 0x80 | (chip->CursorStart >> 17);
+            state->cursor1  = (chip->CursorStart >> 11) << 2;
+            state->cursor2  = chip->CursorStart >> 24;
+*/
+            state->cursor0  = chip->CursorStart;    
+            state->pllsel   = 0x10000700;
+            state->config   = NV_RD32(&chip->PFB[0x00000200/4], 0);
+            state->general  = bpp == 16 ? 0x00101100 : 0x00100100;
+            state->repaint1 = hDisplaySize < 1280 ? 0x04 : 0x00;
+            break;
+    }
+
+     /* Paul Richards: below if block borks things in kernel for some reason */
+     /* Tony: Below is needed to set hardware in DirectColor */
+    if((bpp != 8) && (chip->Architecture != NV_ARCH_03))
+	    state->general |= 0x00000030;
+
+    state->vpll     = (p << 16) | (n << 8) | m;
+    state->repaint0 = (((width/8)*pixelDepth) & 0x700) >> 3;
+    state->pixel    = pixelDepth > 2   ? 3    : pixelDepth;
+    state->pixel    |= 0x80; /* --- XBOX --- */
+    state->offset0  =
+    state->offset1  =
+    state->offset2  =
+    state->offset3  = 0;
+    state->pitch0   =
+    state->pitch1   =
+    state->pitch2   =
+    state->pitch3   = pixelDepth * width;
+}
+/*
+ * Load fixed function state and pre-calculated/stored state.
+ */
+#if 0
+#define LOAD_FIXED_STATE(tbl,dev)                                       \
+    for (i = 0; i < sizeof(tbl##Table##dev)/8; i++)                 \
+        chip->dev[tbl##Table##dev[i][0]] = tbl##Table##dev[i][1]
+#define LOAD_FIXED_STATE_8BPP(tbl,dev)                                  \
+    for (i = 0; i < sizeof(tbl##Table##dev##_8BPP)/8; i++)            \
+        chip->dev[tbl##Table##dev##_8BPP[i][0]] = tbl##Table##dev##_8BPP[i][1]
+#define LOAD_FIXED_STATE_15BPP(tbl,dev)                                 \
+    for (i = 0; i < sizeof(tbl##Table##dev##_15BPP)/8; i++)           \
+        chip->dev[tbl##Table##dev##_15BPP[i][0]] = tbl##Table##dev##_15BPP[i][1]
+#define LOAD_FIXED_STATE_16BPP(tbl,dev)                                 \
+    for (i = 0; i < sizeof(tbl##Table##dev##_16BPP)/8; i++)           \
+        chip->dev[tbl##Table##dev##_16BPP[i][0]] = tbl##Table##dev##_16BPP[i][1]
+#define LOAD_FIXED_STATE_32BPP(tbl,dev)                                 \
+    for (i = 0; i < sizeof(tbl##Table##dev##_32BPP)/8; i++)           \
+        chip->dev[tbl##Table##dev##_32BPP[i][0]] = tbl##Table##dev##_32BPP[i][1]
+#endif
+
+#define LOAD_FIXED_STATE(tbl,dev)                                       \
+    for (i = 0; i < sizeof(tbl##Table##dev)/8; i++)                 \
+        NV_WR32(&chip->dev[tbl##Table##dev[i][0]], 0, tbl##Table##dev[i][1])
+#define LOAD_FIXED_STATE_8BPP(tbl,dev)                                  \
+    for (i = 0; i < sizeof(tbl##Table##dev##_8BPP)/8; i++)            \
+        NV_WR32(&chip->dev[tbl##Table##dev##_8BPP[i][0]], 0, tbl##Table##dev##_8BPP[i][1])
+#define LOAD_FIXED_STATE_15BPP(tbl,dev)                                 \
+    for (i = 0; i < sizeof(tbl##Table##dev##_15BPP)/8; i++)           \
+        NV_WR32(&chip->dev[tbl##Table##dev##_15BPP[i][0]], 0, tbl##Table##dev##_15BPP[i][1])
+#define LOAD_FIXED_STATE_16BPP(tbl,dev)                                 \
+    for (i = 0; i < sizeof(tbl##Table##dev##_16BPP)/8; i++)           \
+        NV_WR32(&chip->dev[tbl##Table##dev##_16BPP[i][0]], 0, tbl##Table##dev##_16BPP[i][1])
+#define LOAD_FIXED_STATE_32BPP(tbl,dev)                                 \
+    for (i = 0; i < sizeof(tbl##Table##dev##_32BPP)/8; i++)           \
+        NV_WR32(&chip->dev[tbl##Table##dev##_32BPP[i][0]], 0, tbl##Table##dev##_32BPP[i][1])
+
+static void UpdateFifoState
+(
+    RIVA_HW_INST  *chip
+)
+{
+    int i;
+
+    switch (chip->Architecture)
+    {
+        case NV_ARCH_04:
+            LOAD_FIXED_STATE(nv4,FIFO);
+            chip->Tri03 = NULL;
+            chip->Tri05 = (RivaTexturedTriangle05 __iomem *)&(chip->FIFO[0x0000E000/4]);
+            break;
+        case NV_ARCH_10:
+            /*
+             * Initialize state for the RivaTriangle3D05 routines.
+             */
+            LOAD_FIXED_STATE(nv10tri05,PGRAPH);
+        case NV_ARCH_20:
+        case NV_ARCH_30:
+            LOAD_FIXED_STATE(nv10,FIFO);
+            chip->Tri03 = NULL;
+            chip->Tri05 = (RivaTexturedTriangle05 __iomem *)&(chip->FIFO[0x0000E000/4]);
+            break;
+    }
+}
+static void LoadStateExt
+(
+    RIVA_HW_INST  *chip,
+    RIVA_HW_STATE *state
+)
+{
+    int i;
+
+    /*
+     * Load HW fixed function state.
+     */
+    LOAD_FIXED_STATE(Riva,PMC);
+    LOAD_FIXED_STATE(Riva,PTIMER);
+    switch (chip->Architecture)
+    {
+        case NV_ARCH_03:
+            /*
+             * Make sure frame buffer config gets set before loading PRAMIN.
+             */
+            NV_WR32(chip->PFB, 0x00000200, state->config);
+            LOAD_FIXED_STATE(nv3,PFIFO);
+            LOAD_FIXED_STATE(nv3,PRAMIN);
+            LOAD_FIXED_STATE(nv3,PGRAPH);
+            switch (state->bpp)
+            {
+                case 15:
+                case 16:
+                    LOAD_FIXED_STATE_15BPP(nv3,PRAMIN);
+                    LOAD_FIXED_STATE_15BPP(nv3,PGRAPH);
+                    chip->Tri03 = (RivaTexturedTriangle03  __iomem *)&(chip->FIFO[0x0000E000/4]);
+                    break;
+                case 24:
+                case 32:
+                    LOAD_FIXED_STATE_32BPP(nv3,PRAMIN);
+                    LOAD_FIXED_STATE_32BPP(nv3,PGRAPH);
+                    chip->Tri03 = NULL;
+                    break;
+                case 8:
+                default:
+                    LOAD_FIXED_STATE_8BPP(nv3,PRAMIN);
+                    LOAD_FIXED_STATE_8BPP(nv3,PGRAPH);
+                    chip->Tri03 = NULL;
+                    break;
+            }
+            for (i = 0x00000; i < 0x00800; i++)
+                NV_WR32(&chip->PRAMIN[0x00000502 + i], 0, (i << 12) | 0x03);
+            NV_WR32(chip->PGRAPH, 0x00000630, state->offset0);
+            NV_WR32(chip->PGRAPH, 0x00000634, state->offset1);
+            NV_WR32(chip->PGRAPH, 0x00000638, state->offset2);
+            NV_WR32(chip->PGRAPH, 0x0000063C, state->offset3);
+            NV_WR32(chip->PGRAPH, 0x00000650, state->pitch0);
+            NV_WR32(chip->PGRAPH, 0x00000654, state->pitch1);
+            NV_WR32(chip->PGRAPH, 0x00000658, state->pitch2);
+            NV_WR32(chip->PGRAPH, 0x0000065C, state->pitch3);
+            break;
+        case NV_ARCH_04:
+            /*
+             * Make sure frame buffer config gets set before loading PRAMIN.
+             */
+            NV_WR32(chip->PFB, 0x00000200, state->config);
+            LOAD_FIXED_STATE(nv4,PFIFO);
+            LOAD_FIXED_STATE(nv4,PRAMIN);
+            LOAD_FIXED_STATE(nv4,PGRAPH);
+            switch (state->bpp)
+            {
+                case 15:
+                    LOAD_FIXED_STATE_15BPP(nv4,PRAMIN);
+                    LOAD_FIXED_STATE_15BPP(nv4,PGRAPH);
+                    chip->Tri03 = (RivaTexturedTriangle03  __iomem *)&(chip->FIFO[0x0000E000/4]);
+                    break;
+                case 16:
+                    LOAD_FIXED_STATE_16BPP(nv4,PRAMIN);
+                    LOAD_FIXED_STATE_16BPP(nv4,PGRAPH);
+                    chip->Tri03 = (RivaTexturedTriangle03  __iomem *)&(chip->FIFO[0x0000E000/4]);
+                    break;
+                case 24:
+                case 32:
+                    LOAD_FIXED_STATE_32BPP(nv4,PRAMIN);
+                    LOAD_FIXED_STATE_32BPP(nv4,PGRAPH);
+                    chip->Tri03 = NULL;
+                    break;
+                case 8:
+                default:
+                    LOAD_FIXED_STATE_8BPP(nv4,PRAMIN);
+                    LOAD_FIXED_STATE_8BPP(nv4,PGRAPH);
+                    chip->Tri03 = NULL;
+                    break;
+            }
+            NV_WR32(chip->PGRAPH, 0x00000640, state->offset0);
+            NV_WR32(chip->PGRAPH, 0x00000644, state->offset1);
+            NV_WR32(chip->PGRAPH, 0x00000648, state->offset2);
+            NV_WR32(chip->PGRAPH, 0x0000064C, state->offset3);
+            NV_WR32(chip->PGRAPH, 0x00000670, state->pitch0);
+            NV_WR32(chip->PGRAPH, 0x00000674, state->pitch1);
+            NV_WR32(chip->PGRAPH, 0x00000678, state->pitch2);
+            NV_WR32(chip->PGRAPH, 0x0000067C, state->pitch3);
+            break;
+        case NV_ARCH_10:
+        case NV_ARCH_30:
+            if(chip->twoHeads) {
+               VGA_WR08(chip->PCIO, 0x03D4, 0x44);
+               VGA_WR08(chip->PCIO, 0x03D5, state->crtcOwner);
+               chip->LockUnlock(chip, 0);
+            }
+
+            LOAD_FIXED_STATE(nv10,PFIFO);
+            LOAD_FIXED_STATE(nv10,PRAMIN);
+            LOAD_FIXED_STATE(nv10,PGRAPH);
+            switch (state->bpp)
+            {
+                case 15:
+                    LOAD_FIXED_STATE_15BPP(nv10,PRAMIN);
+                    LOAD_FIXED_STATE_15BPP(nv10,PGRAPH);
+                    chip->Tri03 = (RivaTexturedTriangle03  __iomem *)&(chip->FIFO[0x0000E000/4]);
+                    break;
+                case 16:
+                    LOAD_FIXED_STATE_16BPP(nv10,PRAMIN);
+                    LOAD_FIXED_STATE_16BPP(nv10,PGRAPH);
+                    chip->Tri03 = (RivaTexturedTriangle03  __iomem *)&(chip->FIFO[0x0000E000/4]);
+                    break;
+                case 24:
+                case 32:
+                    LOAD_FIXED_STATE_32BPP(nv10,PRAMIN);
+                    LOAD_FIXED_STATE_32BPP(nv10,PGRAPH);
+                    chip->Tri03 = NULL;
+                    break;
+                case 8:
+                default:
+                    LOAD_FIXED_STATE_8BPP(nv10,PRAMIN);
+                    LOAD_FIXED_STATE_8BPP(nv10,PGRAPH);
+                    chip->Tri03 = NULL;
+                    break;
+            }
+
+            if(chip->Architecture == NV_ARCH_10) {
+                NV_WR32(chip->PGRAPH, 0x00000640, state->offset0);
+                NV_WR32(chip->PGRAPH, 0x00000644, state->offset1);
+                NV_WR32(chip->PGRAPH, 0x00000648, state->offset2);
+                NV_WR32(chip->PGRAPH, 0x0000064C, state->offset3);
+                NV_WR32(chip->PGRAPH, 0x00000670, state->pitch0);
+                NV_WR32(chip->PGRAPH, 0x00000674, state->pitch1);
+                NV_WR32(chip->PGRAPH, 0x00000678, state->pitch2);
+                NV_WR32(chip->PGRAPH, 0x0000067C, state->pitch3);
+                NV_WR32(chip->PGRAPH, 0x00000680, state->pitch3);
+        } else {
+        NV_WR32(chip->PGRAPH, 0x00000820, state->offset0);
+        NV_WR32(chip->PGRAPH, 0x00000824, state->offset1);
+        NV_WR32(chip->PGRAPH, 0x00000828, state->offset2);
+        NV_WR32(chip->PGRAPH, 0x0000082C, state->offset3);
+        NV_WR32(chip->PGRAPH, 0x00000850, state->pitch0);
+        NV_WR32(chip->PGRAPH, 0x00000854, state->pitch1);
+        NV_WR32(chip->PGRAPH, 0x00000858, state->pitch2);
+        NV_WR32(chip->PGRAPH, 0x0000085C, state->pitch3);
+        NV_WR32(chip->PGRAPH, 0x00000860, state->pitch3);
+        NV_WR32(chip->PGRAPH, 0x00000864, state->pitch3);
+        NV_WR32(chip->PGRAPH, 0x000009A4, NV_RD32(chip->PFB, 0x00000200));
+        NV_WR32(chip->PGRAPH, 0x000009A8, NV_RD32(chip->PFB, 0x00000204));
+        }
+            if(chip->twoHeads) {
+               NV_WR32(chip->PCRTC0, 0x00000860, state->head);
+               NV_WR32(chip->PCRTC0, 0x00002860, state->head2);
+            }
+            NV_WR32(chip->PRAMDAC, 0x00000404, NV_RD32(chip->PRAMDAC, 0x00000404) | (1 << 25));
+
+            NV_WR32(chip->PMC, 0x00008704, 1);
+            NV_WR32(chip->PMC, 0x00008140, 0);
+            NV_WR32(chip->PMC, 0x00008920, 0);
+            NV_WR32(chip->PMC, 0x00008924, 0);
+            NV_WR32(chip->PMC, 0x00008908, 0x01ffffff);
+            NV_WR32(chip->PMC, 0x0000890C, 0x01ffffff);
+            NV_WR32(chip->PMC, 0x00001588, 0);
+
+            NV_WR32(chip->PFB, 0x00000240, 0);
+            NV_WR32(chip->PFB, 0x00000250, 0);
+            NV_WR32(chip->PFB, 0x00000260, 0);
+            NV_WR32(chip->PFB, 0x00000270, 0);
+            NV_WR32(chip->PFB, 0x00000280, 0);
+            NV_WR32(chip->PFB, 0x00000290, 0);
+            NV_WR32(chip->PFB, 0x000002A0, 0);
+            NV_WR32(chip->PFB, 0x000002B0, 0);
+
+            NV_WR32(chip->PGRAPH, 0x00000B00, NV_RD32(chip->PFB, 0x00000240));
+            NV_WR32(chip->PGRAPH, 0x00000B04, NV_RD32(chip->PFB, 0x00000244));
+            NV_WR32(chip->PGRAPH, 0x00000B08, NV_RD32(chip->PFB, 0x00000248));
+            NV_WR32(chip->PGRAPH, 0x00000B0C, NV_RD32(chip->PFB, 0x0000024C));
+            NV_WR32(chip->PGRAPH, 0x00000B10, NV_RD32(chip->PFB, 0x00000250));
+            NV_WR32(chip->PGRAPH, 0x00000B14, NV_RD32(chip->PFB, 0x00000254));
+            NV_WR32(chip->PGRAPH, 0x00000B18, NV_RD32(chip->PFB, 0x00000258));
+            NV_WR32(chip->PGRAPH, 0x00000B1C, NV_RD32(chip->PFB, 0x0000025C));
+            NV_WR32(chip->PGRAPH, 0x00000B20, NV_RD32(chip->PFB, 0x00000260));
+            NV_WR32(chip->PGRAPH, 0x00000B24, NV_RD32(chip->PFB, 0x00000264));
+            NV_WR32(chip->PGRAPH, 0x00000B28, NV_RD32(chip->PFB, 0x00000268));
+            NV_WR32(chip->PGRAPH, 0x00000B2C, NV_RD32(chip->PFB, 0x0000026C));
+            NV_WR32(chip->PGRAPH, 0x00000B30, NV_RD32(chip->PFB, 0x00000270));
+            NV_WR32(chip->PGRAPH, 0x00000B34, NV_RD32(chip->PFB, 0x00000274));
+            NV_WR32(chip->PGRAPH, 0x00000B38, NV_RD32(chip->PFB, 0x00000278));
+            NV_WR32(chip->PGRAPH, 0x00000B3C, NV_RD32(chip->PFB, 0x0000027C));
+            NV_WR32(chip->PGRAPH, 0x00000B40, NV_RD32(chip->PFB, 0x00000280));
+            NV_WR32(chip->PGRAPH, 0x00000B44, NV_RD32(chip->PFB, 0x00000284));
+            NV_WR32(chip->PGRAPH, 0x00000B48, NV_RD32(chip->PFB, 0x00000288));
+            NV_WR32(chip->PGRAPH, 0x00000B4C, NV_RD32(chip->PFB, 0x0000028C));
+            NV_WR32(chip->PGRAPH, 0x00000B50, NV_RD32(chip->PFB, 0x00000290));
+            NV_WR32(chip->PGRAPH, 0x00000B54, NV_RD32(chip->PFB, 0x00000294));
+            NV_WR32(chip->PGRAPH, 0x00000B58, NV_RD32(chip->PFB, 0x00000298));
+            NV_WR32(chip->PGRAPH, 0x00000B5C, NV_RD32(chip->PFB, 0x0000029C));
+            NV_WR32(chip->PGRAPH, 0x00000B60, NV_RD32(chip->PFB, 0x000002A0));
+            NV_WR32(chip->PGRAPH, 0x00000B64, NV_RD32(chip->PFB, 0x000002A4));
+            NV_WR32(chip->PGRAPH, 0x00000B68, NV_RD32(chip->PFB, 0x000002A8));
+            NV_WR32(chip->PGRAPH, 0x00000B6C, NV_RD32(chip->PFB, 0x000002AC));
+            NV_WR32(chip->PGRAPH, 0x00000B70, NV_RD32(chip->PFB, 0x000002B0));
+            NV_WR32(chip->PGRAPH, 0x00000B74, NV_RD32(chip->PFB, 0x000002B4));
+            NV_WR32(chip->PGRAPH, 0x00000B78, NV_RD32(chip->PFB, 0x000002B8));
+            NV_WR32(chip->PGRAPH, 0x00000B7C, NV_RD32(chip->PFB, 0x000002BC));
+            NV_WR32(chip->PGRAPH, 0x00000F40, 0x10000000);
+            NV_WR32(chip->PGRAPH, 0x00000F44, 0x00000000);
+            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000040);
+            NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000008);
+            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000200);
+            for (i = 0; i < (3*16); i++)
+                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
+            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000040);
+            NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
+            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000800);
+            for (i = 0; i < (16*16); i++)
+                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
+            NV_WR32(chip->PGRAPH, 0x00000F40, 0x30000000);
+            NV_WR32(chip->PGRAPH, 0x00000F44, 0x00000004);
+            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00006400);
+            for (i = 0; i < (59*4); i++)
+                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
+            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00006800);
+            for (i = 0; i < (47*4); i++)
+                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
+            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00006C00);
+            for (i = 0; i < (3*4); i++)
+                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
+            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00007000);
+            for (i = 0; i < (19*4); i++)
+                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
+            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00007400);
+            for (i = 0; i < (12*4); i++)
+                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
+            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00007800);
+            for (i = 0; i < (12*4); i++)
+                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
+            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00004400);
+            for (i = 0; i < (8*4); i++)
+                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
+            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000000);
+            for (i = 0; i < 16; i++)
+                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
+            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000040);
+            for (i = 0; i < 4; i++)
+                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
+
+            NV_WR32(chip->PCRTC, 0x00000810, state->cursorConfig);
+
+            if(chip->flatPanel) {
+               if((chip->Chipset & 0x0ff0) == 0x0110) {
+                   NV_WR32(chip->PRAMDAC, 0x0528, state->dither);
+               } else 
+               if((chip->Chipset & 0x0ff0) >= 0x0170) {
+                   NV_WR32(chip->PRAMDAC, 0x083C, state->dither);
+               }
+            
+               VGA_WR08(chip->PCIO, 0x03D4, 0x53);
+               VGA_WR08(chip->PCIO, 0x03D5, 0);
+               VGA_WR08(chip->PCIO, 0x03D4, 0x54);
+               VGA_WR08(chip->PCIO, 0x03D5, 0);
+               VGA_WR08(chip->PCIO, 0x03D4, 0x21);
+               VGA_WR08(chip->PCIO, 0x03D5, 0xfa);
+            }
+
+            VGA_WR08(chip->PCIO, 0x03D4, 0x41);
+            VGA_WR08(chip->PCIO, 0x03D5, state->extra);
+			break;
+         case NV_ARCH_20:
+            if(chip->twoHeads) {
+               VGA_WR08(chip->PCIO, 0x03D4, 0x44);
+               VGA_WR08(chip->PCIO, 0x03D5, state->crtcOwner);
+               chip->LockUnlock(chip, 0);
+            }
+
+            LOAD_FIXED_STATE(nv10,PFIFO);
+            LOAD_FIXED_STATE(nv10,PRAMIN);
+            switch (state->bpp)
+            {
+                case 15:
+                    LOAD_FIXED_STATE_15BPP(nv10,PRAMIN);
+                    LOAD_FIXED_STATE_15BPP(nv10,PGRAPH);
+                    chip->Tri03 = (RivaTexturedTriangle03  *)&(chip->FIFO[0x0000E000/4]);
+                    break;
+                case 16:
+                    LOAD_FIXED_STATE_16BPP(nv10,PRAMIN);
+                    LOAD_FIXED_STATE_16BPP(nv10,PGRAPH);
+                    chip->Tri03 = (RivaTexturedTriangle03  *)&(chip->FIFO[0x0000E000/4]);
+                    break;
+                case 24:
+                case 32:
+                    LOAD_FIXED_STATE_32BPP(nv10,PRAMIN);
+                    LOAD_FIXED_STATE_32BPP(nv10,PGRAPH);
+                    chip->Tri03 = 0L;
+                    break;
+                case 8:
+                default:
+                    LOAD_FIXED_STATE_8BPP(nv10,PRAMIN);
+                    LOAD_FIXED_STATE_8BPP(nv10,PGRAPH);
+                    chip->Tri03 = 0L;
+                    break;
+            }
+
+            if(chip->twoHeads) {
+               chip->PCRTC0[0x00000860/4] = state->head;
+               chip->PCRTC0[0x00002860/4] = state->head2;
+            }
+            chip->PRAMDAC[0x00000404/4] |= (1 << 25);
+
+            chip->PMC[0x00008704/4] = 1;
+            chip->PMC[0x00008140/4] = 0;
+            chip->PMC[0x00008920/4] = 0;
+            chip->PMC[0x00008924/4] = 0;
+            chip->PMC[0x00008908/4] = (chip->RamAmountKBytes*1024)-1;
+            chip->PMC[0x0000890C/4] = (chip->RamAmountKBytes*1024)-1;
+            chip->PMC[0x00001588/4] = 0;
+
+            chip->PFB[0x00000240/4] = 0;
+            chip->PFB[0x00000244/4] = (chip->RamAmountKBytes*1024)-1;
+            chip->PFB[0x00000250/4] = 0;
+            chip->PFB[0x00000254/4] = (chip->RamAmountKBytes*1024)-1;
+            chip->PFB[0x00000260/4] = 0;
+            chip->PFB[0x00000264/4] = (chip->RamAmountKBytes*1024)-1;
+            chip->PFB[0x00000270/4] = 0;
+            chip->PFB[0x00000274/4] = (chip->RamAmountKBytes*1024)-1;
+            chip->PFB[0x00000280/4] = 0;
+            chip->PFB[0x00000284/4] = (chip->RamAmountKBytes*1024)-1;
+            chip->PFB[0x00000290/4] = 0;
+            chip->PFB[0x00000294/4] = (chip->RamAmountKBytes*1024)-1;
+            chip->PFB[0x000002A0/4] = 0;
+            chip->PFB[0x000002A4/4] = (chip->RamAmountKBytes*1024)-1;
+            chip->PFB[0x000002B0/4] = 0;
+            chip->PFB[0x000002B4/4] = (chip->RamAmountKBytes*1024)-1;
+
+            chip->PGRAPH[0x00000080/4] = 0xFFFFFFFF;
+            chip->PGRAPH[0x00000080/4] = 0x00000000;
+
+            chip->PGRAPH[0x00000140/4] = 0x00000000;
+            chip->PGRAPH[0x00000100/4] = 0xFFFFFFFF;
+            chip->PGRAPH[0x00000144/4] = 0x10010100;
+            chip->PGRAPH[0x00000714/4] = 0xFFFFFFFF;
+            chip->PGRAPH[0x00000720/4] = 0x00000001;
+            chip->PGRAPH[0x00000710/4] = chip->PGRAPH[0x00000710/4] & 0x0007ff00;
+       	    chip->PGRAPH[0x00000710/4] = chip->PGRAPH[0x00000710/4] | 0x00020100;
+
+            chip->PGRAPH[0x00000084/4] = 0x00118700;
+            chip->PGRAPH[0x0000008C/4] = 0xF20E0431;
+            chip->PGRAPH[0x00000090/4] = 0x00000000;
+            chip->PGRAPH[0x0000009C/4] = 0x00000040;
+
+            chip->PGRAPH[0x00000880/4] = 0x00080000;
+            chip->PGRAPH[0x00000094/4] = 0x00000005;
+            chip->PGRAPH[0x00000B80/4] = 0x45CAA208; 
+            chip->PGRAPH[0x00000B84/4] = 0x24000000;
+            chip->PGRAPH[0x00000098/4] = 0x00000040;
+            chip->PGRAPH[0x00000750/4] = 0x00E00038;
+            chip->PGRAPH[0x00000754/4] = 0x00000030;
+            chip->PGRAPH[0x00000750/4] = 0x00E10038;
+            chip->PGRAPH[0x00000754/4] = 0x00000030;
+
+		    for(i = 0; i < 32; i++)
+			    chip->PGRAPH[(0x00000900/4)+i] = chip->PFB[(0x00000240/4)+i];
+		
+            chip->PGRAPH[0x000009A4/4] = chip->PFB[0x00000200/4];
+            chip->PGRAPH[0x000009A8/4] = chip->PFB[0x00000204/4];
+            chip->PGRAPH[0x00000750/4] = 0x00EA0000;
+            chip->PGRAPH[0x00000754/4] = chip->PFB[0x00000200/4];
+            chip->PGRAPH[0x00000750/4] = 0x00EA0004;
+            chip->PGRAPH[0x00000754/4] = chip->PFB[0x00000204/4];
+
+            chip->PGRAPH[0x00000820/4] = state->offset0;
+            chip->PGRAPH[0x00000824/4] = state->offset1;
+            chip->PGRAPH[0x00000828/4] = state->offset2;
+            chip->PGRAPH[0x0000082C/4] = state->offset3;
+            chip->PGRAPH[0x00000850/4] = state->pitch0;
+            chip->PGRAPH[0x00000854/4] = state->pitch1;
+            chip->PGRAPH[0x00000858/4] = state->pitch2;
+            chip->PGRAPH[0x0000085C/4] = state->pitch3;
+            chip->PGRAPH[0x00000860/4] = state->pitch3;
+            chip->PGRAPH[0x00000864/4] = state->pitch3;
+          
+            chip->PGRAPH[0x00000B20/4] = 0x00000000;
+            chip->PGRAPH[0x00000B04/4] = 0xFFFFFFFF;
+
+            chip->PCRTC[0x00000810/4] = state->cursorConfig;
+
+            if(chip->flatPanel) {
+               if((chip->Chipset & 0x0ff0) == 0x0110) {
+                   chip->PRAMDAC[0x0528/4] = state->dither;
+               } else 
+               if((chip->Chipset & 0x0ff0) >= 0x0170) {
+                   chip->PRAMDAC[0x083C/4] = state->dither;
+               }
+            
+               VGA_WR08(chip->PCIO, 0x03D4, 0x53);
+               VGA_WR08(chip->PCIO, 0x03D5, 0);
+               VGA_WR08(chip->PCIO, 0x03D4, 0x54);
+               VGA_WR08(chip->PCIO, 0x03D5, 0);
+               VGA_WR08(chip->PCIO, 0x03D4, 0x21);
+               VGA_WR08(chip->PCIO, 0x03D5, 0xfa);
+            }
+
+            VGA_WR08(chip->PCIO, 0x03D4, 0x41);
+            VGA_WR08(chip->PCIO, 0x03D5, state->extra);
+            break;
+    }
+    LOAD_FIXED_STATE(Riva,FIFO);
+    UpdateFifoState(chip);
+    /*
+     * Load HW mode state.
+     */
+    VGA_WR08(chip->PCIO, 0x03D4, 0x19);
+    VGA_WR08(chip->PCIO, 0x03D5, state->repaint0);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x1A);
+    VGA_WR08(chip->PCIO, 0x03D5, state->repaint1);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x25);
+    VGA_WR08(chip->PCIO, 0x03D5, state->screen);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x28);
+    VGA_WR08(chip->PCIO, 0x03D5, state->pixel);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x2D);
+    VGA_WR08(chip->PCIO, 0x03D5, state->horiz);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x1B);
+    VGA_WR08(chip->PCIO, 0x03D5, state->arbitration0);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x20);
+    VGA_WR08(chip->PCIO, 0x03D5, state->arbitration1);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x30);
+    VGA_WR08(chip->PCIO, 0x03D5, state->cursor0);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x31);
+    VGA_WR08(chip->PCIO, 0x03D5, state->cursor1);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x2F);
+    VGA_WR08(chip->PCIO, 0x03D5, state->cursor2);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x39);
+    VGA_WR08(chip->PCIO, 0x03D5, state->interlace);
+
+    if(!chip->flatPanel) {
+       NV_WR32(chip->PRAMDAC0, 0x00000508, state->vpll);
+       NV_WR32(chip->PRAMDAC0, 0x0000050C, state->pllsel);
+       if(chip->twoHeads)
+          NV_WR32(chip->PRAMDAC0, 0x00000520, state->vpll2);
+    }  else {
+       NV_WR32(chip->PRAMDAC, 0x00000848 , state->scale);
+    }  
+    NV_WR32(chip->PRAMDAC, 0x00000600 , state->general);
+    /* -- XBOX --- */    
+    NV_WR32(chip->PCRTC, 0x00000800, state->fb_start);
+    NV_WR32(chip->PRAMDAC, 0x00000800, state->vend);
+    NV_WR32(chip->PRAMDAC, 0x00000804, state->vtotal);
+    NV_WR32(chip->PRAMDAC, 0x00000808, state->vcrtc);
+    NV_WR32(chip->PRAMDAC, 0x0000080c, state->vsyncstart);
+    NV_WR32(chip->PRAMDAC, 0x00000810, state->vsyncend);
+    NV_WR32(chip->PRAMDAC, 0x00000814, state->vvalidstart);
+    NV_WR32(chip->PRAMDAC, 0x00000818, state->vvalidend);
+    NV_WR32(chip->PRAMDAC, 0x00000820, state->hend);
+    NV_WR32(chip->PRAMDAC, 0x00000824, state->htotal);
+    NV_WR32(chip->PRAMDAC, 0x00000828, state->hcrtc);
+    NV_WR32(chip->PRAMDAC, 0x0000082c, state->hsyncstart);
+    NV_WR32(chip->PRAMDAC, 0x00000830, state->hsyncend);
+    NV_WR32(chip->PRAMDAC, 0x00000834, state->hvalidstart);
+    NV_WR32(chip->PRAMDAC, 0x00000838, state->hvalidend);
+    NV_WR32(chip->PRAMDAC, 0x00000840, state->checksum );
+
+    /*
+     * Turn off VBlank enable and reset.
+     */
+    NV_WR32(chip->PCRTC, 0x00000140, 0);
+    NV_WR32(chip->PCRTC, 0x00000100, chip->VBlankBit);
+    /*
+     * Set interrupt enable.
+     */    
+    NV_WR32(chip->PMC, 0x00000140, chip->EnableIRQ & 0x01);
+    /*
+     * Set current state pointer.
+     */
+    chip->CurrentState = state;
+    /*
+     * Reset FIFO free and empty counts.
+     */
+    chip->FifoFreeCount  = 0;
+    /* Free count from first subchannel */
+    chip->FifoEmptyCount = NV_RD32(&chip->Rop->FifoFree, 0);
+}
+static void UnloadStateExt
+(
+    RIVA_HW_INST  *chip,
+    RIVA_HW_STATE *state
+)
+{
+    /*
+     * Save current HW state.
+     */
+    VGA_WR08(chip->PCIO, 0x03D4, 0x19);
+    state->repaint0     = VGA_RD08(chip->PCIO, 0x03D5);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x1A);
+    state->repaint1     = VGA_RD08(chip->PCIO, 0x03D5);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x25);
+    state->screen       = VGA_RD08(chip->PCIO, 0x03D5);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x28);
+    state->pixel        = VGA_RD08(chip->PCIO, 0x03D5);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x2D);
+    state->horiz        = VGA_RD08(chip->PCIO, 0x03D5);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x1B);
+    state->arbitration0 = VGA_RD08(chip->PCIO, 0x03D5);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x20);
+    state->arbitration1 = VGA_RD08(chip->PCIO, 0x03D5);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x30);
+    state->cursor0      = VGA_RD08(chip->PCIO, 0x03D5);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x31);
+    state->cursor1      = VGA_RD08(chip->PCIO, 0x03D5);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x2F);
+    state->cursor2      = VGA_RD08(chip->PCIO, 0x03D5);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x39);
+    state->interlace    = VGA_RD08(chip->PCIO, 0x03D5);
+    state->vpll         = NV_RD32(chip->PRAMDAC0, 0x00000508);
+    state->vpll2        = NV_RD32(chip->PRAMDAC0, 0x00000520);
+    state->pllsel       = NV_RD32(chip->PRAMDAC0, 0x0000050C);
+    state->general      = NV_RD32(chip->PRAMDAC, 0x00000600);
+    state->scale        = NV_RD32(chip->PRAMDAC, 0x00000848);
+    state->config       = NV_RD32(chip->PFB, 0x00000200);
+    switch (chip->Architecture)
+    {
+        case NV_ARCH_03:
+            state->offset0  = NV_RD32(chip->PGRAPH, 0x00000630);
+            state->offset1  = NV_RD32(chip->PGRAPH, 0x00000634);
+            state->offset2  = NV_RD32(chip->PGRAPH, 0x00000638);
+            state->offset3  = NV_RD32(chip->PGRAPH, 0x0000063C);
+            state->pitch0   = NV_RD32(chip->PGRAPH, 0x00000650);
+            state->pitch1   = NV_RD32(chip->PGRAPH, 0x00000654);
+            state->pitch2   = NV_RD32(chip->PGRAPH, 0x00000658);
+            state->pitch3   = NV_RD32(chip->PGRAPH, 0x0000065C);
+            break;
+        case NV_ARCH_04:
+            state->offset0  = NV_RD32(chip->PGRAPH, 0x00000640);
+            state->offset1  = NV_RD32(chip->PGRAPH, 0x00000644);
+            state->offset2  = NV_RD32(chip->PGRAPH, 0x00000648);
+            state->offset3  = NV_RD32(chip->PGRAPH, 0x0000064C);
+            state->pitch0   = NV_RD32(chip->PGRAPH, 0x00000670);
+            state->pitch1   = NV_RD32(chip->PGRAPH, 0x00000674);
+            state->pitch2   = NV_RD32(chip->PGRAPH, 0x00000678);
+            state->pitch3   = NV_RD32(chip->PGRAPH, 0x0000067C);
+            break;
+        case NV_ARCH_10:
+        case NV_ARCH_20:
+        case NV_ARCH_30:
+            if (chip->Architecture == NV_ARCH_10) {
+                state->offset0  = NV_RD32(chip->PGRAPH, 0x00000640);
+                state->offset1  = NV_RD32(chip->PGRAPH, 0x00000644);
+                state->offset2  = NV_RD32(chip->PGRAPH, 0x00000648);
+                state->offset3  = NV_RD32(chip->PGRAPH, 0x0000064C);
+                state->pitch0   = NV_RD32(chip->PGRAPH, 0x00000670);
+                state->pitch1   = NV_RD32(chip->PGRAPH, 0x00000674);
+                state->pitch2   = NV_RD32(chip->PGRAPH, 0x00000678);
+                state->pitch3   = NV_RD32(chip->PGRAPH, 0x0000067C);
+            } else {
+                state->offset0  = NV_RD32(chip->PGRAPH, 0x00000820);
+                state->offset1  = NV_RD32(chip->PGRAPH, 0x00000824);
+                state->offset2  = NV_RD32(chip->PGRAPH, 0x00000828);
+                state->offset3  = NV_RD32(chip->PGRAPH, 0x0000082C);
+                state->pitch0   = NV_RD32(chip->PGRAPH, 0x00000850);
+                state->pitch1   = NV_RD32(chip->PGRAPH, 0x00000854);
+                state->pitch2   = NV_RD32(chip->PGRAPH, 0x00000858);
+                state->pitch3   = NV_RD32(chip->PGRAPH, 0x0000085C);
+            }
+            if(chip->twoHeads) {
+               state->head     = NV_RD32(chip->PCRTC0, 0x00000860);
+               state->head2    = NV_RD32(chip->PCRTC0, 0x00002860);
+               VGA_WR08(chip->PCIO, 0x03D4, 0x44);
+               state->crtcOwner = VGA_RD08(chip->PCIO, 0x03D5);
+            }
+            VGA_WR08(chip->PCIO, 0x03D4, 0x41);
+            state->extra = VGA_RD08(chip->PCIO, 0x03D5);
+            state->cursorConfig = NV_RD32(chip->PCRTC, 0x00000810);
+
+            if((chip->Chipset & 0x0ff0) == 0x0110) {
+                state->dither = NV_RD32(chip->PRAMDAC, 0x0528);
+            } else 
+            if((chip->Chipset & 0x0ff0) >= 0x0170) {
+                state->dither = NV_RD32(chip->PRAMDAC, 0x083C);
+            }
+            /* -- XBOX --- */            
+            state->fb_start    = NV_RD32(chip->PCRTC, 0x00000800);
+            state->cursor0     = NV_RD32(chip->PCRTC, 0x0000080c);
+            state->vend        = NV_RD32(chip->PRAMDAC, 0x00000800);
+            state->vtotal      = NV_RD32(chip->PRAMDAC, 0x00000804);
+            state->vcrtc       = NV_RD32(chip->PRAMDAC, 0x00000808);
+            state->vsyncstart  = NV_RD32(chip->PRAMDAC, 0x0000080c);
+            state->vsyncend    = NV_RD32(chip->PRAMDAC, 0x00000810);
+            state->vvalidstart = NV_RD32(chip->PRAMDAC, 0x00000814);
+            state->vvalidend   = NV_RD32(chip->PRAMDAC, 0x00000818);
+            state->hend        = NV_RD32(chip->PRAMDAC, 0x00000820);
+            state->htotal      = NV_RD32(chip->PRAMDAC, 0x00000824);
+            state->hcrtc       = NV_RD32(chip->PRAMDAC, 0x00000828);
+            state->hsyncstart  = NV_RD32(chip->PRAMDAC, 0x0000082c);
+            state->hsyncend    = NV_RD32(chip->PRAMDAC, 0x00000830);
+            state->hvalidstart = NV_RD32(chip->PRAMDAC, 0x00000834);
+            state->hvalidend   = NV_RD32(chip->PRAMDAC, 0x00000838);
+            state->checksum    = NV_RD32(chip->PRAMDAC, 0x00000840);	    
+            break;
+    }
+}
+static void SetStartAddress
+(
+    RIVA_HW_INST *chip,
+    unsigned      start
+)
+{
+    NV_WR32(chip->PCRTC, 0x800, start);
+}
+
+static void SetStartAddress3
+(
+    RIVA_HW_INST *chip,
+    unsigned      start
+)
+{
+    int offset = start >> 2;
+    int pan    = (start & 3) << 1;
+    unsigned char tmp;
+
+    /*
+     * Unlock extended registers.
+     */
+    chip->LockUnlock(chip, 0);
+    /*
+     * Set start address.
+     */
+    VGA_WR08(chip->PCIO, 0x3D4, 0x0D); VGA_WR08(chip->PCIO, 0x3D5, offset);
+    offset >>= 8;
+    VGA_WR08(chip->PCIO, 0x3D4, 0x0C); VGA_WR08(chip->PCIO, 0x3D5, offset);
+    offset >>= 8;
+    VGA_WR08(chip->PCIO, 0x3D4, 0x19); tmp = VGA_RD08(chip->PCIO, 0x3D5);
+    VGA_WR08(chip->PCIO, 0x3D5, (offset & 0x01F) | (tmp & ~0x1F));
+    VGA_WR08(chip->PCIO, 0x3D4, 0x2D); tmp = VGA_RD08(chip->PCIO, 0x3D5);
+    VGA_WR08(chip->PCIO, 0x3D5, (offset & 0x60) | (tmp & ~0x60));
+    /*
+     * 4 pixel pan register.
+     */
+    offset = VGA_RD08(chip->PCIO, chip->IO + 0x0A);
+    VGA_WR08(chip->PCIO, 0x3C0, 0x13);
+    VGA_WR08(chip->PCIO, 0x3C0, pan);
+}
+static void nv3SetSurfaces2D
+(
+    RIVA_HW_INST *chip,
+    unsigned     surf0,
+    unsigned     surf1
+)
+{
+    RivaSurface __iomem *Surface =
+	(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);
+
+    RIVA_FIFO_FREE(*chip,Tri03,5);
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000003);
+    NV_WR32(&Surface->Offset, 0, surf0);
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000004);
+    NV_WR32(&Surface->Offset, 0, surf1);
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000013);
+}
+static void nv4SetSurfaces2D
+(
+    RIVA_HW_INST *chip,
+    unsigned     surf0,
+    unsigned     surf1
+)
+{
+    RivaSurface __iomem *Surface =
+	(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);
+
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000003);
+    NV_WR32(&Surface->Offset, 0, surf0);
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000004);
+    NV_WR32(&Surface->Offset, 0, surf1);
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);
+}
+static void nv10SetSurfaces2D
+(
+    RIVA_HW_INST *chip,
+    unsigned     surf0,
+    unsigned     surf1
+)
+{
+    RivaSurface __iomem *Surface =
+	(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);
+
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000003);
+    NV_WR32(&Surface->Offset, 0, surf0);
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000004);
+    NV_WR32(&Surface->Offset, 0, surf1);
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);
+}
+static void nv3SetSurfaces3D
+(
+    RIVA_HW_INST *chip,
+    unsigned     surf0,
+    unsigned     surf1
+)
+{
+    RivaSurface __iomem *Surface =
+	(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);
+
+    RIVA_FIFO_FREE(*chip,Tri03,5);
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000005);
+    NV_WR32(&Surface->Offset, 0, surf0);
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000006);
+    NV_WR32(&Surface->Offset, 0, surf1);
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000013);
+}
+static void nv4SetSurfaces3D
+(
+    RIVA_HW_INST *chip,
+    unsigned     surf0,
+    unsigned     surf1
+)
+{
+    RivaSurface __iomem *Surface =
+	(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);
+
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000005);
+    NV_WR32(&Surface->Offset, 0, surf0);
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000006);
+    NV_WR32(&Surface->Offset, 0, surf1);
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);
+}
+static void nv10SetSurfaces3D
+(
+    RIVA_HW_INST *chip,
+    unsigned     surf0,
+    unsigned     surf1
+)
+{
+    RivaSurface3D __iomem *Surfaces3D =
+	(RivaSurface3D __iomem *)&(chip->FIFO[0x0000E000/4]);
+
+    RIVA_FIFO_FREE(*chip,Tri03,4);
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000007);
+    NV_WR32(&Surfaces3D->RenderBufferOffset, 0, surf0);
+    NV_WR32(&Surfaces3D->ZBufferOffset, 0, surf1);
+    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);
+}
+
+/****************************************************************************\
+*                                                                            *
+*                      Probe RIVA Chip Configuration                         *
+*                                                                            *
+\****************************************************************************/
+
+static void nv3GetConfig
+(
+    RIVA_HW_INST *chip
+)
+{
+    /*
+     * Fill in chip configuration.
+     */
+    if (NV_RD32(&chip->PFB[0x00000000/4], 0) & 0x00000020)
+    {
+        if (((NV_RD32(chip->PMC, 0x00000000) & 0xF0) == 0x20)
+         && ((NV_RD32(chip->PMC, 0x00000000) & 0x0F) >= 0x02))
+        {        
+            /*
+             * SDRAM 128 ZX.
+             */
+            chip->RamBandwidthKBytesPerSec = 800000;
+            switch (NV_RD32(chip->PFB, 0x00000000) & 0x03)
+            {
+                case 2:
+                    chip->RamAmountKBytes = 1024 * 4;
+                    break;
+                case 1:
+                    chip->RamAmountKBytes = 1024 * 2;
+                    break;
+                default:
+                    chip->RamAmountKBytes = 1024 * 8;
+                    break;
+            }
+        }            
+        else            
+        {
+            chip->RamBandwidthKBytesPerSec = 1000000;
+            chip->RamAmountKBytes          = 1024 * 8;
+        }            
+    }
+    else
+    {
+        /*
+         * SGRAM 128.
+         */
+        chip->RamBandwidthKBytesPerSec = 1000000;
+        switch (NV_RD32(chip->PFB, 0x00000000) & 0x00000003)
+        {
+            case 0:
+                chip->RamAmountKBytes = 1024 * 8;
+                break;
+            case 2:
+                chip->RamAmountKBytes = 1024 * 4;
+                break;
+            default:
+                chip->RamAmountKBytes = 1024 * 2;
+                break;
+        }
+    }        
+    chip->CrystalFreqKHz   = (NV_RD32(chip->PEXTDEV, 0x00000000) & 0x00000040) ? 14318 : 13500;
+    chip->CURSOR           = &(chip->PRAMIN[0x00008000/4 - 0x0800/4]);
+    chip->VBlankBit        = 0x00000100;
+    chip->MaxVClockFreqKHz = 256000;
+    /*
+     * Set chip functions.
+     */
+    chip->Busy            = nv3Busy;
+    chip->ShowHideCursor  = ShowHideCursor;
+    chip->CalcStateExt    = CalcStateExt;
+    chip->LoadStateExt    = LoadStateExt;
+    chip->UnloadStateExt  = UnloadStateExt;
+    chip->SetStartAddress = SetStartAddress3;
+    chip->SetSurfaces2D   = nv3SetSurfaces2D;
+    chip->SetSurfaces3D   = nv3SetSurfaces3D;
+    chip->LockUnlock      = nv3LockUnlock;
+}
+static void nv4GetConfig
+(
+    RIVA_HW_INST *chip
+)
+{
+    /*
+     * Fill in chip configuration.
+     */
+    if (NV_RD32(chip->PFB, 0x00000000) & 0x00000100)
+    {
+        chip->RamAmountKBytes = ((NV_RD32(chip->PFB, 0x00000000) >> 12) & 0x0F) * 1024 * 2
+                              + 1024 * 2;
+    }
+    else
+    {
+        switch (NV_RD32(chip->PFB, 0x00000000) & 0x00000003)
+        {
+            case 0:
+                chip->RamAmountKBytes = 1024 * 32;
+                break;
+            case 1:
+                chip->RamAmountKBytes = 1024 * 4;
+                break;
+            case 2:
+                chip->RamAmountKBytes = 1024 * 8;
+                break;
+            case 3:
+            default:
+                chip->RamAmountKBytes = 1024 * 16;
+                break;
+        }
+    }
+    switch ((NV_RD32(chip->PFB, 0x00000000) >> 3) & 0x00000003)
+    {
+        case 3:
+            chip->RamBandwidthKBytesPerSec = 800000;
+            break;
+        default:
+            chip->RamBandwidthKBytesPerSec = 1000000;
+            break;
+    }
+    chip->CrystalFreqKHz   = (NV_RD32(chip->PEXTDEV, 0x00000000) & 0x00000040) ? 14318 : 13500;
+    chip->CURSOR           = &(chip->PRAMIN[0x00010000/4 - 0x0800/4]);
+    chip->VBlankBit        = 0x00000001;
+    chip->MaxVClockFreqKHz = 350000;
+    /*
+     * Set chip functions.
+     */
+    chip->Busy            = nv4Busy;
+    chip->ShowHideCursor  = ShowHideCursor;
+    chip->CalcStateExt    = CalcStateExt;
+    chip->LoadStateExt    = LoadStateExt;
+    chip->UnloadStateExt  = UnloadStateExt;
+    chip->SetStartAddress = SetStartAddress;
+    chip->SetSurfaces2D   = nv4SetSurfaces2D;
+    chip->SetSurfaces3D   = nv4SetSurfaces3D;
+    chip->LockUnlock      = nv4LockUnlock;
+}
+static void nv10GetConfig
+(
+    RIVA_HW_INST *chip,
+    unsigned int chipset
+)
+{
+    struct pci_dev* dev;
+    int amt;
+
+#ifdef __BIG_ENDIAN
+    /* turn on big endian register access */
+    if(!(NV_RD32(chip->PMC, 0x00000004) & 0x01000001))
+    	NV_WR32(chip->PMC, 0x00000004, 0x01000001);
+#endif
+
+    /*
+     * Fill in chip configuration.
+     */
+    if(chipset == NV_CHIP_IGEFORCE2) {
+        dev = pci_find_slot(0, 1);
+        pci_read_config_dword(dev, 0x7C, &amt);
+        chip->RamAmountKBytes = (((amt >> 6) & 31) + 1) * 1024;
+    } else if(chipset == NV_CHIP_0x01F0) {
+        dev = pci_find_slot(0, 1);
+        pci_read_config_dword(dev, 0x84, &amt);
+        chip->RamAmountKBytes = (((amt >> 4) & 127) + 1) * 1024;
+    } else {
+        switch ((NV_RD32(chip->PFB, 0x0000020C) >> 20) & 0x000000FF)
+        {
+            case 0x02:
+                chip->RamAmountKBytes = 1024 * 2;
+                break;
+            case 0x04:
+                chip->RamAmountKBytes = 1024 * 4;
+                break;
+            case 0x08:
+                chip->RamAmountKBytes = 1024 * 8;
+                break;
+            case 0x10:
+                chip->RamAmountKBytes = 1024 * 16;
+                break;
+            case 0x20:
+                chip->RamAmountKBytes = 1024 * 32;
+                break;
+            case 0x40:
+                chip->RamAmountKBytes = 1024 * 64;
+                break;
+            case 0x80:
+                chip->RamAmountKBytes = 1024 * 128;
+                break;
+            default:
+                chip->RamAmountKBytes = 1024 * 16;
+                break;
+        }
+    }
+    switch ((NV_RD32(chip->PFB, 0x00000000) >> 3) & 0x00000003)
+    {
+        case 3:
+            chip->RamBandwidthKBytesPerSec = 800000;
+            break;
+        default:
+            chip->RamBandwidthKBytesPerSec = 1000000;
+            break;
+    }
+    chip->CrystalFreqKHz = (NV_RD32(chip->PEXTDEV, 0x0000) & (1 << 6)) ?
+	14318 : 13500;
+
+    switch (chipset & 0x0ff0) {
+    case 0x0170:
+    case 0x0180:
+    case 0x01F0:
+    case 0x0250:
+    case 0x0280:
+    case 0x0300:
+    case 0x0310:
+    case 0x0320:
+    case 0x0330:
+    case 0x0340:
+       if(NV_RD32(chip->PEXTDEV, 0x0000) & (1 << 22))
+           chip->CrystalFreqKHz = 27000;
+       break;
+    default:
+       break;
+    }
+
+    chip->CursorStart      = (chip->RamAmountKBytes - 2) * 1024;
+    chip->CURSOR           = NULL;  /* can't set this here */
+    chip->VBlankBit        = 0x00000001;
+    chip->MaxVClockFreqKHz = 350000;
+    /*
+     * Set chip functions.
+     */
+    chip->Busy            = nv10Busy;
+    /* -- XBOX --- */
+    chip->ShowHideCursor  = nv10ShowHideCursor;
+    chip->CalcStateExt    = CalcStateExt;
+    chip->LoadStateExt    = LoadStateExt;
+    chip->UnloadStateExt  = UnloadStateExt;
+    chip->SetStartAddress = SetStartAddress;
+    chip->SetSurfaces2D   = nv10SetSurfaces2D;
+    chip->SetSurfaces3D   = nv10SetSurfaces3D;
+    chip->LockUnlock      = nv4LockUnlock;
+
+    switch(chipset & 0x0ff0) {
+    case 0x0110:
+    case 0x0170:
+    case 0x0180:
+    case 0x01F0:
+    case 0x0250:
+    case 0x0280:
+    case 0x0300:
+    case 0x0310:
+    case 0x0320:
+    case 0x0330:
+    case 0x0340:
+        chip->twoHeads = TRUE;
+        break;
+    default:
+        chip->twoHeads = FALSE;
+        break;
+    }
+}
+int RivaGetConfig
+(
+    RIVA_HW_INST *chip,
+    unsigned int chipset
+)
+{
+    /*
+     * Save this so future SW know whats it's dealing with.
+     */
+    chip->Version = RIVA_SW_VERSION;
+    /*
+     * Chip specific configuration.
+     */
+    switch (chip->Architecture)
+    {
+        case NV_ARCH_03:
+            nv3GetConfig(chip);
+            break;
+        case NV_ARCH_04:
+            nv4GetConfig(chip);
+            break;
+        case NV_ARCH_10:
+        case NV_ARCH_20:
+        case NV_ARCH_30:
+            nv10GetConfig(chip, chipset);
+            break;
+        default:
+            return (-1);
+    }
+    chip->Chipset = chipset;
+    /*
+     * Fill in FIFO pointers.
+     */
+    chip->Rop    = (RivaRop __iomem         *)&(chip->FIFO[0x00000000/4]);
+    chip->Clip   = (RivaClip __iomem        *)&(chip->FIFO[0x00002000/4]);
+    chip->Patt   = (RivaPattern __iomem     *)&(chip->FIFO[0x00004000/4]);
+    chip->Pixmap = (RivaPixmap __iomem      *)&(chip->FIFO[0x00006000/4]);
+    chip->Blt    = (RivaScreenBlt __iomem   *)&(chip->FIFO[0x00008000/4]);
+    chip->Bitmap = (RivaBitmap __iomem      *)&(chip->FIFO[0x0000A000/4]);
+    chip->Line   = (RivaLine __iomem        *)&(chip->FIFO[0x0000C000/4]);
+    chip->Tri03  = (RivaTexturedTriangle03 __iomem *)&(chip->FIFO[0x0000E000/4]);
+    return (0);
+}
+
diff -uprN a/drivers/video/xbox/riva_hw.h b/drivers/video/xbox/riva_hw.h
--- a/drivers/video/xbox/riva_hw.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/riva_hw.h	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,567 @@
+/***************************************************************************\
+|*                                                                           *|
+|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
+|*                                                                           *|
+|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
+|*     international laws.  Users and possessors of this source code are     *|
+|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
+|*     use this code in individual and commercial software.                  *|
+|*                                                                           *|
+|*     Any use of this source code must include,  in the user documenta-     *|
+|*     tion and  internal comments to the code,  notices to the end user     *|
+|*     as follows:                                                           *|
+|*                                                                           *|
+|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
+|*                                                                           *|
+|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
+|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
+|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
+|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
+|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
+|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
+|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
+|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
+|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
+|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
+|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
+|*                                                                           *|
+|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
+|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
+|*     consisting  of "commercial  computer  software"  and  "commercial     *|
+|*     computer  software  documentation,"  as such  terms  are  used in     *|
+|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
+|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
+|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
+|*     all U.S. Government End Users  acquire the source code  with only     *|
+|*     those rights set forth herein.                                        *|
+|*                                                                           *|
+\***************************************************************************/
+
+/*
+ * GPL licensing note -- nVidia is allowing a liberal interpretation of
+ * the documentation restriction above, to merely say that this nVidia's
+ * copyright and disclaimer should be included with all code derived
+ * from this source.  -- Jeff Garzik <jgarzik@pobox.com>, 01/Nov/99 
+ */
+
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/riva_hw.h,v 1.21 2002/10/14 18:22:46 mvojkovi Exp $ */
+#ifndef __RIVA_HW_H__
+#define __RIVA_HW_H__
+#define RIVA_SW_VERSION 0x00010003
+
+#ifndef Bool
+typedef int Bool;
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+#ifndef NULL
+#define NULL 0
+#endif
+
+/*
+ * Typedefs to force certain sized values.
+ */
+typedef unsigned char  U008;
+typedef unsigned short U016;
+typedef unsigned int   U032;
+
+/*
+ * HW access macros.
+ */
+#include <asm/io.h>
+
+#define NV_WR08(p,i,d)  (__raw_writeb((d), (void __iomem *)(p) + (i)))
+#define NV_RD08(p,i)    (__raw_readb((void __iomem *)(p) + (i)))
+#define NV_WR16(p,i,d)  (__raw_writew((d), (void __iomem *)(p) + (i)))
+#define NV_RD16(p,i)    (__raw_readw((void __iomem *)(p) + (i)))
+#define NV_WR32(p,i,d)  (__raw_writel((d), (void __iomem *)(p) + (i)))
+#define NV_RD32(p,i)    (__raw_readl((void __iomem *)(p) + (i)))
+
+#define VGA_WR08(p,i,d) (writeb((d), (void __iomem *)(p) + (i)))
+#define VGA_RD08(p,i)   (readb((void __iomem *)(p) + (i)))
+
+/*
+ * Define different architectures.
+ */
+#define NV_ARCH_03  0x03
+#define NV_ARCH_04  0x04
+#define NV_ARCH_10  0x10
+#define NV_ARCH_20  0x20
+#define NV_ARCH_30  0x30
+#define NV_ARCH_40  0x40
+
+/***************************************************************************\
+*                                                                           *
+*                             FIFO registers.                               *
+*                                                                           *
+\***************************************************************************/
+
+/*
+ * Raster OPeration. Windows style ROP3.
+ */
+typedef volatile struct
+{
+    U032 reserved00[4];
+#ifdef __BIG_ENDIAN
+    U032 FifoFree;
+#else
+    U016 FifoFree;
+    U016 Nop;
+#endif
+    U032 reserved01[0x0BB];
+    U032 Rop3;
+} RivaRop;
+/*
+ * 8X8 Monochrome pattern.
+ */
+typedef volatile struct
+{
+    U032 reserved00[4];
+#ifdef __BIG_ENDIAN
+    U032 FifoFree;
+#else
+    U016 FifoFree;
+    U016 Nop;
+#endif
+    U032 reserved01[0x0BD];
+    U032 Shape;
+    U032 reserved03[0x001];
+    U032 Color0;
+    U032 Color1;
+    U032 Monochrome[2];
+} RivaPattern;
+/*
+ * Scissor clip rectangle.
+ */
+typedef volatile struct
+{
+    U032 reserved00[4];
+#ifdef __BIG_ENDIAN
+    U032 FifoFree;
+#else
+    U016 FifoFree;
+    U016 Nop;
+#endif
+    U032 reserved01[0x0BB];
+    U032 TopLeft;
+    U032 WidthHeight;
+} RivaClip;
+/*
+ * 2D filled rectangle.
+ */
+typedef volatile struct
+{
+    U032 reserved00[4];
+#ifdef __BIG_ENDIAN
+    U032 FifoFree;
+#else
+    U016 FifoFree;
+    U016 Nop[1];
+#endif
+    U032 reserved01[0x0BC];
+    U032 Color;
+    U032 reserved03[0x03E];
+    U032 TopLeft;
+    U032 WidthHeight;
+} RivaRectangle;
+/*
+ * 2D screen-screen BLT.
+ */
+typedef volatile struct
+{
+    U032 reserved00[4];
+#ifdef __BIG_ENDIAN
+    U032 FifoFree;
+#else
+    U016 FifoFree;
+    U016 Nop;
+#endif
+    U032 reserved01[0x0BB];
+    U032 TopLeftSrc;
+    U032 TopLeftDst;
+    U032 WidthHeight;
+} RivaScreenBlt;
+/*
+ * 2D pixel BLT.
+ */
+typedef volatile struct
+{
+    U032 reserved00[4];
+#ifdef __BIG_ENDIAN
+    U032 FifoFree;
+#else
+    U016 FifoFree;
+    U016 Nop[1];
+#endif
+    U032 reserved01[0x0BC];
+    U032 TopLeft;
+    U032 WidthHeight;
+    U032 WidthHeightIn;
+    U032 reserved02[0x03C];
+    U032 Pixels;
+} RivaPixmap;
+/*
+ * Filled rectangle combined with monochrome expand.  Useful for glyphs.
+ */
+typedef volatile struct
+{
+    U032 reserved00[4];
+#ifdef __BIG_ENDIAN
+    U032 FifoFree;
+#else
+    U016 FifoFree;
+    U016 Nop;
+#endif
+    U032 reserved01[0x0BB];
+    U032 reserved03[(0x040)-1];
+    U032 Color1A;
+    struct
+    {
+        U032 TopLeft;
+        U032 WidthHeight;
+    } UnclippedRectangle[64];
+    U032 reserved04[(0x080)-3];
+    struct
+    {
+        U032 TopLeft;
+        U032 BottomRight;
+    } ClipB;
+    U032 Color1B;
+    struct
+    {
+        U032 TopLeft;
+        U032 BottomRight;
+    } ClippedRectangle[64];
+    U032 reserved05[(0x080)-5];
+    struct
+    {
+        U032 TopLeft;
+        U032 BottomRight;
+    } ClipC;
+    U032 Color1C;
+    U032 WidthHeightC;
+    U032 PointC;
+    U032 MonochromeData1C;
+    U032 reserved06[(0x080)+121];
+    struct
+    {
+        U032 TopLeft;
+        U032 BottomRight;
+    } ClipD;
+    U032 Color1D;
+    U032 WidthHeightInD;
+    U032 WidthHeightOutD;
+    U032 PointD;
+    U032 MonochromeData1D;
+    U032 reserved07[(0x080)+120];
+    struct
+    {
+        U032 TopLeft;
+        U032 BottomRight;
+    } ClipE;
+    U032 Color0E;
+    U032 Color1E;
+    U032 WidthHeightInE;
+    U032 WidthHeightOutE;
+    U032 PointE;
+    U032 MonochromeData01E;
+} RivaBitmap;
+/*
+ * 3D textured, Z buffered triangle.
+ */
+typedef volatile struct
+{
+    U032 reserved00[4];
+#ifdef __BIG_ENDIAN
+    U032 FifoFree;
+#else
+    U016 FifoFree;
+    U016 Nop;
+#endif
+    U032 reserved01[0x0BC];
+    U032 TextureOffset;
+    U032 TextureFormat;
+    U032 TextureFilter;
+    U032 FogColor;
+/* This is a problem on LynxOS */
+#ifdef Control
+#undef Control
+#endif
+    U032 Control;
+    U032 AlphaTest;
+    U032 reserved02[0x339];
+    U032 FogAndIndex;
+    U032 Color;
+    float ScreenX;
+    float ScreenY;
+    float ScreenZ;
+    float EyeM;
+    float TextureS;
+    float TextureT;
+} RivaTexturedTriangle03;
+typedef volatile struct
+{
+    U032 reserved00[4];
+#ifdef __BIG_ENDIAN
+    U032 FifoFree;
+#else
+    U016 FifoFree;
+    U016 Nop;
+#endif
+    U032 reserved01[0x0BB];
+    U032 ColorKey;
+    U032 TextureOffset;
+    U032 TextureFormat;
+    U032 TextureFilter;
+    U032 Blend;
+/* This is a problem on LynxOS */
+#ifdef Control
+#undef Control
+#endif
+    U032 Control;
+    U032 FogColor;
+    U032 reserved02[0x39];
+    struct
+    {
+        float ScreenX;
+        float ScreenY;
+        float ScreenZ;
+        float EyeM;
+        U032 Color;
+        U032 Specular;
+        float TextureS;
+        float TextureT;
+    } Vertex[16];
+    U032 DrawTriangle3D;
+} RivaTexturedTriangle05;
+/*
+ * 2D line.
+ */
+typedef volatile struct
+{
+    U032 reserved00[4];
+#ifdef __BIG_ENDIAN
+    U032 FifoFree;
+#else
+    U016 FifoFree;
+    U016 Nop[1];
+#endif
+    U032 reserved01[0x0BC];
+    U032 Color;             /* source color               0304-0307*/
+    U032 Reserved02[0x03e];
+    struct {                /* start aliased methods in array   0400-    */
+        U032 point0;        /* y_x S16_S16 in pixels            0-   3*/
+        U032 point1;        /* y_x S16_S16 in pixels            4-   7*/
+    } Lin[16];              /* end of aliased methods in array      -047f*/
+    struct {                /* start aliased methods in array   0480-    */
+        U032 point0X;       /* in pixels, 0 at left                0-   3*/
+        U032 point0Y;       /* in pixels, 0 at top                 4-   7*/
+        U032 point1X;       /* in pixels, 0 at left                8-   b*/
+        U032 point1Y;       /* in pixels, 0 at top                 c-   f*/
+    } Lin32[8];             /* end of aliased methods in array      -04ff*/
+    U032 PolyLin[32];       /* y_x S16_S16 in pixels         0500-057f*/
+    struct {                /* start aliased methods in array   0580-    */
+        U032 x;             /* in pixels, 0 at left                0-   3*/
+        U032 y;             /* in pixels, 0 at top                 4-   7*/
+    } PolyLin32[16];        /* end of aliased methods in array      -05ff*/
+    struct {                /* start aliased methods in array   0600-    */
+        U032 color;         /* source color                     0-   3*/
+        U032 point;         /* y_x S16_S16 in pixels            4-   7*/
+    } ColorPolyLin[16];     /* end of aliased methods in array      -067f*/
+} RivaLine;
+/*
+ * 2D/3D surfaces
+ */
+typedef volatile struct
+{
+    U032 reserved00[4];
+#ifdef __BIG_ENDIAN
+    U032 FifoFree;
+#else
+    U016 FifoFree;
+    U016 Nop;
+#endif
+    U032 reserved01[0x0BE];
+    U032 Offset;
+} RivaSurface;
+typedef volatile struct
+{
+    U032 reserved00[4];
+#ifdef __BIG_ENDIAN
+    U032 FifoFree;
+#else
+    U016 FifoFree;
+    U016 Nop;
+#endif
+    U032 reserved01[0x0BD];
+    U032 Pitch;
+    U032 RenderBufferOffset;
+    U032 ZBufferOffset;
+} RivaSurface3D;
+    
+/***************************************************************************\
+*                                                                           *
+*                        Virtualized RIVA H/W interface.                    *
+*                                                                           *
+\***************************************************************************/
+
+#define FP_ENABLE  1
+#define FP_DITHER  2
+
+struct _riva_hw_inst;
+struct _riva_hw_state;
+/*
+ * Virtialized chip interface. Makes RIVA 128 and TNT look alike.
+ */
+typedef struct _riva_hw_inst
+{
+    /*
+     * Chip specific settings.
+     */
+    U032 Architecture;
+    U032 Version;
+    U032 Chipset;
+    U032 CrystalFreqKHz;
+    U032 RamAmountKBytes;
+    U032 MaxVClockFreqKHz;
+    U032 RamBandwidthKBytesPerSec;
+    U032 EnableIRQ;
+    U032 IO;
+    U032 VBlankBit;
+    U032 FifoFreeCount;
+    U032 FifoEmptyCount;
+    U032 CursorStart;
+    U032 flatPanel;
+    Bool twoHeads;
+    /*
+     * Non-FIFO registers.
+     */
+    volatile U032 __iomem *PCRTC0;
+    volatile U032 __iomem *PCRTC;
+    volatile U032 __iomem *PRAMDAC0;
+    volatile U032 __iomem *PFB;
+    volatile U032 __iomem *PFIFO;
+    volatile U032 __iomem *PGRAPH;
+    volatile U032 __iomem *PEXTDEV;
+    volatile U032 __iomem *PTIMER;
+    volatile U032 __iomem *PMC;
+    volatile U032 __iomem *PRAMIN;
+    volatile U032 __iomem *FIFO;
+    volatile U032 __iomem *CURSOR;
+    volatile U008 __iomem *PCIO0;
+    volatile U008 __iomem *PCIO;
+    volatile U008 __iomem *PVIO;
+    volatile U008 __iomem *PDIO0;
+    volatile U008 __iomem *PDIO;
+    volatile U032 __iomem *PRAMDAC;
+    /*
+     * Common chip functions.
+     */
+    int  (*Busy)(struct _riva_hw_inst *);
+    void (*CalcStateExt)(struct _riva_hw_inst *,struct _riva_hw_state *,int,int,int,int,int);
+    void (*LoadStateExt)(struct _riva_hw_inst *,struct _riva_hw_state *);
+    void (*UnloadStateExt)(struct _riva_hw_inst *,struct _riva_hw_state *);
+    void (*SetStartAddress)(struct _riva_hw_inst *,U032);
+    void (*SetSurfaces2D)(struct _riva_hw_inst *,U032,U032);
+    void (*SetSurfaces3D)(struct _riva_hw_inst *,U032,U032);
+    int  (*ShowHideCursor)(struct _riva_hw_inst *,int);
+    void (*LockUnlock)(struct _riva_hw_inst *, int);
+    /*
+     * Current extended mode settings.
+     */
+    struct _riva_hw_state *CurrentState;
+    /*
+     * FIFO registers.
+     */
+    RivaRop                 __iomem *Rop;
+    RivaPattern             __iomem *Patt;
+    RivaClip                __iomem *Clip;
+    RivaPixmap              __iomem *Pixmap;
+    RivaScreenBlt           __iomem *Blt;
+    RivaBitmap              __iomem *Bitmap;
+    RivaLine                __iomem *Line;
+    RivaTexturedTriangle03  __iomem *Tri03;
+    RivaTexturedTriangle05  __iomem *Tri05;
+} RIVA_HW_INST;
+/*
+ * Extended mode state information.
+ */
+typedef struct _riva_hw_state
+{
+    U032 bpp;
+    U032 width;
+    U032 height;
+    U032 interlace;
+    U032 repaint0;
+    U032 repaint1;
+    U032 screen;
+    U032 scale;
+    U032 dither;
+    U032 extra;
+    U032 pixel;
+    U032 horiz;
+    U032 arbitration0;
+    U032 arbitration1;
+    U032 vpll;
+    U032 vpll2;
+    U032 pllsel;
+    U032 general;
+    U032 crtcOwner;
+    U032 head; 
+    U032 head2; 
+    U032 config;
+    U032 cursorConfig;	
+    U032 cursor0;
+    U032 cursor1;
+    U032 cursor2;
+    U032 offset0;
+    U032 offset1;
+    U032 offset2;
+    U032 offset3;
+    U032 pitch0;
+    U032 pitch1;
+    U032 pitch2;
+    U032 pitch3;
+    U032 fb_start;
+    U032 vend;
+    U032 vtotal;
+    U032 vcrtc;
+    U032 vsyncstart;
+    U032 vsyncend;
+    U032 vvalidstart;
+    U032 vvalidend;
+    U032 hend;
+    U032 htotal;
+    U032 hcrtc;
+    U032 hsyncstart;
+    U032 hsyncend;
+    U032 hvalidstart;
+    U032 hvalidend;
+    U032 crtchdispend;
+    U032 crtcvstart;
+    U032 crtcvtotal;
+    U032 checksum;   
+} RIVA_HW_STATE;
+/*
+ * External routines.
+ */
+int RivaGetConfig(RIVA_HW_INST *, unsigned int);
+/*
+ * FIFO Free Count. Should attempt to yield processor if RIVA is busy.
+ */
+
+#define RIVA_FIFO_FREE(hwinst,hwptr,cnt)                            \
+{                                                                   \
+    while ((hwinst).FifoFreeCount < (cnt)) {                        \
+	mb();mb();						    \
+        (hwinst).FifoFreeCount = NV_RD32(&(hwinst).hwptr->FifoFree, 0) >> 2;     \
+    }								    \
+    (hwinst).FifoFreeCount -= (cnt);                                \
+}
+#endif /* __RIVA_HW_H__ */
+
diff -uprN a/drivers/video/xbox/riva_tbl.h b/drivers/video/xbox/riva_tbl.h
--- a/drivers/video/xbox/riva_tbl.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/riva_tbl.h	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,1008 @@
+ /***************************************************************************\
+|*                                                                           *|
+|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
+|*                                                                           *|
+|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
+|*     international laws.  Users and possessors of this source code are     *|
+|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
+|*     use this code in individual and commercial software.                  *|
+|*                                                                           *|
+|*     Any use of this source code must include,  in the user documenta-     *|
+|*     tion and  internal comments to the code,  notices to the end user     *|
+|*     as follows:                                                           *|
+|*                                                                           *|
+|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
+|*                                                                           *|
+|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
+|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
+|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
+|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
+|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
+|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
+|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
+|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
+|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
+|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
+|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
+|*                                                                           *|
+|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
+|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
+|*     consisting  of "commercial  computer  software"  and  "commercial     *|
+|*     computer  software  documentation,"  as such  terms  are  used in     *|
+|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
+|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
+|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
+|*     all U.S. Government End Users  acquire the source code  with only     *|
+|*     those rights set forth herein.                                        *|
+|*                                                                           *|
+ \***************************************************************************/
+
+/*
+ * GPL licensing note -- nVidia is allowing a liberal interpretation of
+ * the documentation restriction above, to merely say that this nVidia's
+ * copyright and disclaimer should be included with all code derived
+ * from this source.  -- Jeff Garzik <jgarzik@pobox.com>, 01/Nov/99 
+ */
+
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/riva_tbl.h,v 1.9 2002/01/30 01:35:03 mvojkovi Exp $ */
+
+
+/*
+ * RIVA Fixed Functionality Init Tables.
+ */
+static unsigned RivaTablePMC[][2] =
+{
+    {0x00000050, 0x00000000},
+    {0x00000080, 0xFFFF00FF},
+    {0x00000080, 0xFFFFFFFF}
+};
+static unsigned RivaTablePTIMER[][2] =
+{
+    {0x00000080, 0x00000008},
+    {0x00000084, 0x00000003},
+    {0x00000050, 0x00000000},
+    {0x00000040, 0xFFFFFFFF}
+};
+static unsigned RivaTableFIFO[][2] =
+{
+    {0x00000000, 0x80000000},
+    {0x00000800, 0x80000001},
+    {0x00001000, 0x80000002},
+    {0x00001800, 0x80000010},
+    {0x00002000, 0x80000011},
+    {0x00002800, 0x80000012},
+    {0x00003000, 0x80000016},
+    {0x00003800, 0x80000013}
+};
+static unsigned nv3TablePFIFO[][2] =
+{
+    {0x00000140, 0x00000000},
+    {0x00000480, 0x00000000},
+    {0x00000490, 0x00000000},
+    {0x00000494, 0x00000000},
+    {0x00000481, 0x00000000},
+    {0x00000084, 0x00000000},
+    {0x00000086, 0x00002000},
+    {0x00000085, 0x00002200},
+    {0x00000484, 0x00000000},
+    {0x0000049C, 0x00000000},
+    {0x00000104, 0x00000000},
+    {0x00000108, 0x00000000},
+    {0x00000100, 0x00000000},
+    {0x000004A0, 0x00000000},
+    {0x000004A4, 0x00000000},
+    {0x000004A8, 0x00000000},
+    {0x000004AC, 0x00000000},
+    {0x000004B0, 0x00000000},
+    {0x000004B4, 0x00000000},
+    {0x000004B8, 0x00000000},
+    {0x000004BC, 0x00000000},
+    {0x00000050, 0x00000000},
+    {0x00000040, 0xFFFFFFFF},
+    {0x00000480, 0x00000001},
+    {0x00000490, 0x00000001},
+    {0x00000140, 0x00000001}
+};
+static unsigned nv3TablePGRAPH[][2] =
+{
+    {0x00000020, 0x1230001F},
+    {0x00000021, 0x10113000},
+    {0x00000022, 0x1131F101},
+    {0x00000023, 0x0100F531},
+    {0x00000060, 0x00000000},
+    {0x00000065, 0x00000000},
+    {0x00000068, 0x00000000},
+    {0x00000069, 0x00000000},
+    {0x0000006A, 0x00000000},
+    {0x0000006B, 0x00000000},
+    {0x0000006C, 0x00000000},
+    {0x0000006D, 0x00000000},
+    {0x0000006E, 0x00000000},
+    {0x0000006F, 0x00000000},
+    {0x000001A8, 0x00000000},
+    {0x00000440, 0xFFFFFFFF},
+    {0x00000480, 0x00000001},
+    {0x000001A0, 0x00000000},
+    {0x000001A2, 0x00000000},
+    {0x0000018A, 0xFFFFFFFF},
+    {0x00000190, 0x00000000},
+    {0x00000142, 0x00000000},
+    {0x00000154, 0x00000000},
+    {0x00000155, 0xFFFFFFFF},
+    {0x00000156, 0x00000000},
+    {0x00000157, 0xFFFFFFFF},
+    {0x00000064, 0x10010002},
+    {0x00000050, 0x00000000},
+    {0x00000051, 0x00000000},
+    {0x00000040, 0xFFFFFFFF},
+    {0x00000041, 0xFFFFFFFF},
+    {0x00000440, 0xFFFFFFFF},
+    {0x000001A9, 0x00000001}
+};
+static unsigned nv3TablePGRAPH_8BPP[][2] =
+{
+    {0x000001AA, 0x00001111}
+};
+static unsigned nv3TablePGRAPH_15BPP[][2] =
+{
+    {0x000001AA, 0x00002222}
+};
+static unsigned nv3TablePGRAPH_32BPP[][2] =
+{
+    {0x000001AA, 0x00003333}
+};
+static unsigned nv3TablePRAMIN[][2] =
+{
+    {0x00000500, 0x00010000},
+    {0x00000501, 0x007FFFFF},
+    {0x00000200, 0x80000000},
+    {0x00000201, 0x00C20341},
+    {0x00000204, 0x80000001},
+    {0x00000205, 0x00C50342},
+    {0x00000208, 0x80000002},
+    {0x00000209, 0x00C60343},
+    {0x0000020C, 0x80000003},
+    {0x0000020D, 0x00DC0348},
+    {0x00000210, 0x80000004},
+    {0x00000211, 0x00DC0349},
+    {0x00000214, 0x80000005},
+    {0x00000215, 0x00DC034A},
+    {0x00000218, 0x80000006},
+    {0x00000219, 0x00DC034B},
+    {0x00000240, 0x80000010},
+    {0x00000241, 0x00D10344},
+    {0x00000244, 0x80000011},
+    {0x00000245, 0x00D00345},
+    {0x00000248, 0x80000012},
+    {0x00000249, 0x00CC0346},
+    {0x0000024C, 0x80000013},
+    {0x0000024D, 0x00D70347},
+    {0x00000258, 0x80000016},
+    {0x00000259, 0x00CA034C},
+    {0x00000D05, 0x00000000},
+    {0x00000D06, 0x00000000},
+    {0x00000D07, 0x00000000},
+    {0x00000D09, 0x00000000},
+    {0x00000D0A, 0x00000000},
+    {0x00000D0B, 0x00000000},
+    {0x00000D0D, 0x00000000},
+    {0x00000D0E, 0x00000000},
+    {0x00000D0F, 0x00000000},
+    {0x00000D11, 0x00000000},
+    {0x00000D12, 0x00000000},
+    {0x00000D13, 0x00000000},
+    {0x00000D15, 0x00000000},
+    {0x00000D16, 0x00000000},
+    {0x00000D17, 0x00000000},
+    {0x00000D19, 0x00000000},
+    {0x00000D1A, 0x00000000},
+    {0x00000D1B, 0x00000000},
+    {0x00000D1D, 0x00000140},
+    {0x00000D1E, 0x00000000},
+    {0x00000D1F, 0x00000000},
+    {0x00000D20, 0x10100200},
+    {0x00000D21, 0x00000000},
+    {0x00000D22, 0x00000000},
+    {0x00000D23, 0x00000000},
+    {0x00000D24, 0x10210200},
+    {0x00000D25, 0x00000000},
+    {0x00000D26, 0x00000000},
+    {0x00000D27, 0x00000000},
+    {0x00000D28, 0x10420200},
+    {0x00000D29, 0x00000000},
+    {0x00000D2A, 0x00000000},
+    {0x00000D2B, 0x00000000},
+    {0x00000D2C, 0x10830200},
+    {0x00000D2D, 0x00000000},
+    {0x00000D2E, 0x00000000},
+    {0x00000D2F, 0x00000000},
+    {0x00000D31, 0x00000000},
+    {0x00000D32, 0x00000000},
+    {0x00000D33, 0x00000000}
+};
+static unsigned nv3TablePRAMIN_8BPP[][2] =
+{
+    /*           0xXXXXX3XX For  MSB mono format */
+    /*           0xXXXXX2XX For  LSB mono format */
+    {0x00000D04, 0x10110203},
+    {0x00000D08, 0x10110203},
+    {0x00000D0C, 0x1011020B},
+    {0x00000D10, 0x10118203},
+    {0x00000D14, 0x10110203},
+    {0x00000D18, 0x10110203},
+    {0x00000D1C, 0x10419208},
+    {0x00000D30, 0x10118203}
+};
+static unsigned nv3TablePRAMIN_15BPP[][2] =
+{
+    /*           0xXXXXX2XX For  MSB mono format */
+    /*           0xXXXXX3XX For  LSB mono format */
+    {0x00000D04, 0x10110200},
+    {0x00000D08, 0x10110200},
+    {0x00000D0C, 0x10110208},
+    {0x00000D10, 0x10118200},
+    {0x00000D14, 0x10110200},
+    {0x00000D18, 0x10110200},
+    {0x00000D1C, 0x10419208},
+    {0x00000D30, 0x10118200}
+};
+static unsigned nv3TablePRAMIN_32BPP[][2] =
+{
+    /*           0xXXXXX3XX For  MSB mono format */
+    /*           0xXXXXX2XX For  LSB mono format */
+    {0x00000D04, 0x10110201},
+    {0x00000D08, 0x10110201},
+    {0x00000D0C, 0x10110209},
+    {0x00000D10, 0x10118201},
+    {0x00000D14, 0x10110201},
+    {0x00000D18, 0x10110201},
+    {0x00000D1C, 0x10419208},
+    {0x00000D30, 0x10118201}
+};
+static unsigned nv4TableFIFO[][2] =
+{
+    {0x00003800, 0x80000014}
+};
+static unsigned nv4TablePFIFO[][2] =
+{
+    {0x00000140, 0x00000000},
+    {0x00000480, 0x00000000},
+    {0x00000494, 0x00000000},
+    {0x00000481, 0x00000000},
+    {0x0000048B, 0x00000000},
+    {0x00000400, 0x00000000},
+    {0x00000414, 0x00000000},
+    {0x00000084, 0x03000100},  
+    {0x00000085, 0x00000110},
+    {0x00000086, 0x00000112},  
+    {0x00000143, 0x0000FFFF},
+    {0x00000496, 0x0000FFFF},
+    {0x00000050, 0x00000000},
+    {0x00000040, 0xFFFFFFFF},
+    {0x00000415, 0x00000001},
+    {0x00000480, 0x00000001},
+    {0x00000494, 0x00000001},
+    {0x00000495, 0x00000001},
+    {0x00000140, 0x00000001}
+};
+static unsigned nv4TablePGRAPH[][2] =
+{
+    {0x00000020, 0x1231C001},
+    {0x00000021, 0x72111101},
+    {0x00000022, 0x11D5F071},
+    {0x00000023, 0x10D4FF31},
+    {0x00000060, 0x00000000},
+    {0x00000068, 0x00000000},
+    {0x00000070, 0x00000000},
+    {0x00000078, 0x00000000},
+    {0x00000061, 0x00000000},
+    {0x00000069, 0x00000000},
+    {0x00000071, 0x00000000},
+    {0x00000079, 0x00000000},
+    {0x00000062, 0x00000000},
+    {0x0000006A, 0x00000000},
+    {0x00000072, 0x00000000},
+    {0x0000007A, 0x00000000},
+    {0x00000063, 0x00000000},
+    {0x0000006B, 0x00000000},
+    {0x00000073, 0x00000000},
+    {0x0000007B, 0x00000000},
+    {0x00000064, 0x00000000},
+    {0x0000006C, 0x00000000},
+    {0x00000074, 0x00000000},
+    {0x0000007C, 0x00000000},
+    {0x00000065, 0x00000000},
+    {0x0000006D, 0x00000000},
+    {0x00000075, 0x00000000},
+    {0x0000007D, 0x00000000},
+    {0x00000066, 0x00000000},
+    {0x0000006E, 0x00000000},
+    {0x00000076, 0x00000000},
+    {0x0000007E, 0x00000000},
+    {0x00000067, 0x00000000},
+    {0x0000006F, 0x00000000},
+    {0x00000077, 0x00000000},
+    {0x0000007F, 0x00000000},
+    {0x00000058, 0x00000000},
+    {0x00000059, 0x00000000},
+    {0x0000005A, 0x00000000},
+    {0x0000005B, 0x00000000},
+    {0x00000196, 0x00000000},
+    {0x000001A1, 0x01FFFFFF},
+    {0x00000197, 0x00000000},
+    {0x000001A2, 0x01FFFFFF},
+    {0x00000198, 0x00000000},
+    {0x000001A3, 0x01FFFFFF},
+    {0x00000199, 0x00000000},
+    {0x000001A4, 0x01FFFFFF},
+    {0x00000050, 0x00000000},
+    {0x00000040, 0xFFFFFFFF},
+    {0x0000005C, 0x10010100},
+    {0x000001C4, 0xFFFFFFFF},
+    {0x000001C8, 0x00000001},
+    {0x00000204, 0x00000000},
+    {0x000001C3, 0x00000001}
+};
+static unsigned nv4TablePGRAPH_8BPP[][2] =
+{
+    {0x000001C9, 0x00111111},
+    {0x00000186, 0x00001010},
+    {0x0000020C, 0x03020202}
+};
+static unsigned nv4TablePGRAPH_15BPP[][2] =
+{
+    {0x000001C9, 0x00226222},
+    {0x00000186, 0x00002071},
+    {0x0000020C, 0x09080808}
+};
+static unsigned nv4TablePGRAPH_16BPP[][2] =
+{
+    {0x000001C9, 0x00556555},
+    {0x00000186, 0x000050C2},
+    {0x0000020C, 0x0C0B0B0B}
+};
+static unsigned nv4TablePGRAPH_32BPP[][2] =
+{
+    {0x000001C9, 0x0077D777},
+    {0x00000186, 0x000070E5},
+    {0x0000020C, 0x0E0D0D0D}
+};
+static unsigned nv4TablePRAMIN[][2] =
+{
+    {0x00000000, 0x80000010},
+    {0x00000001, 0x80011145},
+    {0x00000002, 0x80000011},
+    {0x00000003, 0x80011146},
+    {0x00000004, 0x80000012},
+    {0x00000005, 0x80011147},
+    {0x00000006, 0x80000013},
+    {0x00000007, 0x80011148},
+    {0x00000008, 0x80000014},
+    {0x00000009, 0x80011149},
+    {0x0000000A, 0x80000015},
+    {0x0000000B, 0x8001114A},
+    {0x0000000C, 0x80000016},
+    {0x0000000D, 0x8001114F},
+    {0x00000020, 0x80000000},
+    {0x00000021, 0x80011142},
+    {0x00000022, 0x80000001},
+    {0x00000023, 0x80011143},
+    {0x00000024, 0x80000002},
+    {0x00000025, 0x80011144}, 
+    {0x00000026, 0x80000003},
+    {0x00000027, 0x8001114B},
+    {0x00000028, 0x80000004},
+    {0x00000029, 0x8001114C},
+    {0x0000002A, 0x80000005},
+    {0x0000002B, 0x8001114D},
+    {0x0000002C, 0x80000006},
+    {0x0000002D, 0x8001114E},
+    {0x00000500, 0x00003000},
+    {0x00000501, 0x01FFFFFF},
+    {0x00000502, 0x00000002},
+    {0x00000503, 0x00000002},
+    {0x00000508, 0x01008043},
+    {0x0000050A, 0x00000000},
+    {0x0000050B, 0x00000000},
+    {0x0000050C, 0x01008019},
+    {0x0000050E, 0x00000000},
+    {0x0000050F, 0x00000000},
+#if 1
+    {0x00000510, 0x01008018},
+#else
+    {0x00000510, 0x01008044},
+#endif
+    {0x00000512, 0x00000000},
+    {0x00000513, 0x00000000},
+    {0x00000514, 0x01008021},
+    {0x00000516, 0x00000000},
+    {0x00000517, 0x00000000},
+    {0x00000518, 0x0100805F},
+    {0x0000051A, 0x00000000},
+    {0x0000051B, 0x00000000},
+#if 1
+    {0x0000051C, 0x0100804B},
+#else
+    {0x0000051C, 0x0100804A},
+#endif
+    {0x0000051E, 0x00000000},
+    {0x0000051F, 0x00000000},
+    {0x00000520, 0x0100A048},
+    {0x00000521, 0x00000D01},
+    {0x00000522, 0x11401140},
+    {0x00000523, 0x00000000},
+    {0x00000524, 0x0300A054},
+    {0x00000525, 0x00000D01},
+    {0x00000526, 0x11401140},
+    {0x00000527, 0x00000000},
+    {0x00000528, 0x0300A055},
+    {0x00000529, 0x00000D01},
+    {0x0000052A, 0x11401140},
+    {0x0000052B, 0x00000000},
+    {0x0000052C, 0x00000058},
+    {0x0000052E, 0x11401140},
+    {0x0000052F, 0x00000000},
+    {0x00000530, 0x00000059},
+    {0x00000532, 0x11401140},
+    {0x00000533, 0x00000000},
+    {0x00000534, 0x0000005A},
+    {0x00000536, 0x11401140},
+    {0x00000537, 0x00000000},
+    {0x00000538, 0x0000005B},
+    {0x0000053A, 0x11401140},
+    {0x0000053B, 0x00000000},
+    {0x0000053C, 0x0300A01C},
+    {0x0000053E, 0x11401140},
+    {0x0000053F, 0x00000000}
+};
+static unsigned nv4TablePRAMIN_8BPP[][2] =
+{
+    /*           0xXXXXXX01 For  MSB mono format */
+    /*           0xXXXXXX02 For  LSB mono format */
+    {0x00000509, 0x00000302},
+    {0x0000050D, 0x00000302},
+    {0x00000511, 0x00000202},
+    {0x00000515, 0x00000302},
+    {0x00000519, 0x00000302},
+    {0x0000051D, 0x00000302},
+    {0x0000052D, 0x00000302},
+    {0x0000052E, 0x00000302},
+    {0x00000535, 0x00000000},
+    {0x00000539, 0x00000000},
+    {0x0000053D, 0x00000302}
+};
+static unsigned nv4TablePRAMIN_15BPP[][2] =
+{
+    /*           0xXXXXXX01 For  MSB mono format */
+    /*           0xXXXXXX02 For  LSB mono format */
+    {0x00000509, 0x00000902},
+    {0x0000050D, 0x00000902},
+    {0x00000511, 0x00000802},
+    {0x00000515, 0x00000902},
+    {0x00000519, 0x00000902},
+    {0x0000051D, 0x00000902},
+    {0x0000052D, 0x00000902},
+    {0x0000052E, 0x00000902},
+    {0x00000535, 0x00000702},
+    {0x00000539, 0x00000702},
+    {0x0000053D, 0x00000902}
+};
+static unsigned nv4TablePRAMIN_16BPP[][2] =
+{
+    /*           0xXXXXXX01 For  MSB mono format */
+    /*           0xXXXXXX02 For  LSB mono format */
+    {0x00000509, 0x00000C02},
+    {0x0000050D, 0x00000C02},
+    {0x00000511, 0x00000B02},
+    {0x00000515, 0x00000C02},
+    {0x00000519, 0x00000C02},
+    {0x0000051D, 0x00000C02},
+    {0x0000052D, 0x00000C02},
+    {0x0000052E, 0x00000C02},
+    {0x00000535, 0x00000702},
+    {0x00000539, 0x00000702},
+    {0x0000053D, 0x00000C02}
+};
+static unsigned nv4TablePRAMIN_32BPP[][2] =
+{
+    /*           0xXXXXXX01 For  MSB mono format */
+    /*           0xXXXXXX02 For  LSB mono format */
+    {0x00000509, 0x00000E02},
+    {0x0000050D, 0x00000E02},
+    {0x00000511, 0x00000D02},
+    {0x00000515, 0x00000E02},
+    {0x00000519, 0x00000E02},
+    {0x0000051D, 0x00000E02},
+    {0x0000052D, 0x00000E02},
+    {0x0000052E, 0x00000E02},
+    {0x00000535, 0x00000E02},
+    {0x00000539, 0x00000E02},
+    {0x0000053D, 0x00000E02}
+};
+static unsigned nv10TableFIFO[][2] =
+{
+    {0x00003800, 0x80000014}
+};
+static unsigned nv10TablePFIFO[][2] =
+{
+    {0x00000140, 0x00000000},
+    {0x00000480, 0x00000000},
+    {0x00000494, 0x00000000},
+    {0x00000481, 0x00000000},
+    {0x0000048B, 0x00000000},
+    {0x00000400, 0x00000000},
+    {0x00000414, 0x00000000},
+    {0x00000084, 0x03000100},
+    {0x00000085, 0x00000110},
+    {0x00000086, 0x00000112},
+    {0x00000143, 0x0000FFFF},
+    {0x00000496, 0x0000FFFF},
+    {0x00000050, 0x00000000},
+    {0x00000040, 0xFFFFFFFF},
+    {0x00000415, 0x00000001},
+    {0x00000480, 0x00000001},
+    {0x00000494, 0x00000001},
+    {0x00000495, 0x00000001},
+    {0x00000140, 0x00000001}
+};
+static unsigned nv10TablePGRAPH[][2] =
+{
+    {0x00000020, 0x0003FFFF},
+    {0x00000021, 0x00118701},
+    {0x00000022, 0x24F82AD9},
+    {0x00000023, 0x55DE0030},
+    {0x00000020, 0x00000000},
+    {0x00000024, 0x00000000},
+    {0x00000058, 0x00000000},
+    {0x00000060, 0x00000000},
+    {0x00000068, 0x00000000},
+    {0x00000070, 0x00000000},
+    {0x00000078, 0x00000000},
+    {0x00000059, 0x00000000},
+    {0x00000061, 0x00000000},
+    {0x00000069, 0x00000000},
+    {0x00000071, 0x00000000},
+    {0x00000079, 0x00000000},
+    {0x0000005A, 0x00000000},
+    {0x00000062, 0x00000000},
+    {0x0000006A, 0x00000000},
+    {0x00000072, 0x00000000},
+    {0x0000007A, 0x00000000},
+    {0x0000005B, 0x00000000},
+    {0x00000063, 0x00000000},
+    {0x0000006B, 0x00000000},
+    {0x00000073, 0x00000000},
+    {0x0000007B, 0x00000000},
+    {0x0000005C, 0x00000000},
+    {0x00000064, 0x00000000},
+    {0x0000006C, 0x00000000},
+    {0x00000074, 0x00000000},
+    {0x0000007C, 0x00000000},
+    {0x0000005D, 0x00000000},
+    {0x00000065, 0x00000000},
+    {0x0000006D, 0x00000000},
+    {0x00000075, 0x00000000},
+    {0x0000007D, 0x00000000},
+    {0x0000005E, 0x00000000},
+    {0x00000066, 0x00000000},
+    {0x0000006E, 0x00000000},
+    {0x00000076, 0x00000000},
+    {0x0000007E, 0x00000000},
+    {0x0000005F, 0x00000000},
+    {0x00000067, 0x00000000},
+    {0x0000006F, 0x00000000},
+    {0x00000077, 0x00000000},
+    {0x0000007F, 0x00000000},
+    {0x00000053, 0x00000000},
+    {0x00000054, 0x00000000},
+    {0x00000055, 0x00000000},
+    {0x00000056, 0x00000000},
+    {0x00000057, 0x00000000},
+    {0x00000196, 0x00000000},
+    {0x000001A1, 0x01FFFFFF},
+    {0x00000197, 0x00000000},
+    {0x000001A2, 0x01FFFFFF},
+    {0x00000198, 0x00000000},
+    {0x000001A3, 0x01FFFFFF},
+    {0x00000199, 0x00000000},
+    {0x000001A4, 0x01FFFFFF},
+    {0x0000019A, 0x00000000},
+    {0x000001A5, 0x01FFFFFF},
+    {0x0000019B, 0x00000000},
+    {0x000001A6, 0x01FFFFFF},
+    {0x00000050, 0x01111111},
+    {0x00000040, 0xFFFFFFFF},
+    {0x00000051, 0x10010100},
+    {0x000001C5, 0xFFFFFFFF},
+    {0x000001C8, 0x00000001},
+    {0x00000204, 0x00000000},
+    {0x000001C4, 0x00000001}
+};
+static unsigned nv10TablePGRAPH_8BPP[][2] =
+{
+    {0x000001C9, 0x00111111},
+    {0x00000186, 0x00001010},
+    {0x0000020C, 0x03020202}
+};
+static unsigned nv10TablePGRAPH_15BPP[][2] =
+{
+    {0x000001C9, 0x00226222},
+    {0x00000186, 0x00002071},
+    {0x0000020C, 0x09080808}
+};
+static unsigned nv10TablePGRAPH_16BPP[][2] =
+{
+    {0x000001C9, 0x00556555},
+    {0x00000186, 0x000050C2},
+    {0x0000020C, 0x000B0B0C}
+};
+static unsigned nv10TablePGRAPH_32BPP[][2] =
+{
+    {0x000001C9, 0x0077D777},
+    {0x00000186, 0x000070E5},
+    {0x0000020C, 0x0E0D0D0D}
+};
+static unsigned nv10tri05TablePGRAPH[][2] =
+{
+    {(0x00000E00/4), 0x00000000},
+    {(0x00000E04/4), 0x00000000},
+    {(0x00000E08/4), 0x00000000},
+    {(0x00000E0C/4), 0x00000000},
+    {(0x00000E10/4), 0x00001000},
+    {(0x00000E14/4), 0x00001000},
+    {(0x00000E18/4), 0x4003ff80},
+    {(0x00000E1C/4), 0x00000000},
+    {(0x00000E20/4), 0x00000000},
+    {(0x00000E24/4), 0x00000000},
+    {(0x00000E28/4), 0x00000000},
+    {(0x00000E2C/4), 0x00000000},
+    {(0x00000E30/4), 0x00080008},
+    {(0x00000E34/4), 0x00080008},
+    {(0x00000E38/4), 0x00000000},
+    {(0x00000E3C/4), 0x00000000},
+    {(0x00000E40/4), 0x00000000},
+    {(0x00000E44/4), 0x00000000},
+    {(0x00000E48/4), 0x00000000},
+    {(0x00000E4C/4), 0x00000000},
+    {(0x00000E50/4), 0x00000000},
+    {(0x00000E54/4), 0x00000000},
+    {(0x00000E58/4), 0x00000000},
+    {(0x00000E5C/4), 0x00000000},
+    {(0x00000E60/4), 0x00000000},
+    {(0x00000E64/4), 0x10000000},
+    {(0x00000E68/4), 0x00000000},
+    {(0x00000E6C/4), 0x00000000},
+    {(0x00000E70/4), 0x00000000},
+    {(0x00000E74/4), 0x00000000},
+    {(0x00000E78/4), 0x00000000},
+    {(0x00000E7C/4), 0x00000000},
+    {(0x00000E80/4), 0x00000000},
+    {(0x00000E84/4), 0x00000000},
+    {(0x00000E88/4), 0x08000000},
+    {(0x00000E8C/4), 0x00000000},
+    {(0x00000E90/4), 0x00000000},
+    {(0x00000E94/4), 0x00000000},
+    {(0x00000E98/4), 0x00000000},
+    {(0x00000E9C/4), 0x4B7FFFFF},
+    {(0x00000EA0/4), 0x00000000},
+    {(0x00000EA4/4), 0x00000000},
+    {(0x00000EA8/4), 0x00000000},
+    {(0x00000F00/4), 0x07FF0800},
+    {(0x00000F04/4), 0x07FF0800},
+    {(0x00000F08/4), 0x07FF0800},
+    {(0x00000F0C/4), 0x07FF0800},
+    {(0x00000F10/4), 0x07FF0800},
+    {(0x00000F14/4), 0x07FF0800},
+    {(0x00000F18/4), 0x07FF0800},
+    {(0x00000F1C/4), 0x07FF0800},
+    {(0x00000F20/4), 0x07FF0800},
+    {(0x00000F24/4), 0x07FF0800},
+    {(0x00000F28/4), 0x07FF0800},
+    {(0x00000F2C/4), 0x07FF0800},
+    {(0x00000F30/4), 0x07FF0800},
+    {(0x00000F34/4), 0x07FF0800},
+    {(0x00000F38/4), 0x07FF0800},
+    {(0x00000F3C/4), 0x07FF0800},
+    {(0x00000F40/4), 0x10000000},
+    {(0x00000F44/4), 0x00000000},
+    {(0x00000F50/4), 0x00006740},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F50/4), 0x00006750},
+    {(0x00000F54/4), 0x40000000},
+    {(0x00000F54/4), 0x40000000},
+    {(0x00000F54/4), 0x40000000},
+    {(0x00000F54/4), 0x40000000},
+    {(0x00000F50/4), 0x00006760},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F50/4), 0x00006770},
+    {(0x00000F54/4), 0xC5000000},
+    {(0x00000F54/4), 0xC5000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F50/4), 0x00006780},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F50/4), 0x000067A0},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F50/4), 0x00006AB0},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F50/4), 0x00006AC0},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F50/4), 0x00006C10},
+    {(0x00000F54/4), 0xBF800000},
+    {(0x00000F50/4), 0x00007030},
+    {(0x00000F54/4), 0x7149F2CA},
+    {(0x00000F50/4), 0x00007040},
+    {(0x00000F54/4), 0x7149F2CA},
+    {(0x00000F50/4), 0x00007050},
+    {(0x00000F54/4), 0x7149F2CA},
+    {(0x00000F50/4), 0x00007060},
+    {(0x00000F54/4), 0x7149F2CA},
+    {(0x00000F50/4), 0x00007070},
+    {(0x00000F54/4), 0x7149F2CA},
+    {(0x00000F50/4), 0x00007080},
+    {(0x00000F54/4), 0x7149F2CA},
+    {(0x00000F50/4), 0x00007090},
+    {(0x00000F54/4), 0x7149F2CA},
+    {(0x00000F50/4), 0x000070A0},
+    {(0x00000F54/4), 0x7149F2CA},
+    {(0x00000F50/4), 0x00006A80},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F50/4), 0x00006AA0},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F50/4), 0x00000040},
+    {(0x00000F54/4), 0x00000005},
+    {(0x00000F50/4), 0x00006400},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F54/4), 0x4B7FFFFF},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F50/4), 0x00006410},
+    {(0x00000F54/4), 0xC5000000},
+    {(0x00000F54/4), 0xC5000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F50/4), 0x00006420},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F50/4), 0x00006430},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F50/4), 0x000064C0},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F54/4), 0x477FFFFF},
+    {(0x00000F54/4), 0x3F800000},
+    {(0x00000F50/4), 0x000064D0},
+    {(0x00000F54/4), 0xC5000000},
+    {(0x00000F54/4), 0xC5000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F50/4), 0x000064E0},
+    {(0x00000F54/4), 0xC4FFF000},
+    {(0x00000F54/4), 0xC4FFF000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F50/4), 0x000064F0},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F54/4), 0x00000000},
+    {(0x00000F40/4), 0x30000000},
+    {(0x00000F44/4), 0x00000004},
+    {(0x00000F48/4), 0x10000000},
+    {(0x00000F4C/4), 0x00000000}
+};
+static unsigned nv10TablePRAMIN[][2] =
+{
+    {0x00000000, 0x80000010},
+    {0x00000001, 0x80011145},
+    {0x00000002, 0x80000011},
+    {0x00000003, 0x80011146},
+    {0x00000004, 0x80000012},
+    {0x00000005, 0x80011147},
+    {0x00000006, 0x80000013},
+    {0x00000007, 0x80011148},
+    {0x00000008, 0x80000014},
+    {0x00000009, 0x80011149},
+    {0x0000000A, 0x80000015},
+    {0x0000000B, 0x8001114A},
+    {0x0000000C, 0x80000016},
+    {0x0000000D, 0x80011150},
+    {0x00000020, 0x80000000},
+    {0x00000021, 0x80011142},
+    {0x00000022, 0x80000001},
+    {0x00000023, 0x80011143},
+    {0x00000024, 0x80000002},
+    {0x00000025, 0x80011144},
+    {0x00000026, 0x80000003},
+    {0x00000027, 0x8001114B},
+    {0x00000028, 0x80000004},
+    {0x00000029, 0x8001114C},
+    {0x0000002A, 0x80000005},
+    {0x0000002B, 0x8001114D},
+    {0x0000002C, 0x80000006},
+    {0x0000002D, 0x8001114E},
+    {0x0000002E, 0x80000007},
+    {0x0000002F, 0x8001114F},
+    {0x00000500, 0x00003000},
+    {0x00000501, 0x01FFFFFF},
+    {0x00000502, 0x00000002},
+    {0x00000503, 0x00000002},
+#ifdef __BIG_ENDIAN
+    {0x00000508, 0x01088043}, 
+#else
+    {0x00000508, 0x01008043},
+#endif
+    {0x0000050A, 0x00000000},
+    {0x0000050B, 0x00000000},
+#ifdef __BIG_ENDIAN
+    {0x0000050C, 0x01088019},
+#else
+    {0x0000050C, 0x01008019},
+#endif
+    {0x0000050E, 0x00000000},
+    {0x0000050F, 0x00000000},
+#ifdef __BIG_ENDIAN
+    {0x00000510, 0x01088018},
+#else
+    {0x00000510, 0x01008018},
+#endif
+    {0x00000512, 0x00000000},
+    {0x00000513, 0x00000000},
+#ifdef __BIG_ENDIAN
+    {0x00000514, 0x01088021},
+#else
+    {0x00000514, 0x01008021},
+#endif
+    {0x00000516, 0x00000000},
+    {0x00000517, 0x00000000},
+#ifdef __BIG_ENDIAN
+    {0x00000518, 0x0108805F},
+#else
+    {0x00000518, 0x0100805F},
+#endif
+    {0x0000051A, 0x00000000},
+    {0x0000051B, 0x00000000},
+#ifdef __BIG_ENDIAN
+    {0x0000051C, 0x0108804B},
+#else
+    {0x0000051C, 0x0100804B},
+#endif
+    {0x0000051E, 0x00000000},
+    {0x0000051F, 0x00000000},
+    {0x00000520, 0x0100A048},
+    {0x00000521, 0x00000D01},
+    {0x00000522, 0x11401140},
+    {0x00000523, 0x00000000},
+    {0x00000524, 0x0300A094},
+    {0x00000525, 0x00000D01},
+    {0x00000526, 0x11401140},
+    {0x00000527, 0x00000000},
+    {0x00000528, 0x0300A095},
+    {0x00000529, 0x00000D01},
+    {0x0000052A, 0x11401140},
+    {0x0000052B, 0x00000000},
+#ifdef __BIG_ENDIAN
+    {0x0000052C, 0x00080058},
+#else
+    {0x0000052C, 0x00000058},
+#endif
+    {0x0000052E, 0x11401140},
+    {0x0000052F, 0x00000000},
+#ifdef __BIG_ENDIAN
+    {0x00000530, 0x00080059},
+#else
+    {0x00000530, 0x00000059},
+#endif
+    {0x00000532, 0x11401140},
+    {0x00000533, 0x00000000},
+    {0x00000534, 0x0000005A},
+    {0x00000536, 0x11401140},
+    {0x00000537, 0x00000000},
+    {0x00000538, 0x0000005B},
+    {0x0000053A, 0x11401140},
+    {0x0000053B, 0x00000000},
+    {0x0000053C, 0x00000093},
+    {0x0000053E, 0x11401140},
+    {0x0000053F, 0x00000000},
+#ifdef __BIG_ENDIAN
+    {0x00000540, 0x0308A01C},
+#else
+    {0x00000540, 0x0300A01C},
+#endif
+    {0x00000542, 0x11401140},
+    {0x00000543, 0x00000000}
+};
+static unsigned nv10TablePRAMIN_8BPP[][2] =
+{
+    /*           0xXXXXXX01 For  MSB mono format */
+    /*           0xXXXXXX02 For  LSB mono format */
+    {0x00000509, 0x00000302},
+    {0x0000050D, 0x00000302},
+    {0x00000511, 0x00000202},
+    {0x00000515, 0x00000302},
+    {0x00000519, 0x00000302},
+    {0x0000051D, 0x00000302},
+    {0x0000052D, 0x00000302},
+    {0x0000052E, 0x00000302},
+    {0x00000535, 0x00000000},
+    {0x00000539, 0x00000000},
+    {0x0000053D, 0x00000000},
+    {0x00000541, 0x00000302}
+};
+static unsigned nv10TablePRAMIN_15BPP[][2] =
+{
+    /*           0xXXXXXX01 For  MSB mono format */
+    /*           0xXXXXXX02 For  LSB mono format */
+    {0x00000509, 0x00000902},
+    {0x0000050D, 0x00000902},
+    {0x00000511, 0x00000802},
+    {0x00000515, 0x00000902},
+    {0x00000519, 0x00000902},
+    {0x0000051D, 0x00000902},
+    {0x0000052D, 0x00000902},
+    {0x0000052E, 0x00000902},
+    {0x00000535, 0x00000902},
+    {0x00000539, 0x00000902}, 
+    {0x0000053D, 0x00000902},
+    {0x00000541, 0x00000902}
+};
+static unsigned nv10TablePRAMIN_16BPP[][2] =
+{
+    /*           0xXXXXXX01 For  MSB mono format */
+    /*           0xXXXXXX02 For  LSB mono format */
+    {0x00000509, 0x00000C02},
+    {0x0000050D, 0x00000C02},
+    {0x00000511, 0x00000B02},
+    {0x00000515, 0x00000C02},
+    {0x00000519, 0x00000C02},
+    {0x0000051D, 0x00000C02},
+    {0x0000052D, 0x00000C02},
+    {0x0000052E, 0x00000C02},
+    {0x00000535, 0x00000C02},
+    {0x00000539, 0x00000C02},
+    {0x0000053D, 0x00000C02},
+    {0x00000541, 0x00000C02}
+};
+static unsigned nv10TablePRAMIN_32BPP[][2] =
+{
+    /*           0xXXXXXX01 For  MSB mono format */
+    /*           0xXXXXXX02 For  LSB mono format */
+    {0x00000509, 0x00000E02},
+    {0x0000050D, 0x00000E02},
+    {0x00000511, 0x00000D02},
+    {0x00000515, 0x00000E02},
+    {0x00000519, 0x00000E02},
+    {0x0000051D, 0x00000E02},
+    {0x0000052D, 0x00000E02},
+    {0x0000052E, 0x00000E02},
+    {0x00000535, 0x00000E02},
+    {0x00000539, 0x00000E02},
+    {0x0000053D, 0x00000E02},
+    {0x00000541, 0x00000E02}
+};
+
diff -uprN a/drivers/video/xbox/xboxfb.h b/drivers/video/xbox/xboxfb.h
--- a/drivers/video/xbox/xboxfb.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/xboxfb.h	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,75 @@
+#ifndef __XBOXFB_H
+#define __XBOXFB_H
+
+#include <linux/fb.h>
+#include <video/vga.h>
+#include "riva_hw.h"
+#include <linux/xboxfbctl.h>
+
+/* GGI compatibility macros */
+#define NUM_SEQ_REGS		0x05
+#define NUM_CRT_REGS		0x41
+#define NUM_GRC_REGS		0x09
+#define NUM_ATC_REGS		0x15
+
+#define NUM_CONEXANT_REGS	0x69
+#define NUM_FOCUS_REGS 	    0xff
+#define MAX_ENCODER_REGS    0xff
+
+/* holds the state of the VGA core and extended Riva hw state from riva_hw.c.
+ * From KGI originally. */
+struct riva_regs {
+	u8 attr[NUM_ATC_REGS];
+	u8 crtc[NUM_CRT_REGS];
+	u8 gra[NUM_GRC_REGS];
+	u8 seq[NUM_SEQ_REGS];
+	u8 misc_output;
+	RIVA_HW_STATE ext;
+	void *encoder_regs;
+};
+
+struct riva_par {
+	RIVA_HW_INST riva;	/* interface to riva_hw.c */
+	u32 pseudo_palette[16]; /* default palette */
+	u32 palette[16];        /* for Riva128 */
+	u8 __iomem *ctrl_base;	/* virtual control register base addr */
+	unsigned dclk_max;	/* max DCLK */
+
+	struct riva_regs initial_state;	/* initial startup video mode */
+	struct riva_regs current_state;
+	struct vgastate state;
+	atomic_t ref_count;
+	u32 cursor_data[32 * 32/4];
+	unsigned char *EDID;
+
+	int panel_xres, panel_yres;
+	int hOver_plus, hSync_width, hblank;
+	int vOver_plus, vSync_width, vblank;
+	int hAct_high, vAct_high, interlaced;
+	int synct, misc, clock;
+
+	int use_default_var;
+	int got_dfpinfo;
+	unsigned int Chipset;
+	int forceCRTC;
+	Bool SecondCRTC;
+	int FlatPanel;
+	struct pci_dev *pdev;
+	int bus;
+	int cursor_reset;
+#ifdef CONFIG_MTRR
+	struct { int vram; int vram_valid; } mtrr;
+#endif
+	unsigned riva_fb_start; /* start address of fb in riva address space */
+	xbox_tv_encoding tv_encoding;
+	xbox_av_type av_type;
+	xbox_encoder_type video_encoder;
+	double hoc;
+	double voc;
+};
+
+void riva_common_setup(struct riva_par *);
+unsigned long riva_get_memlen(struct riva_par *);
+unsigned long riva_get_maxdclk(struct riva_par *);
+
+#endif /* __XBOXFB_H */
diff -uprN a/drivers/video/xbox/xcalibur-regs.h b/drivers/video/xbox/xcalibur-regs.h
--- a/drivers/video/xbox/xcalibur-regs.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/xcalibur-regs.h	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,121 @@
+#ifndef _XCALIBUR_REGS_H_
+#define _XCALIBUR_REGS_H_
+#include "xcalibur.h"
+
+const u32 Composite_XCal_Vals_PAL[] = {
+	0x02000000, 0x36005003, 0x00000000, 0x00000000,
+	0x04000000, 0x0be58a21, 0x7789c500, 0x10000003,
+	0xffffffff, 0x00000000, 0x00000000, 0xffffffff,
+	0x0f000000, 0x00000000, 0xffffffff, 0x01000000,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x03000000, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0xffffffff, 0xffffffff, 0xffffffff, 0x04000000,
+	0xfd000c00, 0xe7013b00, 0xf1000000, 0xfb010300,
+	0xfc000f00, 0xd9018600, 0xcb00df01, 0x0900fe00,
+	0xfe000900, 0xdf01ca00, 0x8700d901, 0x0f00fc00,
+	0x0300fb01, 0x0000f000, 0x3c00e701, 0x0b00fe00,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x04000000, 0x0a0d0210,
+	0x1b230000, 0x04000000, 0x046e5578, 0x41417855,
+	0x6e040000, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x71820003, 0x2ebc0024, 0x48000028, 0xffffffff,
+	0x08022003, 0x279c101e, 0x60000028, 0xffffffff,
+	0x10808000, 0xf0000000, 0xac050000, 0x02200000,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x12029281, 0x69cac800, 0x57d00401, 0x51d01c01,
+	0x47d04401, 0x41d05c01, 0x32caa401, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x00000000, 0x00000000, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x0c000000, 0x0f000000, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+};
+
+const u32 Composite_XCal_Vals_NTSC[] = {
+	0x02000000, 0x10804003, 0x00000000, 0x00000000,
+	0x04000000, 0xea528255, 0x24c5eb00, 0x00000303,
+	0xffffffff, 0x00000000, 0x00000000, 0xffffffff,
+	0x0f000000, 0x00000000, 0xffffffff, 0x01000000,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x03000000, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0xffffffff, 0xffffffff, 0xffffffff, 0x04000000,
+	0xfe000a00, 0xe9013700, 0xe4000000, 0xfb010300,
+	0xfc000f00, 0xdb017e00, 0xc000e101, 0x0800ff00,
+	0xfd000900, 0xe101be00, 0x8000db01, 0x0e00fc00,
+	0x0300fc01, 0x0000e200, 0x3900e801, 0x0b00fe00,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x04000000, 0x0a0d0210,
+	0x1b230000, 0x04000000, 0x38656108, 0x3a3a0861,
+	0x65380000, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x0d820c03, 0x27a0001e, 0x49000028, 0xffffffff,
+	0x0d020c03, 0x2698101e, 0x60000028, 0xffffffff,
+	0x10808000, 0xf0000000, 0x8c000000, 0x01100000,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x10004101, 0x24709000, 0x24709000, 0x24709000,
+	0x24709000, 0x24709000, 0x24709000, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x00000000, 0x00000000, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x05000000, 0x0f000000, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+};
+
+const u32 HDTV_XCal_Vals_480p[] = {
+	0x02000000, 0x30004000, 0x00000000, 0x00000000,
+	0x08000000, 0xa6c08324, 0xcf6f4600, 0x00000000,
+	0xffffffff, 0x00000000, 0x00000000, 0xffffffff,
+	0x0f000000, 0x00000000, 0xffffffff, 0x01000000,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x00000000, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x00000000, 0x00000000, 0x00000000, 0x01000000,
+	0xffffffff, 0xffffffff, 0xffffffff, 0x04000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0xfb001000, 0xdb016000, 0xe900e801,
+	0x01000200, 0x02000300, 0xe801e700, 0x6200da01,
+	0x1000fb00, 0x00000000, 0xfc000e00, 0xe0015100,
+	0xc600ec01, 0x01000200, 0x02000200, 0xec01c500,
+	0x5200e001, 0x0e00fc00, 0x04000000, 0x00000000,
+	0x00000000, 0x04000000, 0x00000000, 0x00000000,
+	0x00000000, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x0d020c03, 0x2594001e, 0x1c000028, 0xffffffff,
+	0x0d020c03, 0x2594001e, 0x60000028, 0xffffffff,
+	0x10808000, 0xf0000000, 0x4c000000, 0x0dd22000,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x10000001, 0x20808000, 0x20808000, 0x20808000,
+	0x20808000, 0x20808000, 0x20808000, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x00000000, 0x00000000, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0x05000000, 0x0f000000, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+	0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
+};
+#endif
diff -uprN a/drivers/video/xbox/xcalibur.c b/drivers/video/xbox/xcalibur.c
--- a/drivers/video/xbox/xcalibur.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/xcalibur.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,72 @@
+/*
+ * linux/drivers/video/xbox/xcalibur.c - Xbox driver for Xcalibur encoder
+ *
+ * Maintainer: David Pye (dmp) <dmp@davidmpye.dyndns.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * Known bugs and issues:
+ * Overscanned composite and svideo, 480p component only.
+ *
+*/
+#include "xcalibur.h"
+#include "xcalibur-regs.h"
+#include "encoder.h"
+
+int xcalibur_calc_hdtv_mode(
+	xbox_hdtv_mode hdtv_mode,
+	int dotClock,
+	void **regs
+	){
+	*regs = kmalloc(0x90*sizeof(char)*4, GFP_KERNEL);
+	//Only 480p so far, sorry!
+	memcpy(*regs,&HDTV_XCal_Vals_480p[0],0x90*sizeof(char)*4);	
+	return 1;
+}
+
+int xcalibur_calc_mode(xbox_video_mode * mode, struct riva_regs * riva_out)
+{
+	//These registers consist of 4 bytes per address.
+	riva_out->encoder_regs = kmalloc(0x90*sizeof(char)*4, GFP_KERNEL);
+	
+	//Syncs.
+	switch(mode->tv_encoding) {
+		case TV_ENC_PALBDGHI:
+			memcpy(riva_out->encoder_regs,&Composite_XCal_Vals_PAL[0],0x90*sizeof(char)*4);
+			riva_out->ext.vsyncstart = 481;
+			riva_out->ext.hsyncstart = 703;
+			riva_out->ext.htotal = 800 - 1;
+			riva_out->ext.vtotal = 520 - 1;
+			break;
+			
+		case TV_ENC_NTSC:
+		default: // Default to NTSC
+			memcpy(riva_out->encoder_regs,&Composite_XCal_Vals_NTSC[0],0x90*sizeof(char)*4);
+			riva_out->ext.vsyncstart = 487;
+			riva_out->ext.hsyncstart = 683;
+			riva_out->ext.htotal = 780 - 1;
+			riva_out->ext.vtotal = 525 - 1;
+			break;
+	}
+		
+	riva_out->ext.width = mode->xres;
+	riva_out->ext.height = mode->yres;
+	riva_out->ext.vcrtc = mode->yres - 1;
+	riva_out->ext.vend = mode->yres - 1;
+	riva_out->ext.vsyncend = riva_out->ext.vsyncstart + 3;
+	riva_out->ext.vvalidstart = 0;
+	riva_out->ext.vvalidend = mode->yres - 1;
+	riva_out->ext.hend = mode->xres + 7 ;
+	riva_out->ext.hcrtc = mode->xres - 1;
+	riva_out->ext.hsyncend = riva_out->ext.hsyncstart + 32;
+	riva_out->ext.hvalidstart = 0;
+	riva_out->ext.hvalidend = mode->xres - 1;
+	riva_out->ext.crtchdispend = mode->xres;
+	riva_out->ext.crtcvstart = mode->yres + 32;
+	//increased from 32
+	riva_out->ext.crtcvtotal = mode->yres + 64;
+	
+	return 1;
+}
diff -uprN a/drivers/video/xbox/xcalibur.h b/drivers/video/xbox/xcalibur.h
--- a/drivers/video/xbox/xcalibur.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/video/xbox/xcalibur.h	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,25 @@
+/*
+ * linux/drivers/video/xbox/xcalibur.c - Xbox driver for Xcalibur encoder
+ *
+ * Maintainer: David Pye (dmp) <dmp@davidmpye.dyndns.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * Known bugs and issues:
+ *
+ * none
+ */
+
+
+#ifndef XCALIBUR_H_
+#define XCALIBUR_H_
+
+#include <linux/slab.h>
+#include "encoder.h"
+#include "xboxfb.h"
+
+int xcalibur_calc_mode(xbox_video_mode * mode, struct riva_regs * riva_out);
+int xcalibur_calc_hdtv_mode(xbox_hdtv_mode hdtv_mode, int dotClock, void **encoder_regs);
+#endif
diff -uprN a/fs/Kconfig b/fs/Kconfig
--- a/fs/Kconfig	2007-09-23 18:33:00.000000000 +0100
+++ b/fs/Kconfig	2007-10-12 11:17:00.000000000 +0100
@@ -796,6 +796,32 @@ config FAT_DEFAULT_IOCHARSET
 	  If unsure, you shouldn't set "utf8" here.
 	  See <file:Documentation/filesystems/vfat.txt> for more information.
 
+config FATX_FS
+	tristate "FATX fs support (DANGEROUS)"
+	depends on EXPERIMENTAL
+	help
+	  This adds support for the FATX filesystem as found in Microsoft's Xbox.
+
+	  The FATX filesystem is a derivative of the FAT filesystem minus some
+	  legacy fields and redundant information. For lengthier discussions on
+	  the filesystem, see:
+
+	  <http://xbox-linux.sourceforge.net/docs/fatxfat.html>
+	  <http://xbox-linux.sourceforge.net/docs/hdpartfs.html>
+	  <http://xbox-linux.sourceforge.net/docs/hackingfatx.html>
+
+	  # Uncomment this once things actually stabilize:
+	  #
+	  # If you are running Linux on the Xbox, choose Y unless you know
+	  # what you're doing. Otherwise, choose N.
+
+	  NOTE: Support for this filesystem is currently in a fragile state.
+	  Expect filesystem corruption and other such nastiness. Only choose
+	  this option if you know what to expect (or not, thereof).
+
+	  To compile this filesystem support as a module, choose M here: the
+	  module will be called fatx.
+
 config NTFS_FS
 	tristate "NTFS file system support"
 	select NLS
diff -uprN a/fs/Makefile b/fs/Makefile
--- a/fs/Makefile	2007-07-09 00:32:17.000000000 +0100
+++ b/fs/Makefile	2007-10-12 11:17:00.000000000 +0100
@@ -79,6 +79,7 @@ obj-$(CONFIG_MINIX_FS)		+= minix/
 obj-$(CONFIG_FAT_FS)		+= fat/
 obj-$(CONFIG_MSDOS_FS)		+= msdos/
 obj-$(CONFIG_VFAT_FS)		+= vfat/
+obj-$(CONFIG_FATX_FS)		+= fatx/
 obj-$(CONFIG_BFS_FS)		+= bfs/
 obj-$(CONFIG_ISO9660_FS)	+= isofs/
 obj-$(CONFIG_HFSPLUS_FS)	+= hfsplus/ # Before hfs to find wrapped HFS+
diff -uprN a/fs/fatx/Makefile b/fs/fatx/Makefile
--- a/fs/fatx/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/fs/fatx/Makefile	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,7 @@
+#
+# Makefile for the Linux fatx filesystem support.
+#
+
+obj-$(CONFIG_FATX_FS) += fatx.o
+
+fatx-objs := cache.o dir.o fatent.o file.o inode.o misc.o namei.o
diff -uprN a/fs/fatx/cache.c b/fs/fatx/cache.c
--- a/fs/fatx/cache.c	1970-01-01 01:00:00.000000000 +0100
+++ b/fs/fatx/cache.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,327 @@
+/*
+ *  linux/fs/fatx/cache.c
+ *
+ *  Written 1992,1993 by Werner Almesberger
+ *
+ *  FATX port 2005 by Edgar Hucek
+ *
+ *  Mar 1999. AV. Changed cache, so that it uses the starting cluster instead
+ *	of inode number.
+ *  May 1999. AV. Fixed the bogosity with FAT32 (read "FAT28"). Fscking lusers.
+ */
+
+#include <linux/fs.h>
+#include <linux/fatx_fs.h>
+#include <linux/buffer_head.h>
+
+#define PRINTK(format, args...) do { if (fatx_debug) printk( format, ##args ); } while(0)
+
+/* this must be > 0. */
+#define FAT_MAX_CACHE	8
+
+struct fatx_cache {
+	struct list_head cache_list;
+	int nr_contig;	/* number of contiguous clusters */
+	int fcluster;	/* cluster number in the file. */
+	int dcluster;	/* cluster number on disk. */
+};
+
+struct fatx_cache_id {
+	unsigned int id;
+	int nr_contig;
+	int fcluster;
+	int dcluster;
+};
+
+static inline int fatx_max_cache(struct inode *inode)
+{
+	return FAT_MAX_CACHE;
+}
+
+static struct kmem_cache *fatx_cache_cachep;
+
+static void init_once(void *foo, struct kmem_cache *cachep, unsigned long flags)
+{
+	struct fatx_cache *cache = (struct fatx_cache *)foo;
+	INIT_LIST_HEAD(&cache->cache_list);
+}
+
+int __init fatx_cache_init(void)
+{
+	fatx_cache_cachep = kmem_cache_create("fatx_cache",
+				sizeof(struct fatx_cache),
+				0, SLAB_RECLAIM_ACCOUNT,
+				init_once, NULL);
+	if (fatx_cache_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+void __exit fatx_cache_destroy(void)
+{
+	kmem_cache_destroy(fatx_cache_cachep);
+}
+
+static inline struct fatx_cache *fatx_cache_alloc(struct inode *inode)
+{
+	return kmem_cache_alloc(fatx_cache_cachep, GFP_KERNEL);
+}
+
+static inline void fatx_cache_free(struct fatx_cache *cache)
+{
+	BUG_ON(!list_empty(&cache->cache_list));
+	kmem_cache_free(fatx_cache_cachep, cache);
+}
+
+static inline void fatx_cache_update_lru(struct inode *inode,
+					struct fatx_cache *cache)
+{
+	if (FATX_I(inode)->cache_lru.next != &cache->cache_list)
+		list_move(&cache->cache_list, &FATX_I(inode)->cache_lru);
+}
+
+static int fatx_cache_lookup(struct inode *inode, int fclus,
+			    struct fatx_cache_id *cid,
+			    int *cached_fclus, int *cached_dclus)
+{
+	static struct fatx_cache nohit = { .fcluster = 0, };
+
+	struct fatx_cache *hit = &nohit, *p;
+	int offset = -1;
+
+	spin_lock(&FATX_I(inode)->cache_lru_lock);
+	list_for_each_entry(p, &FATX_I(inode)->cache_lru, cache_list) {
+		/* Find the cache of "fclus" or nearest cache. */
+		if (p->fcluster <= fclus && hit->fcluster < p->fcluster) {
+			hit = p;
+			if ((hit->fcluster + hit->nr_contig) < fclus) {
+				offset = hit->nr_contig;
+			} else {
+				offset = fclus - hit->fcluster;
+				break;
+			}
+		}
+	}
+	if (hit != &nohit) {
+		fatx_cache_update_lru(inode, hit);
+
+		cid->id = FATX_I(inode)->cache_valid_id;
+		cid->nr_contig = hit->nr_contig;
+		cid->fcluster = hit->fcluster;
+		cid->dcluster = hit->dcluster;
+		*cached_fclus = cid->fcluster + offset;
+		*cached_dclus = cid->dcluster + offset;
+	}
+	spin_unlock(&FATX_I(inode)->cache_lru_lock);
+
+	return offset;
+}
+
+static struct fatx_cache *fatx_cache_merge(struct inode *inode,
+					 struct fatx_cache_id *new)
+{
+	struct fatx_cache *p;
+
+	list_for_each_entry(p, &FATX_I(inode)->cache_lru, cache_list) {
+		/* Find the same part as "new" in cluster-chain. */
+		if (p->fcluster == new->fcluster) {
+			BUG_ON(p->dcluster != new->dcluster);
+			if (new->nr_contig > p->nr_contig)
+				p->nr_contig = new->nr_contig;
+			return p;
+		}
+	}
+	return NULL;
+}
+
+static void fatx_cache_add(struct inode *inode, struct fatx_cache_id *new)
+{
+	struct fatx_cache *cache, *tmp;
+
+	if (new->fcluster == -1) /* dummy cache */
+		return;
+
+	spin_lock(&FATX_I(inode)->cache_lru_lock);
+	if (new->id != FAT_CACHE_VALID &&
+	    new->id != FATX_I(inode)->cache_valid_id)
+		goto out;	/* this cache was invalidated */
+
+	cache = fatx_cache_merge(inode, new);
+	if (cache == NULL) {
+		if (FATX_I(inode)->nr_caches < fatx_max_cache(inode)) {
+			FATX_I(inode)->nr_caches++;
+			spin_unlock(&FATX_I(inode)->cache_lru_lock);
+
+			tmp = fatx_cache_alloc(inode);
+			spin_lock(&FATX_I(inode)->cache_lru_lock);
+			cache = fatx_cache_merge(inode, new);
+			if (cache != NULL) {
+				FATX_I(inode)->nr_caches--;
+				fatx_cache_free(tmp);
+				goto out_update_lru;
+			}
+			cache = tmp;
+		} else {
+			struct list_head *p = FATX_I(inode)->cache_lru.prev;
+			cache = list_entry(p, struct fatx_cache, cache_list);
+		}
+		cache->fcluster = new->fcluster;
+		cache->dcluster = new->dcluster;
+		cache->nr_contig = new->nr_contig;
+	}
+out_update_lru:
+	fatx_cache_update_lru(inode, cache);
+out:
+	spin_unlock(&FATX_I(inode)->cache_lru_lock);
+}
+
+/*
+ * Cache invalidation occurs rarely, thus the LRU chain is not updated. It
+ * fixes itself after a while.
+ */
+static void __fatx_cache_inval_inode(struct inode *inode)
+{
+	struct fatx_inode_info *i = FATX_I(inode);
+	struct fatx_cache *cache;
+
+	while (!list_empty(&i->cache_lru)) {
+		cache = list_entry(i->cache_lru.next, struct fatx_cache, cache_list);
+		list_del_init(&cache->cache_list);
+		i->nr_caches--;
+		fatx_cache_free(cache);
+	}
+	/* Update. The copy of caches before this id is discarded. */
+	i->cache_valid_id++;
+	if (i->cache_valid_id == FAT_CACHE_VALID)
+		i->cache_valid_id++;
+}
+
+void fatx_cache_inval_inode(struct inode *inode)
+{
+	spin_lock(&FATX_I(inode)->cache_lru_lock);
+	__fatx_cache_inval_inode(inode);
+	spin_unlock(&FATX_I(inode)->cache_lru_lock);
+}
+
+static inline int cache_contiguous(struct fatx_cache_id *cid, int dclus)
+{
+	cid->nr_contig++;
+	return ((cid->dcluster + cid->nr_contig) == dclus);
+}
+
+static inline void cache_init(struct fatx_cache_id *cid, int fclus, int dclus)
+{
+	cid->id = FAT_CACHE_VALID;
+	cid->fcluster = fclus;
+	cid->dcluster = dclus;
+	cid->nr_contig = 0;
+}
+
+__s64 fatx_get_cluster(struct inode *inode, __s64 cluster, int *fclus, int *dclus)
+{
+	struct super_block *sb = inode->i_sb;
+	//const int limit = sb->s_maxbytes >> FATX_SB(sb)->cluster_bits;
+	const int limit = FATX_SB(sb)->max_cluster;
+	struct fatx_entry fatxent;
+	struct fatx_cache_id cid;
+	__s64 nr;
+
+	BUG_ON(FATX_I(inode)->i_start == 0);
+
+	*fclus = 0;
+	*dclus = FATX_I(inode)->i_start;
+	if (cluster == 0)
+		return 0;
+
+	if (fatx_cache_lookup(inode, cluster, &cid, fclus, dclus) < 0) {
+		/*
+		 * dummy, always not contiguous
+		 * This is reinitialized by cache_init(), later.
+		 */
+		cache_init(&cid, -1, -1);
+	}
+
+	fatxent_init(&fatxent);
+	PRINTK("FATX: %s fclus 0x%08x cluster 0x%08llx\n", __FUNCTION__, *fclus, cluster);
+	while (*fclus < cluster) {
+		/* prevent the infinite loop of cluster chain */
+		if (*fclus > limit) {
+			fatx_fs_panic(sb, "%s: detected the cluster chain loop"
+				     " (i_pos %lld)", __FUNCTION__,
+				     FATX_I(inode)->i_pos);
+			nr = -EIO;
+			goto out;
+		}
+
+		nr = fatx_ent_read(inode, &fatxent, *dclus);
+		if (nr < 0)
+			goto out;
+		else if (nr == FAT_ENT_FREE) {
+			fatx_fs_panic(sb, "%s: invalid cluster chain"
+				     " (i_pos %lld)", __FUNCTION__,
+				     FATX_I(inode)->i_pos);
+			nr = -EIO;
+			goto out;
+		} else if (nr == FAT_ENT_EOF) {
+			fatx_cache_add(inode, &cid);
+			goto out;
+		}
+		(*fclus)++;
+		*dclus = nr;
+		if (!cache_contiguous(&cid, *dclus))
+			cache_init(&cid, *fclus, *dclus);
+	}
+	nr = 0;
+	fatx_cache_add(inode, &cid);
+out:
+	fatxent_brelse(&fatxent);
+	return nr;
+}
+
+static __s64 fatx_bmap_cluster(struct inode *inode, __s64 cluster)
+{
+	struct super_block *sb = inode->i_sb;
+	__s64 ret;
+	int fclus, dclus;
+
+	if (FATX_I(inode)->i_start == 0)
+		return 0;
+
+	ret = fatx_get_cluster(inode, cluster, &fclus, &dclus);
+	if (ret < 0)
+		return ret;
+	else if (ret == FAT_ENT_EOF) {
+		fatx_fs_panic(sb, "%s: request beyond EOF (i_pos %lld ret 0x%08llx fclus 0x%08x dclus 0x%08x)",
+			     __FUNCTION__, FATX_I(inode)->i_pos, ret, fclus, dclus);
+		return -EIO;
+	}
+	return dclus;
+}
+
+int fatx_bmap(struct inode *inode, sector_t sector, sector_t *phys)
+{
+	struct super_block *sb = inode->i_sb;
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+	sector_t last_block;
+	__s64 cluster, offset;
+
+	*phys = 0;
+	if (inode->i_ino == FATX_ROOT_INO) {
+		if (sector < (sbi->dir_entries >> sbi->dir_per_block_bits))
+			*phys = sector + sbi->dir_start;
+		return 0;
+	}
+	last_block = (FATX_I(inode)->mmu_private + (sb->s_blocksize - 1))
+		>> sb->s_blocksize_bits;
+	if (sector >= last_block)
+		return 0;
+
+	cluster = sector >> (sbi->cluster_bits - sb->s_blocksize_bits);
+	offset  = sector & (sbi->sec_per_clus - 1);
+	cluster = fatx_bmap_cluster(inode, cluster);
+	if (cluster < 0)
+		return cluster;
+	else if (cluster)
+		*phys = fatx_clus_to_blknr(sbi, cluster) + offset;
+	return 0;
+}
diff -uprN a/fs/fatx/dir.c b/fs/fatx/dir.c
--- a/fs/fatx/dir.c	1970-01-01 01:00:00.000000000 +0100
+++ b/fs/fatx/dir.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,643 @@
+/*
+ *  linux/fs/fatx/dir.c
+ *
+ *  directory handling functions for fatx-based filesystems
+ *
+ *  Written 1992,1993 by Werner Almesberger
+ *
+ *  Hidden files 1995 by Albert Cahalan <albert@ccs.neu.edu> <adc@coe.neu.edu>
+ *
+ *  VFAT extensions by Gordon Chaffee <chaffee@plateau.cs.berkeley.edu>
+ *  Merged with fatx fs by Henrik Storner <storner@osiris.ping.dk>
+ *  Rewritten for constant inumbers. Plugged buffer overrun in readdir(). AV
+ *  Short name translation 1999, 2001 by Wolfram Pienkoss <wp@bszh.de>
+ *
+ *  FATX port 2005 by Edgar Hucek
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/fatx_fs.h>
+#include <linux/dirent.h>
+#include <linux/smp_lock.h>
+#include <linux/buffer_head.h>
+#include <asm/uaccess.h>
+
+#define PRINTK(format, args...) do { if (fatx_debug) printk( format, ##args ); } while(0)
+
+static inline loff_t fatx_make_i_pos(struct super_block *sb,
+				    struct buffer_head *bh,
+				    struct fatx_dir_entry *de)
+{
+	return ((loff_t)bh->b_blocknr << FATX_SB(sb)->dir_per_block_bits)
+		| (de - (struct fatx_dir_entry *)bh->b_data);
+}
+
+/* Returns the inode number of the directory entry at offset pos. If bh is
+   non-NULL, it is brelse'd before. Pos is incremented. The buffer header is
+   returned in bh.
+   AV. Most often we do it item-by-item. Makes sense to optimize.
+   AV. OK, there we go: if both bh and de are non-NULL we assume that we just
+   AV. want the next entry (took one explicit de=NULL in vfatx/namei.c).
+   AV. It's done in fatx_get_entry() (inlined), here the slow case lives.
+   AV. Additionally, when we return -1 (i.e. reached the end of directory)
+   AV. we make bh NULL.
+ */
+static int fatx__get_entry(struct inode *dir, loff_t *pos,
+			  struct buffer_head **bh, struct fatx_dir_entry **de)
+{
+	struct super_block *sb = dir->i_sb;
+	sector_t phys, iblock;
+	int offset;
+	int err;
+
+next:
+	if (*bh)
+		brelse(*bh);
+
+	*bh = NULL;
+	iblock = *pos >> sb->s_blocksize_bits;
+	err = fatx_bmap(dir, iblock, &phys);
+	if (err || !phys) {
+		PRINTK("FATX: %s fatx_bmap err %d phys %ld iblock %ld\n", 
+			__FUNCTION__, err, phys, iblock);
+		return -1;	/* beyond EOF or error */
+	}
+
+	*bh = sb_bread(sb, phys);
+	if (*bh == NULL) {
+		printk(KERN_ERR "FATX: Directory bread(block %llu) failed\n",
+		       (unsigned long long)phys);
+		/* skip this block */
+		*pos = (iblock + 1) << sb->s_blocksize_bits;
+		goto next;
+	}
+
+	offset = *pos & (sb->s_blocksize - 1);
+	*pos += sizeof(struct fatx_dir_entry);
+	*de = (struct fatx_dir_entry *)((*bh)->b_data + offset);
+
+	return 0;
+}
+
+static inline int fatx_get_entry(struct inode *dir, loff_t *pos,
+				struct buffer_head **bh,
+				struct fatx_dir_entry **de)
+{
+	/* Fast stuff first */
+	if (*bh && *de &&
+	    (*de - (struct fatx_dir_entry *)(*bh)->b_data) < FATX_SB(dir->i_sb)->dir_per_block - 1) {
+		*pos += sizeof(struct fatx_dir_entry);
+		(*de)++;
+		return 0;
+	}
+	return fatx__get_entry(dir, pos, bh, de);
+}
+
+static int fatx_readdir(struct file *filp, void *dirent,
+			filldir_t filldir)
+{
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct super_block *sb = inode->i_sb;
+	struct buffer_head *bh;
+	struct fatx_dir_entry *de;
+	/*
+	unsigned long dummy;
+	*/
+	unsigned long lpos, *furrfu = &lpos;
+	unsigned long inum;
+	loff_t cpos;
+	int ret = 0;
+	loff_t i_pos;
+	struct inode *tmp;
+
+	lock_kernel();
+
+	PRINTK("FATX: %s\n", __FUNCTION__ );
+	cpos = filp->f_pos;
+	/* Fake . and .. for the root directory. */
+	/*
+	if (inode->i_ino == FATX_ROOT_INO) {
+		while (cpos < 2) {
+			if (filldir(dirent, "..", cpos+1, cpos, FATX_ROOT_INO, DT_DIR) < 0)
+				goto out;
+			cpos++;
+			filp->f_pos++;
+		}
+		if (cpos == 2) {
+			dummy = 2;
+			furrfu = &dummy;
+			cpos = 0;
+		}
+	}
+	*/
+	if (cpos & (sizeof(struct fatx_dir_entry)-1)) {
+		ret = -ENOENT;
+		goto out;
+	}
+
+	bh = NULL;
+GetNew:
+	if (fatx_get_entry(inode, &cpos, &bh, &de) == -1)
+		goto EODir;
+	/* Check for long filename entry */
+	if (FATX_IS_FREE(de))
+		goto RecEnd;
+
+	lpos = cpos - sizeof(struct fatx_dir_entry);
+	i_pos = fatx_make_i_pos(sb, bh, de);
+	tmp = fatx_iget(sb, i_pos);
+	if (tmp) {
+		inum = tmp->i_ino;
+		iput(tmp);
+	} else
+		inum = iunique(sb, FATX_ROOT_INO);
+
+	if (filldir(dirent, de->name, de->name_length, *furrfu, inum,
+		    (de->attr & ATTR_DIR) ? DT_DIR : DT_REG) < 0)
+		goto FillFailed;
+
+RecEnd:
+	furrfu = &lpos;
+	filp->f_pos = cpos;
+	goto GetNew;
+EODir:
+	filp->f_pos = cpos;
+FillFailed:
+	if (bh)
+		brelse(bh);
+out:
+	unlock_kernel();
+	return ret;
+}
+
+struct file_operations fatx_dir_operations = {
+	.read		= generic_read_dir,
+	.readdir	= fatx_readdir,
+	.ioctl		= NULL,
+	.fsync		= file_fsync,
+};
+
+static int fatx_get_short_entry(struct inode *dir, loff_t *pos,
+			       struct buffer_head **bh,
+			       struct fatx_dir_entry **de)
+{
+	while (fatx_get_entry(dir, pos, bh, de) >= 0) {
+		if (!FATX_IS_FREE(*de))
+			return 0;
+	}
+	return -ENOENT;
+}
+
+/*
+ * The ".." entry can not provide the "struct fat_slot_info" informations
+ * for inode. So, this function provide the some informations only.
+ */
+/*
+int fatx_get_dotdot_entry(struct inode *dir, struct buffer_head **bh,
+			 struct fatx_dir_entry **de, loff_t *i_pos)
+{
+	loff_t offset;
+
+	offset = 0;
+	*bh = NULL;
+	while (fatx_get_short_entry(dir, &offset, bh, de) >= 0) {
+		if (!strncmp((*de)->name, "..", 2)) {
+			*i_pos = fatx_make_i_pos(dir->i_sb, *bh, *de);
+			return 0;
+		}
+	}
+	return -ENOENT;
+}
+
+EXPORT_SYMBOL(fatx_get_dotdot_entry);
+*/
+
+/* See if directory is empty */
+int fatx_dir_empty(struct inode *dir)
+{
+	struct buffer_head *bh;
+	struct fatx_dir_entry *de;
+	loff_t cpos;
+	int result = 0;
+
+	bh = NULL;
+	cpos = 0;
+	while (fatx_get_entry(dir, &cpos, &bh, &de) >= 0) {
+		if (!FATX_IS_FREE(de)) {
+			result = -ENOTEMPTY;
+			break;
+		}
+	}
+	brelse(bh);
+	return result;
+}
+
+EXPORT_SYMBOL(fatx_dir_empty);
+
+/*
+ * fatx_subdirs counts the number of sub-directories of dir. It can be run
+ * on directories being created.
+ */
+int fatx_subdirs(struct inode *dir)
+{
+	struct buffer_head *bh;
+	struct fatx_dir_entry *de;
+	loff_t cpos;
+	int count = 0;
+
+	bh = NULL;
+	cpos = 0;
+	while (fatx_get_short_entry(dir, &cpos, &bh, &de) >= 0) {
+		if (de->attr & ATTR_DIR)
+			count++;
+	}
+	brelse(bh);
+	return count;
+}
+
+/*
+ * Scans a directory for a given file (name points to its formatted name).
+ * Returns an error code or zero.
+ */
+int fatx_scan(struct inode *dir, const unsigned char *name,
+	     struct fatx_slot_info *sinfo)
+{
+	struct super_block *sb = dir->i_sb;
+
+	sinfo->slot_off = 0;
+	sinfo->bh = NULL;
+	while (fatx_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,
+				   &sinfo->de) >= 0) {
+		if (!strncmp(sinfo->de->name, name, FATX_NAME)) {
+			sinfo->slot_off -= sizeof(*sinfo->de);
+			sinfo->i_pos = fatx_make_i_pos(sb, sinfo->bh, sinfo->de);
+			return 0;
+		}
+	}
+	return -ENOENT;
+}
+
+EXPORT_SYMBOL(fatx_scan);
+
+static int __fatx_remove_entries(struct inode *dir, loff_t pos)
+{
+	struct super_block *sb = dir->i_sb;
+	struct buffer_head *bh;
+	struct fatx_dir_entry *de, *endp;
+	int err = 0;
+
+	bh = NULL;
+	if (fatx_get_entry(dir, &pos, &bh, &de) < 0) {
+		err = -EIO;
+	}
+
+	endp = (struct fatx_dir_entry *)(bh->b_data + sb->s_blocksize);
+	de->name_length = DELETED_FLAG;
+	de++;
+	mark_buffer_dirty(bh);
+	if (IS_DIRSYNC(dir))
+		err = sync_dirty_buffer(bh);
+	brelse(bh);
+
+	return err;
+}
+
+int fatx_remove_entries(struct inode *dir, struct fatx_slot_info *sinfo)
+{
+	struct fatx_dir_entry *de;
+	struct buffer_head *bh;
+	int err = 0;
+
+	/*
+	 * First stage: Remove the shortname. By this, the directory
+	 * entry is removed.
+	 */
+	de = sinfo->de;
+	sinfo->de = NULL;
+	bh = sinfo->bh;
+	sinfo->bh = NULL;
+	de->name_length = DELETED_FLAG;
+	de--;
+	mark_buffer_dirty(bh);
+	if (IS_DIRSYNC(dir))
+		err = sync_dirty_buffer(bh);
+	brelse(bh);
+	if (err)
+		return err;
+	dir->i_version++;
+
+	dir->i_mtime = dir->i_atime = CURRENT_TIME;
+	if (IS_DIRSYNC(dir))
+		(void)fatx_sync_inode(dir);
+	else
+		mark_inode_dirty(dir);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(fatx_remove_entries);
+
+static int fatx_zeroed_cluster(struct inode *dir, sector_t blknr, int nr_used,
+			      struct buffer_head **bhs, int nr_bhs)
+{
+	struct super_block *sb = dir->i_sb;
+	sector_t last_blknr = blknr + FATX_SB(sb)->sec_per_clus;
+	int err, i, n;
+
+	/* Zeroing the unused blockson this cluster */
+	blknr += nr_used;
+	n = nr_used;
+	while (blknr < last_blknr) {
+		bhs[n] = sb_getblk(sb, blknr);
+		if (!bhs[n]) {
+			err = -ENOMEM;
+			goto error;
+		}
+		memset(bhs[n]->b_data, 0xFF, sb->s_blocksize);
+		set_buffer_uptodate(bhs[n]);
+		mark_buffer_dirty(bhs[n]);
+
+		n++;
+		blknr++;
+		if (n == nr_bhs) {
+			if (IS_DIRSYNC(dir)) {
+				err = fatx_sync_bhs(bhs, n);
+				if (err)
+					goto error;
+			}
+			for (i = 0; i < n; i++)
+				brelse(bhs[i]);
+			n = 0;
+		}
+	}
+	if (IS_DIRSYNC(dir)) {
+		err = fatx_sync_bhs(bhs, n);
+		if (err)
+			goto error;
+	}
+	for (i = 0; i < n; i++)
+		brelse(bhs[i]);
+
+	return 0;
+
+error:
+	for (i = 0; i < n; i++)
+		bforget(bhs[i]);
+	return err;
+}
+
+int fatx_alloc_new_dir(struct inode *dir, struct timespec *ts)
+{
+	struct super_block *sb = dir->i_sb;
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+	struct buffer_head *bhs[MAX_BUF_PER_PAGE];
+	struct fatx_dir_entry *de;
+	sector_t blknr;
+	__le16 date, time;
+	__s64 err, cluster;
+
+	err = fatx_alloc_clusters(dir, &cluster, 1);
+	if (err) {
+		PRINTK("FATX: %s fatx_alloc_clusters failed\n", __FUNCTION__);
+		goto error;
+	}
+
+	blknr = fatx_clus_to_blknr(sbi, cluster);
+	bhs[0] = sb_getblk(sb, blknr);
+	if (!bhs[0]) {
+		err = -ENOMEM;
+		goto error_free;
+	}
+
+	fatx_date_unix2dos(ts->tv_sec, &time, &date);
+
+	de = (struct fatx_dir_entry *)bhs[0]->b_data;
+	/* filling the new directory slots ("." and ".." entries) */
+	de->attr = de[1].attr = ATTR_DIR;
+	de[0].name_length = 0xFF; //end of dir marker
+	de[0].start = cpu_to_le32(cluster);
+	de[1].start = cpu_to_le32(FATX_I(dir)->i_logstart);
+	de[0].time = de[1].time = time;
+	de[0].date = de[1].date = date;
+	de[0].ctime = de[1].ctime = 0;
+	de[0].adate = de[0].cdate = de[1].adate = de[1].cdate = 0;
+	de[0].size = de[1].size = 0;
+	memset(de, 0xFF, sb->s_blocksize);
+	set_buffer_uptodate(bhs[0]);
+	mark_buffer_dirty(bhs[0]);
+
+	err = fatx_zeroed_cluster(dir, blknr, 1, bhs, MAX_BUF_PER_PAGE);
+	if (err) {
+		PRINTK("FATX: %s fatx_zeroed_cluster failed\n", __FUNCTION__);
+		goto error_free;
+	}
+
+	return cluster;
+
+error_free:
+	fatx_free_clusters(dir, cluster);
+error:
+	return err;
+}
+
+EXPORT_SYMBOL(fatx_alloc_new_dir);
+
+static int fatx_add_new_entries(struct inode *dir, void *slots, int *nr_cluster, 
+			       struct fatx_dir_entry **de,
+			       struct buffer_head **bh, loff_t *i_pos)
+{
+	struct super_block *sb = dir->i_sb;
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+	struct buffer_head *bhs[MAX_BUF_PER_PAGE];
+	sector_t blknr, start_blknr, last_blknr;
+	unsigned long size, copy;
+	int i, n, offset;
+	__s64 err, cluster[2];
+
+	PRINTK("FATX: %s\n", __FUNCTION__);
+	/*
+	 * The minimum cluster size is 512bytes, and maximum entry
+	 * size is 32*slots (672bytes).  So, iff the cluster size is
+	 * 512bytes, we may need two clusters.
+	 */
+	size = sizeof(struct fatx_dir_entry);
+	*nr_cluster = (size + (sbi->cluster_size - 1)) >> sbi->cluster_bits;
+	BUG_ON(*nr_cluster > 2);
+
+	err = fatx_alloc_clusters(dir, cluster, *nr_cluster);
+	PRINTK("FATX: %s fatx_alloc_clusters cluster %lld nr_cluster %d\n", 
+			__FUNCTION__, cluster[0], *nr_cluster);
+	if (err) {
+		goto error;
+	}
+
+	/*
+	 * First stage: Fill the directory entry.  NOTE: This cluster
+	 * is not referenced from any inode yet, so updates order is
+	 * not important.
+	 */
+	i = n = copy = 0;
+	do {
+		start_blknr = blknr = fatx_clus_to_blknr(sbi, cluster[i]);
+		last_blknr = start_blknr + sbi->sec_per_clus;
+		while (blknr < last_blknr) {
+			bhs[n] = sb_getblk(sb, blknr);
+			if (!bhs[n]) {
+				err = -ENOMEM;
+				goto error_nomem;
+			}
+
+			/* fill the directory entry */
+			copy = min(size, sb->s_blocksize);
+			memcpy(bhs[n]->b_data, slots, copy);
+			slots += copy;
+			size -= copy;
+			set_buffer_uptodate(bhs[n]);
+			mark_buffer_dirty(bhs[n]);
+			if (!size)
+				break;
+			n++;
+			blknr++;
+		}
+	} while (++i < *nr_cluster);
+
+	memset(bhs[n]->b_data + copy, 0xFF, sb->s_blocksize - copy);
+	offset = copy - sizeof(struct fatx_dir_entry);
+	get_bh(bhs[n]);
+	*bh = bhs[n];
+	*de = (struct fatx_dir_entry *)((*bh)->b_data + offset);
+	*i_pos = fatx_make_i_pos(sb, *bh, *de);
+
+	/* Second stage: clear the rest of cluster, and write outs */
+	err = fatx_zeroed_cluster(dir, start_blknr, ++n, bhs, MAX_BUF_PER_PAGE);
+	if (err)
+		goto error_free;
+
+	return cluster[0];
+
+error_free:
+	brelse(*bh);
+	*bh = NULL;
+	n = 0;
+error_nomem:
+	for (i = 0; i < n; i++)
+		bforget(bhs[i]);
+	fatx_free_clusters(dir, cluster[0]);
+error:
+	return err;
+}
+
+int fatx_add_entries(struct inode *dir, void *slots, 
+		     struct fatx_slot_info *sinfo)
+{
+	struct super_block *sb = dir->i_sb;
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+	struct buffer_head *bh, *prev;
+	struct fatx_dir_entry *de;
+	__s64 err;
+	loff_t pos, i_pos;
+	int size, free_slots, nr_slots, cluster, nr_cluster, copy;
+	loff_t offset;
+	
+	struct fatx_dir_entry *de1 = (struct fatx_dir_entry *)slots;
+	PRINTK("FATX: %s entryname : ", __FUNCTION__ );
+	if(fatx_debug) fatx_printname(de1->name, de1->name_length);
+	PRINTK("\n");
+
+	/* First stage: search free direcotry entries */
+	free_slots = 0;
+	nr_slots = 1;
+	bh = prev = NULL;
+	offset = pos = 0;
+	err = -ENOSPC;
+	while (fatx_get_entry(dir, &pos, &bh, &de) > -1) {
+		// Root dir can only have 256 entries
+		if(pos >= FATX_MAX_DIR_SIZE && dir->i_ino == FATX_ROOT_INO)
+			goto error;
+		if (FATX_IS_FREE(de)) {
+			if (prev != bh) {
+				get_bh(bh);
+				prev = bh;
+			}
+			free_slots++;
+			goto found;
+		} else {
+//			brelse(bh);
+			prev = NULL;
+			free_slots =  0;
+		}
+	}
+	if (dir->i_ino == FATX_ROOT_INO) {
+		err = -ENOSPC;
+		goto error;
+	}  else if (FATX_I(dir)->i_start == 0) {
+		printk(KERN_ERR "FATX: Corrupted directory (i_pos %lld)\n",
+		       FATX_I(dir)->i_pos);
+		err = -EIO;
+		goto error;
+	}
+found:
+	err = 0;
+	pos -= sizeof(*de);
+	nr_slots -= free_slots;
+	if(free_slots) {
+		size = sizeof(*de);
+		offset = pos & (sb->s_blocksize - 1);
+		copy = min_t(int, sb->s_blocksize - offset, size);
+
+		PRINTK("FATX: %s pos %lld size %d offset %lld copy %d\n", __FUNCTION__, pos, size, offset, copy);
+		memcpy(bh->b_data + offset, slots, copy);
+		mark_buffer_dirty(bh);
+		if (IS_DIRSYNC(dir))
+			err = sync_dirty_buffer(bh);
+		if(err)
+			goto error_remove;
+		brelse(bh);
+	}
+
+	if(nr_slots) {
+		/*
+		 * Third stage: allocate the cluster for new entries.
+		 * And initialize the cluster with new entries, then
+		 * add the cluster to dir.
+		 */
+		cluster = fatx_add_new_entries(dir, slots, &nr_cluster, &de, &bh, &i_pos);
+		if (cluster < 0) {
+			err = cluster;
+			goto error;
+		}
+		PRINTK("FATX: %s fatx_chain_add cluster %d nr_cluster %d\n", __FUNCTION__, cluster, nr_cluster);
+		err = fatx_chain_add(dir, cluster, nr_cluster);
+		if (err) {
+			fatx_free_clusters(dir, cluster);
+			goto error;
+		}
+		if (dir->i_size & (sbi->cluster_size - 1)) {
+			fatx_fs_panic(sb, "Odd directory size");
+			dir->i_size = (dir->i_size + sbi->cluster_size - 1)
+				& ~((loff_t)sbi->cluster_size - 1);
+		}
+		dir->i_size += nr_cluster << sbi->cluster_bits;
+		FATX_I(dir)->mmu_private += nr_cluster << sbi->cluster_bits;
+	}
+	sinfo->slot_off = pos;
+	sinfo->de = de;
+	sinfo->bh = bh;
+	sinfo->i_pos = fatx_make_i_pos(sb, sinfo->bh, sinfo->de);
+
+	return 0;
+
+error:
+	brelse(bh);
+	return err;
+
+error_remove:
+	brelse(bh);
+	if(free_slots)
+		__fatx_remove_entries(dir, pos);
+	return err;
+}
+
+EXPORT_SYMBOL(fatx_add_entries);
diff -uprN a/fs/fatx/fatent.c b/fs/fatx/fatent.c
--- a/fs/fatx/fatent.c	1970-01-01 01:00:00.000000000 +0100
+++ b/fs/fatx/fatent.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,489 @@
+/*
+ * Copyright (C) 2004, OGAWA Hirofumi
+ * Released under GPL v2.
+ *
+ *  FATX port 2005 by Edgar Hucek
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/fatx_fs.h>
+
+#define PRINTK(format, args...) do { if (fatx_debug) printk( format, ##args ); } while(0)
+
+struct fatxent_operations {
+	void (*ent_blocknr)(struct super_block *, int, int *, sector_t *);
+	void (*ent_set_ptr)(struct fatx_entry *, unsigned long);
+	int (*ent_bread)(struct super_block *, struct fatx_entry *,
+			 unsigned long, sector_t);
+	unsigned long (*ent_get)(struct fatx_entry *);
+	void (*ent_put)(struct fatx_entry *, unsigned long);
+	int (*ent_next)(struct fatx_entry *);
+};
+
+static void fatx_ent_blocknr(struct super_block *sb, int entry,
+			    int *offset, sector_t *blocknr)
+{
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+	int bytes = (entry << sbi->fatxent_shift);
+	//WARN_ON(entry < FAT_START_ENT || sbi->max_cluster <= entry);
+	WARN_ON(sbi->max_cluster <= entry);
+	*offset = bytes & (sb->s_blocksize - 1);
+	*blocknr = sbi->fatx_start + (bytes >> sb->s_blocksize_bits);
+}
+
+static void fatx16_ent_set_ptr(struct fatx_entry *fatxent, unsigned long offset)
+{
+	WARN_ON(offset & (2 - 1));
+	fatxent->u.ent16_p = (__le16 *)(fatxent->bhs[0]->b_data + offset);
+}
+
+static void fatx32_ent_set_ptr(struct fatx_entry *fatxent, unsigned long offset)
+{
+	WARN_ON(offset & (4 - 1));
+	fatxent->u.ent32_p = (__u32 *)(fatxent->bhs[0]->b_data + offset);
+}
+
+static int fatx_ent_bread(struct super_block *sb, struct fatx_entry *fatxent,
+			 unsigned long offset, sector_t blocknr)
+{
+	struct fatxent_operations *ops = FATX_SB(sb)->fatxent_ops;
+
+	WARN_ON(blocknr < FATX_SB(sb)->fatx_start);
+	fatxent->bhs[0] = sb_bread(sb, blocknr);
+	if (!fatxent->bhs[0]) {
+		printk(KERN_ERR "FATX: FAT read failed (blocknr %llu)\n",
+		       (unsigned long long)blocknr);
+		return -EIO;
+	}
+	fatxent->nr_bhs = 1;
+	ops->ent_set_ptr(fatxent, offset);
+	return 0;
+}
+
+static unsigned long fatx16_ent_get(struct fatx_entry *fatxent)
+{
+	unsigned long next = le16_to_cpu(*fatxent->u.ent16_p);
+	WARN_ON((unsigned long)fatxent->u.ent16_p & (2 - 1));
+	if (next >= BAD_FAT16)
+		next = FAT_ENT_EOF;
+	return next;
+}
+
+static unsigned long fatx32_ent_get(struct fatx_entry *fatxent)
+{
+	unsigned long next = le32_to_cpu(*fatxent->u.ent32_p);
+	WARN_ON((unsigned long)fatxent->u.ent32_p & (4 - 1));
+	if (next >= BAD_FAT32)
+		next = FAT_ENT_EOF;
+	return next;
+}
+
+static void fatx16_ent_put(struct fatx_entry *fatxent, unsigned long new)
+{
+	if (new == FAT_ENT_EOF)
+		new = EOF_FAT16;
+
+	//if (new == EOF_FAT16) new = 0xffff;
+	PRINTK("FATX: %s new 0x%08lx\n", __FUNCTION__, new);
+	*fatxent->u.ent16_p = cpu_to_le16(new);
+	mark_buffer_dirty(fatxent->bhs[0]);
+}
+
+static void fatx32_ent_put(struct fatx_entry *fatxent, unsigned long new)
+{
+	if (new == FAT_ENT_EOF)
+		new = EOF_FAT32;
+
+	//if (new == EOF_FAT32) new = 0xffffffff;
+	//new = le32_to_cpu(*fatxent->u.ent32_p);
+	PRINTK("FATX: %s new 0x%08lx\n", __FUNCTION__, new);
+	*fatxent->u.ent32_p = cpu_to_le32(new);
+	mark_buffer_dirty(fatxent->bhs[0]);
+}
+
+static int fatx16_ent_next(struct fatx_entry *fatxent)
+{
+	const struct buffer_head *bh = fatxent->bhs[0];
+	fatxent->entry++;
+	if (fatxent->u.ent16_p < (__le16 *)(bh->b_data + (bh->b_size - 2))) {
+		fatxent->u.ent16_p++;
+		return 1;
+	}
+	fatxent->u.ent16_p = NULL;
+	return 0;
+}
+
+static int fatx32_ent_next(struct fatx_entry *fatxent)
+{
+	const struct buffer_head *bh = fatxent->bhs[0];
+	fatxent->entry++;
+	if (fatxent->u.ent32_p < (__u32 *)(bh->b_data + (bh->b_size - 4))) {
+		fatxent->u.ent32_p++;
+		return 1;
+	}
+	fatxent->u.ent32_p = NULL;
+	return 0;
+}
+
+static struct fatxent_operations fatx16_ops = {
+	.ent_blocknr	= fatx_ent_blocknr,
+	.ent_set_ptr	= fatx16_ent_set_ptr,
+	.ent_bread	= fatx_ent_bread,
+	.ent_get	= fatx16_ent_get,
+	.ent_put	= fatx16_ent_put,
+	.ent_next	= fatx16_ent_next,
+};
+
+static struct fatxent_operations fatx32_ops = {
+	.ent_blocknr	= fatx_ent_blocknr,
+	.ent_set_ptr	= fatx32_ent_set_ptr,
+	.ent_bread	= fatx_ent_bread,
+	.ent_get	= fatx32_ent_get,
+	.ent_put	= fatx32_ent_put,
+	.ent_next	= fatx32_ent_next,
+};
+
+static inline void lock_fatx(struct fatx_sb_info *sbi)
+{
+	down(&sbi->fatx_lock);
+}
+
+static inline void unlock_fatx(struct fatx_sb_info *sbi)
+{
+	up(&sbi->fatx_lock);
+}
+
+void fatx_ent_access_init(struct super_block *sb)
+{
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+
+	init_MUTEX(&sbi->fatx_lock);
+
+	switch (sbi->fatx_bits) {
+	case 32:
+		sbi->fatxent_shift = 2;
+		sbi->fatxent_ops = &fatx32_ops;
+		break;
+	case 16:
+		sbi->fatxent_shift = 1;
+		sbi->fatxent_ops = &fatx16_ops;
+		break;
+	}
+}
+
+static inline int fatx_ent_update_ptr(struct super_block *sb,
+				     struct fatx_entry *fatxent,
+				     int offset, sector_t blocknr)
+{
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+	struct fatxent_operations *ops = sbi->fatxent_ops;
+	struct buffer_head **bhs = fatxent->bhs;
+
+	/* Is this fatxent's blocks including this entry? */
+	if (!fatxent->nr_bhs || bhs[0]->b_blocknr != blocknr)
+		return 0;
+	ops->ent_set_ptr(fatxent, offset);
+	return 1;
+}
+
+__s64 fatx_ent_read(struct inode *inode, struct fatx_entry *fatxent, __s64 entry)
+{
+	struct super_block *sb = inode->i_sb;
+	struct fatx_sb_info *sbi = FATX_SB(inode->i_sb);
+	struct fatxent_operations *ops = sbi->fatxent_ops;
+	__s64 err; 
+	int offset;
+	sector_t blocknr;
+
+	if (entry < FAT_START_ENT || sbi->max_cluster <= entry) {
+		fatxent_brelse(fatxent);
+		fatx_fs_panic(sb, "invalid access to FAT (entry 0x%08x)", entry);
+		return -EIO;
+	}
+
+	fatxent_set_entry(fatxent, entry);
+	ops->ent_blocknr(sb, entry, &offset, &blocknr);
+
+	if (!fatx_ent_update_ptr(sb, fatxent, offset, blocknr)) {
+		fatxent_brelse(fatxent);
+		err = ops->ent_bread(sb, fatxent, offset, blocknr);
+		if (err)
+			return err;
+	}
+	err = ops->ent_get(fatxent);
+	PRINTK("FATX: %s ent_get err 0x%08llx entry 0x%08llx\n", __FUNCTION__, err, entry);
+	return err;
+}
+
+/* FIXME: We can write the blocks as more big chunk. */
+static int fatx_mirror_bhs(struct super_block *sb, struct buffer_head **bhs,
+			  int nr_bhs)
+{
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+	struct buffer_head *c_bh;
+	int err, n, copy;
+
+	err = 0;
+	for (copy = 1; copy < sbi->fatxs; copy++) {
+		sector_t backup_fatx = sbi->fatx_length * copy;
+
+		for (n = 0; n < nr_bhs; n++) {
+			c_bh = sb_getblk(sb, backup_fatx + bhs[n]->b_blocknr);
+			if (!c_bh) {
+				err = -ENOMEM;
+				goto error;
+			}
+			memcpy(c_bh->b_data, bhs[n]->b_data, sb->s_blocksize);
+			set_buffer_uptodate(c_bh);
+			mark_buffer_dirty(c_bh);
+			if (sb->s_flags & MS_SYNCHRONOUS)
+				err = sync_dirty_buffer(c_bh);
+			brelse(c_bh);
+			if (err)
+				goto error;
+		}
+	}
+error:
+	return err;
+}
+
+int fatx_ent_write(struct inode *inode, struct fatx_entry *fatxent,
+		  __s64 new, int wait)
+{
+	struct super_block *sb = inode->i_sb;
+	struct fatxent_operations *ops = FATX_SB(sb)->fatxent_ops;
+	int err;
+
+	ops->ent_put(fatxent, new);
+	if (wait) {
+		err = fatx_sync_bhs(fatxent->bhs, fatxent->nr_bhs);
+		if (err)
+			return err;
+	}
+	return fatx_mirror_bhs(sb, fatxent->bhs, fatxent->nr_bhs);
+}
+
+static inline int fatx_ent_next(struct fatx_sb_info *sbi,
+			       struct fatx_entry *fatxent)
+{
+	if (sbi->fatxent_ops->ent_next(fatxent)) {
+		if (fatxent->entry < sbi->max_cluster)
+			return 1;
+	}
+	return 0;
+}
+
+static inline int fatx_ent_read_block(struct super_block *sb,
+				     struct fatx_entry *fatxent)
+{
+	struct fatxent_operations *ops = FATX_SB(sb)->fatxent_ops;
+	sector_t blocknr;
+	int offset;
+
+	fatxent_brelse(fatxent);
+	ops->ent_blocknr(sb, fatxent->entry, &offset, &blocknr);
+	return ops->ent_bread(sb, fatxent, offset, blocknr);
+}
+
+static void fatx_collect_bhs(struct buffer_head **bhs, int *nr_bhs,
+			    struct fatx_entry *fatxent)
+{
+	int n, i;
+
+	for (n = 0; n < fatxent->nr_bhs; n++) {
+		for (i = 0; i < *nr_bhs; i++) {
+			if (fatxent->bhs[n] == bhs[i])
+				break;
+		}
+		if (i == *nr_bhs) {
+			get_bh(fatxent->bhs[n]);
+			bhs[i] = fatxent->bhs[n];
+			(*nr_bhs)++;
+		}
+	}
+}
+
+__s64 fatx_alloc_clusters(struct inode *inode, __s64 *cluster, int nr_cluster)
+{
+	struct super_block *sb = inode->i_sb;
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+	struct fatxent_operations *ops = sbi->fatxent_ops;
+	struct fatx_entry fatxent, prev_ent;
+	struct buffer_head *bhs[MAX_BUF_PER_PAGE];
+	int i, count,  nr_bhs, idx_clus;
+	__s64 err;
+
+	BUG_ON(nr_cluster > (MAX_BUF_PER_PAGE / 2));	/* fixed limit */
+
+	lock_fatx(sbi);
+	if (sbi->free_clusters != -1 && sbi->free_clusters < nr_cluster) {
+		unlock_fatx(sbi);
+		return -ENOSPC;
+	}
+
+	err = nr_bhs = idx_clus = 0;
+	count = FAT_START_ENT;
+	fatxent_init(&prev_ent);
+	fatxent_init(&fatxent);
+	fatxent_set_entry(&fatxent, sbi->prev_free + 1);
+	while (count < sbi->max_cluster) {
+		if (fatxent.entry >= sbi->max_cluster)
+			fatxent.entry = FAT_START_ENT;
+		fatxent_set_entry(&fatxent, fatxent.entry);
+		err = fatx_ent_read_block(sb, &fatxent);
+		if (err)
+			goto out;
+
+		/* Find the free entries in a block */
+		do {
+			if (ops->ent_get(&fatxent) == FAT_ENT_FREE) {
+				int entry = fatxent.entry;
+
+				/* make the cluster chain */
+				ops->ent_put(&fatxent, FAT_ENT_EOF);
+				if (prev_ent.nr_bhs)
+					ops->ent_put(&prev_ent, entry);
+
+				fatx_collect_bhs(bhs, &nr_bhs, &fatxent);
+
+				sbi->prev_free = entry;
+				if (sbi->free_clusters != -1)
+					sbi->free_clusters--;
+
+				cluster[idx_clus] = entry;
+				idx_clus++;
+				if (idx_clus == nr_cluster)
+					goto out;
+
+				/*
+				 * fatx_collect_bhs() gets ref-count of bhs,
+				 * so we can still use the prev_ent.
+				 */
+				prev_ent = fatxent;
+			}
+			count++;
+			if (count == sbi->max_cluster)
+				break;
+		} while (fatx_ent_next(sbi, &fatxent));
+	}
+
+	/* Couldn't allocate the free entries */
+	sbi->free_clusters = 0;
+	err = -ENOSPC;
+
+out:
+
+	unlock_fatx(sbi);
+	fatxent_brelse(&fatxent);
+	if (!err) {
+		PRINTK("FATX: %s cluster %lld err %lld\n", __FUNCTION__, cluster[0], err);
+		if (inode_needs_sync(inode))
+			err = fatx_sync_bhs(bhs, nr_bhs);
+		if (!err)
+			err = fatx_mirror_bhs(sb, bhs, nr_bhs);
+	}
+	for (i = 0; i < nr_bhs; i++)
+		brelse(bhs[i]);
+
+	if (err && idx_clus)
+		fatx_free_clusters(inode, cluster[0]);
+
+	return err;
+}
+
+__s64 fatx_free_clusters(struct inode *inode, __s64 cluster)
+{
+	struct super_block *sb = inode->i_sb;
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+	struct fatxent_operations *ops = sbi->fatxent_ops;
+	struct fatx_entry fatxent;
+	struct buffer_head *bhs[MAX_BUF_PER_PAGE];
+	int i, nr_bhs;
+	__s64 err; 
+	
+	nr_bhs = 0;
+	fatxent_init(&fatxent);
+	lock_fatx(sbi);
+	do {
+		PRINTK("FATX: %s cluster %lld\n", __FUNCTION__, cluster);
+		cluster = fatx_ent_read(inode, &fatxent, cluster);
+		if (cluster < 0) {
+			err = cluster;
+			goto error;
+		} else if (cluster == FAT_ENT_FREE) {
+			fatx_fs_panic(sb, "%s: deleting FAT entry beyond EOF",
+				     __FUNCTION__);
+			err = -EIO;
+			goto error;
+		}
+
+		ops->ent_put(&fatxent, FAT_ENT_FREE);
+		if (sbi->free_clusters != -1)
+			sbi->free_clusters++;
+
+		if (nr_bhs + fatxent.nr_bhs > MAX_BUF_PER_PAGE) {
+			if (sb->s_flags & MS_SYNCHRONOUS) {
+				err = fatx_sync_bhs(bhs, nr_bhs);
+				if (err)
+					goto error;
+			}
+			err = fatx_mirror_bhs(sb, bhs, nr_bhs);
+			if (err)
+				goto error;
+			for (i = 0; i < nr_bhs; i++)
+				brelse(bhs[i]);
+			nr_bhs = 0;
+		}
+		fatx_collect_bhs(bhs, &nr_bhs, &fatxent);
+	} while (cluster != FAT_ENT_EOF);
+
+	if (sb->s_flags & MS_SYNCHRONOUS) {
+		err = fatx_sync_bhs(bhs, nr_bhs);
+		if (err)
+			goto error;
+	}
+	err = fatx_mirror_bhs(sb, bhs, nr_bhs);
+error:
+	fatxent_brelse(&fatxent);
+	for (i = 0; i < nr_bhs; i++)
+		brelse(bhs[i]);
+	unlock_fatx(sbi);
+
+	return err;
+}
+
+EXPORT_SYMBOL(fatx_free_clusters);
+
+__s64 fatx_count_free_clusters(struct super_block *sb)
+{
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+	struct fatxent_operations *ops = sbi->fatxent_ops;
+	struct fatx_entry fatxent;
+	__s64 err = 0;
+	int free;
+
+	lock_fatx(sbi);
+	if (sbi->free_clusters != -1)
+		goto out;
+
+	free = 0;
+	fatxent_init(&fatxent);
+	fatxent_set_entry(&fatxent, FAT_START_ENT);
+	while (fatxent.entry < sbi->max_cluster) {
+		err = fatx_ent_read_block(sb, &fatxent);
+		if (err)
+			goto out;
+
+		do {
+			if (ops->ent_get(&fatxent) == FAT_ENT_FREE)
+				free++;
+		} while (fatx_ent_next(sbi, &fatxent));
+	}
+	sbi->free_clusters = free;
+	fatxent_brelse(&fatxent);
+out:
+	unlock_fatx(sbi);
+	return err;
+}
diff -uprN a/fs/fatx/file.c b/fs/fatx/file.c
--- a/fs/fatx/file.c	1970-01-01 01:00:00.000000000 +0100
+++ b/fs/fatx/file.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,194 @@
+/*
+ *  linux/fs/fatx/file.c
+ *
+ *  Written 1992,1993 by Werner Almesberger
+ *
+ *  FATX port 2005 by Edgar Hucek
+ *
+ *  regular file handling primitives for fatx-based filesystems
+ */
+
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/fatx_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/buffer_head.h>
+
+#define PRINTK(format, args...) do { if (fatx_debug) printk( format, ##args ); } while(0)
+
+static ssize_t fatx_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
+				   unsigned long nr_segs, loff_t pos) {
+	struct inode *inode = iocb->ki_filp->f_dentry->d_inode;
+	ssize_t retval;
+
+	retval = generic_file_aio_write(iocb, iov, nr_segs, pos);
+	if (retval > 0) {
+		inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+		FATX_I(inode)->i_attrs |= ATTR_ARCH;
+		mark_inode_dirty(inode);
+	}
+	return retval;
+};
+
+struct file_operations fatx_file_operations = {
+	.llseek		= generic_file_llseek,
+	.read		= do_sync_read,
+	.write		= do_sync_write,
+	.aio_read	= generic_file_aio_read,
+	.aio_write	= fatx_file_aio_write,
+	.mmap		= generic_file_mmap,
+	.ioctl		= NULL,
+	.fsync		= file_fsync,
+	.sendfile	= generic_file_sendfile,
+};
+
+int fatx_notify_change(struct dentry *dentry, struct iattr *attr)
+{
+	struct fatx_sb_info *sbi = FATX_SB(dentry->d_sb);
+	struct inode *inode = dentry->d_inode;
+	int mask, error = 0;
+
+	lock_kernel();
+
+	/* FAT cannot truncate to a longer file */
+	if (attr->ia_valid & ATTR_SIZE) {
+		if (attr->ia_size > inode->i_size) {
+			error = -EPERM;
+			goto out;
+		}
+	}
+
+	error = inode_change_ok(inode, attr);
+	if (error) {
+		if (sbi->options.quiet)
+			error = 0;
+		goto out;
+	}
+	if (((attr->ia_valid & ATTR_UID) &&
+	     (attr->ia_uid != sbi->options.fs_uid)) ||
+	    ((attr->ia_valid & ATTR_GID) &&
+	     (attr->ia_gid != sbi->options.fs_gid)) ||
+	    ((attr->ia_valid & ATTR_MODE) &&
+	     (attr->ia_mode & ~FATX_VALID_MODE)))
+		error = -EPERM;
+
+	if (error) {
+		if (sbi->options.quiet)
+			error = 0;
+		goto out;
+	}
+	error = inode_setattr(inode, attr);
+	if (error)
+		goto out;
+
+	if (S_ISDIR(inode->i_mode))
+		mask = sbi->options.fs_dmask;
+	else
+		mask = sbi->options.fs_fmask;
+	inode->i_mode &= S_IFMT | (S_IRWXUGO & ~mask);
+out:
+	unlock_kernel();
+	return error;
+}
+
+EXPORT_SYMBOL(fatx_notify_change);
+
+/* Free all clusters after the skip'th cluster. */
+static int fatx_free(struct inode *inode, int skip)
+{
+	struct super_block *sb = inode->i_sb;
+	int err, wait, free_start, i_start, i_logstart;
+
+	if (FATX_I(inode)->i_start == 0)
+		return 0;
+
+	/*
+	 * Write a new EOF, and get the remaining cluster chain for freeing.
+	 */
+	wait = IS_DIRSYNC(inode);
+	if (skip) {
+		struct fatx_entry fatxent;
+		__s64 ret;
+		int fclus, dclus;
+
+		ret = fatx_get_cluster(inode, skip - 1, &fclus, &dclus);
+		if (ret < 0)
+			return ret;
+		else if (ret == FAT_ENT_EOF)
+			return 0;
+
+		fatxent_init(&fatxent);
+		ret = fatx_ent_read(inode, &fatxent, dclus);
+		if (ret == FAT_ENT_EOF) {
+			fatxent_brelse(&fatxent);
+			return 0;
+		} else if (ret == FAT_ENT_FREE) {
+			fatx_fs_panic(sb,
+				     "%s: invalid cluster chain (i_pos %lld)",
+				     __FUNCTION__, FATX_I(inode)->i_pos);
+			ret = -EIO;
+		} else if (ret > 0) {
+			err = fatx_ent_write(inode, &fatxent, FAT_ENT_EOF, wait);
+			if (err)
+				ret = err;
+		}
+		fatxent_brelse(&fatxent);
+		if (ret < 0)
+			return ret;
+
+		free_start = ret;
+		i_start = i_logstart = 0;
+		fatx_cache_inval_inode(inode);
+	} else {
+		fatx_cache_inval_inode(inode);
+
+		i_start = free_start = FATX_I(inode)->i_start;
+		i_logstart = FATX_I(inode)->i_logstart;
+		FATX_I(inode)->i_start = 0;
+		FATX_I(inode)->i_logstart = 0;
+	}
+	FATX_I(inode)->i_attrs |= ATTR_ARCH;
+	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
+	if (wait) {
+		err = fatx_sync_inode(inode);
+		if (err)
+			goto error;
+	} else
+		mark_inode_dirty(inode);
+	inode->i_blocks = skip << (FATX_SB(sb)->cluster_bits - 9);
+
+	/* Freeing the remained cluster chain */
+	return fatx_free_clusters(inode, free_start);
+
+error:
+	if (i_start) {
+		FATX_I(inode)->i_start = i_start;
+		FATX_I(inode)->i_logstart = i_logstart;
+	}
+	return err;
+}
+
+void fatx_truncate(struct inode *inode)
+{
+	struct fatx_sb_info *sbi = FATX_SB(inode->i_sb);
+	const unsigned int cluster_size = sbi->cluster_size;
+	int nr_clusters;
+
+	/*
+	 * This protects against truncating a file bigger than it was then
+	 * trying to write into the hole.
+	 */
+	if (FATX_I(inode)->mmu_private > inode->i_size)
+		FATX_I(inode)->mmu_private = inode->i_size;
+
+	nr_clusters = (inode->i_size + (cluster_size - 1)) >> sbi->cluster_bits;
+
+	lock_kernel();
+	fatx_free(inode, nr_clusters);
+	unlock_kernel();
+}
+
+struct inode_operations fatx_file_inode_operations = {
+	.truncate	= fatx_truncate,
+	.setattr	= fatx_notify_change,
+};
diff -uprN a/fs/fatx/inode.c b/fs/fatx/inode.c
--- a/fs/fatx/inode.c	1970-01-01 01:00:00.000000000 +0100
+++ b/fs/fatx/inode.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,997 @@
+/*
+ *  linux/fs/fatx/inode.c
+ *
+ *  Written 1992,1993 by Werner Almesberger
+ *  VFAT extensions by Gordon Chaffee, merged with fatx fs by Henrik Storner
+ *  Rewritten for the constant inumbers support by Al Viro
+ *
+ *  Fixes:
+ *
+ *	Max Cohan: Fixed invalid FSINFO offset when info_sector is 0
+ *
+ *  FATX port 2005 by Edgar Hucek
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/seq_file.h>
+#include <linux/fatx_fs.h>
+#include <linux/pagemap.h>
+#include <linux/buffer_head.h>
+#include <linux/mount.h>
+#include <linux/vfs.h>
+#include <linux/parser.h>
+#include <asm/unaligned.h>
+
+#ifndef CONFIG_FAT_DEFAULT_IOCHARSET
+/* if user don't select VFAT, this is undefined. */
+#define CONFIG_FAT_DEFAULT_IOCHARSET	""
+#endif
+
+unsigned int fatx_debug = 0;
+
+#define PRINTK(format, args...) do { if (fatx_debug) printk( format, ##args ); } while(0)
+
+
+
+static __s64 fatx_add_cluster(struct inode *inode)
+{
+	__s64 err, cluster;
+
+	PRINTK("FATX: %s\n", __FUNCTION__);
+	err = fatx_alloc_clusters(inode, &cluster, 1);
+	if (err) {
+		PRINTK("FATX: %s fatx_alloc_clusters error cluster 0x%08llx\n", __FUNCTION__, cluster);
+		return err;
+	}
+	/* FIXME: this cluster should be added after data of this
+	 * cluster is writed */
+	err = fatx_chain_add(inode, cluster, 1);
+	if (err) {
+		PRINTK("FATX: %s fatx_chain_add error cluster 0x%08llx\n", __FUNCTION__, cluster);
+		fatx_free_clusters(inode, cluster);
+	}
+	return err;
+}
+
+static int fatx_get_block(struct inode *inode, sector_t iblock,
+			 struct buffer_head *bh_result, int create)
+{
+	struct super_block *sb = inode->i_sb;
+	sector_t phys;
+	__s64 err;
+
+	err = fatx_bmap(inode, iblock, &phys);
+	if (err)
+		return err;
+	if (phys) {
+		map_bh(bh_result, sb, phys);
+		return 0;
+	}
+	if (!create)
+		return 0;
+	if (iblock != FATX_I(inode)->mmu_private >> sb->s_blocksize_bits) {
+		fatx_fs_panic(sb, "corrupted file size (i_pos %lld, %lld)",
+			     FATX_I(inode)->i_pos, FATX_I(inode)->mmu_private);
+		return -EIO;
+	}
+	if (!((unsigned long)iblock & (FATX_SB(sb)->sec_per_clus - 1))) {
+		PRINTK("FATX: fatx_get_block -> fatx_add_cluster 0x%08lx\n",
+			(unsigned long)iblock);
+		err = fatx_add_cluster(inode);
+		if (err)
+			return err;
+	}
+	FATX_I(inode)->mmu_private += sb->s_blocksize;
+	err = fatx_bmap(inode, iblock, &phys);
+	if (err)
+		return err;
+	if (!phys)
+		BUG();
+	set_buffer_new(bh_result);
+	map_bh(bh_result, sb, phys);
+	return 0;
+}
+
+static int fatx_writepage(struct page *page, struct writeback_control *wbc)
+{
+	return block_write_full_page(page, fatx_get_block, wbc);
+}
+
+static int fatx_readpage(struct file *file, struct page *page)
+{
+	return block_read_full_page(page, fatx_get_block);
+}
+
+static int fatx_prepare_write(struct file *file, struct page *page,
+			     unsigned from, unsigned to)
+{
+	return cont_prepare_write(page, from, to, fatx_get_block,
+				  &FATX_I(page->mapping->host)->mmu_private);
+}
+
+static sector_t _fatx_bmap(struct address_space *mapping, sector_t block)
+{
+	return generic_block_bmap(mapping, block, fatx_get_block);
+}
+
+static struct address_space_operations fatx_aops = {
+	.readpage	= fatx_readpage,
+	.writepage	= fatx_writepage,
+	.sync_page	= block_sync_page,
+	.prepare_write	= fatx_prepare_write,
+	.commit_write	= generic_commit_write,
+	.bmap		= _fatx_bmap
+};
+
+/*
+ * New FAT inode stuff. We do the following:
+ *	a) i_ino is constant and has nothing with on-disk location.
+ *	b) FAT manages its own cache of directory entries.
+ *	c) *This* cache is indexed by on-disk location.
+ *	d) inode has an associated directory entry, all right, but
+ *		it may be unhashed.
+ *	e) currently entries are stored within struct inode. That should
+ *		change.
+ *	f) we deal with races in the following way:
+ *		1. readdir() and lookup() do FAT-dir-cache lookup.
+ *		2. rename() unhashes the F-d-c entry and rehashes it in
+ *			a new place.
+ *		3. unlink() and rmdir() unhash F-d-c entry.
+ *		4. fatx_write_inode() checks whether the thing is unhashed.
+ *			If it is we silently return. If it isn't we do bread(),
+ *			check if the location is still valid and retry if it
+ *			isn't. Otherwise we do changes.
+ *		5. Spinlock is used to protect hash/unhash/location check/lookup
+ *		6. fatx_clear_inode() unhashes the F-d-c entry.
+ *		7. lookup() and readdir() do igrab() if they find a F-d-c entry
+ *			and consider negative result as cache miss.
+ */
+
+static void fatx_hash_init(struct super_block *sb)
+{
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+	int i;
+
+	spin_lock_init(&sbi->inode_hash_lock);
+	for (i = 0; i < FAT_HASH_SIZE; i++)
+		INIT_HLIST_HEAD(&sbi->inode_hashtable[i]);
+}
+
+static inline unsigned long fatx_hash(struct super_block *sb, loff_t i_pos)
+{
+	unsigned long tmp = (unsigned long)i_pos | (unsigned long) sb;
+	tmp = tmp + (tmp >> FAT_HASH_BITS) + (tmp >> FAT_HASH_BITS * 2);
+	return tmp & FAT_HASH_MASK;
+}
+
+void fatx_attach(struct inode *inode, loff_t i_pos)
+{
+	struct super_block *sb = inode->i_sb;
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+
+	spin_lock(&sbi->inode_hash_lock);
+	FATX_I(inode)->i_pos = i_pos;
+	hlist_add_head(&FATX_I(inode)->i_fatx_hash,
+			sbi->inode_hashtable + fatx_hash(sb, i_pos));
+	spin_unlock(&sbi->inode_hash_lock);
+}
+
+EXPORT_SYMBOL(fatx_attach);
+
+void fatx_detach(struct inode *inode)
+{
+	struct fatx_sb_info *sbi = FATX_SB(inode->i_sb);
+	spin_lock(&sbi->inode_hash_lock);
+	FATX_I(inode)->i_pos = 0;
+	hlist_del_init(&FATX_I(inode)->i_fatx_hash);
+	spin_unlock(&sbi->inode_hash_lock);
+}
+
+EXPORT_SYMBOL(fatx_detach);
+
+struct inode *fatx_iget(struct super_block *sb, loff_t i_pos)
+{
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+	struct hlist_head *head = sbi->inode_hashtable + fatx_hash(sb, i_pos);
+	struct hlist_node *_p;
+	struct fatx_inode_info *i;
+	struct inode *inode = NULL;
+
+	spin_lock(&sbi->inode_hash_lock);
+	hlist_for_each_entry(i, _p, head, i_fatx_hash) {
+		BUG_ON(i->vfs_inode.i_sb != sb);
+		if (i->i_pos != i_pos)
+			continue;
+		inode = igrab(&i->vfs_inode);
+		if (inode)
+			break;
+	}
+	spin_unlock(&sbi->inode_hash_lock);
+	return inode;
+}
+
+static int fatx_calc_dir_size(struct inode *inode)
+{
+	struct fatx_sb_info *sbi = FATX_SB(inode->i_sb);
+	__s64 ret; 
+	int fclus, dclus;
+
+	inode->i_size = 0;
+	if (FATX_I(inode)->i_start == 0)
+		return 0;
+
+	ret = fatx_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);
+	if (ret < 0)
+		return ret;
+	inode->i_size = (fclus + 1) << sbi->cluster_bits;
+
+	return 0;
+}
+
+/* doesn't deal with root inode */
+static int fatx_fill_inode(struct inode *inode, struct fatx_dir_entry *de)
+{
+	struct fatx_sb_info *sbi = FATX_SB(inode->i_sb);
+	int error;
+
+	FATX_I(inode)->i_pos = 0;
+	inode->i_uid = sbi->options.fs_uid;
+	inode->i_gid = sbi->options.fs_gid;
+	inode->i_version++;
+	inode->i_generation = get_seconds();
+
+	if ((de->attr & ATTR_DIR) && !IS_FREE(de)) {
+		inode->i_generation &= ~1;
+		inode->i_mode = FATX_MKMODE(de->attr, S_IRWXUGO & ~sbi->options.fs_dmask) | S_IFDIR;
+		inode->i_op = sbi->dir_ops;
+		inode->i_fop = &fatx_dir_operations;
+
+		FATX_I(inode)->i_start = le32_to_cpu(de->start);
+		FATX_I(inode)->i_logstart = FATX_I(inode)->i_start;
+		error = fatx_calc_dir_size(inode);
+		if (error < 0) {
+			PRINTK("FATX: %s fatx_calc_dir_size failed\n", __FUNCTION__ );
+			return error;
+		}
+		FATX_I(inode)->mmu_private = inode->i_size;
+
+		// TODO: check if 2 is right
+		inode->i_nlink = fatx_subdirs(inode) + 2;
+	} else { /* not a directory */
+		inode->i_generation |= 1;
+		inode->i_mode = FATX_MKMODE(de->attr,S_IRWXUGO & ~sbi->options.fs_fmask) | S_IFREG;
+		FATX_I(inode)->i_start = le32_to_cpu(de->start);
+		FATX_I(inode)->i_logstart = FATX_I(inode)->i_start;
+		inode->i_size = le32_to_cpu(de->size);
+		inode->i_op = &fatx_file_inode_operations;
+		inode->i_fop = &fatx_file_operations;
+		inode->i_mapping->a_ops = &fatx_aops;
+		FATX_I(inode)->mmu_private = inode->i_size;
+	}
+	FATX_I(inode)->i_attrs = de->attr & ATTR_UNUSED;
+
+	/* this is as close to the truth as we can get ... */
+	// inode->i_blksize = sbi->cluster_size; // Not used anymore? -- lalee
+
+	inode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))
+			   & ~((loff_t)sbi->cluster_size - 1)) >> 9;
+	inode->i_mtime.tv_sec = inode->i_atime.tv_sec =
+		fatx_date_dos2unix(le16_to_cpu(de->time), le16_to_cpu(de->date));
+	inode->i_ctime = inode->i_mtime;
+	return 0;
+}
+
+struct inode *fatx_build_inode(struct super_block *sb,
+			struct fatx_dir_entry *de, loff_t i_pos)
+{
+	struct inode *inode;
+	int err;
+
+	inode = fatx_iget(sb, i_pos);
+	if (inode) {
+		PRINTK("FATX: %s fatx_iget failed\n", __FUNCTION__ );
+		goto out;
+	}
+	inode = new_inode(sb);
+	if (!inode) {
+		inode = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+	inode->i_ino = iunique(sb, FATX_ROOT_INO);
+	inode->i_version = 1;
+	err = fatx_fill_inode(inode, de);
+	if (err) {
+		iput(inode);
+		inode = ERR_PTR(err);
+		PRINTK("FATX: %s fatx_fill_inode failed\n", __FUNCTION__ );
+		goto out;
+	}
+	fatx_attach(inode, i_pos);
+	insert_inode_hash(inode);
+out:
+	return inode;
+}
+
+EXPORT_SYMBOL(fatx_build_inode);
+
+static void fatx_delete_inode(struct inode *inode)
+{
+	if (!is_bad_inode(inode)) {
+		inode->i_size = 0;
+		fatx_truncate(inode);
+	}
+	clear_inode(inode);
+}
+
+static void fatx_clear_inode(struct inode *inode)
+{
+	struct fatx_sb_info *sbi = FATX_SB(inode->i_sb);
+
+	if (is_bad_inode(inode))
+		return;
+	lock_kernel();
+	spin_lock(&sbi->inode_hash_lock);
+	fatx_cache_inval_inode(inode);
+	hlist_del_init(&FATX_I(inode)->i_fatx_hash);
+	spin_unlock(&sbi->inode_hash_lock);
+	unlock_kernel();
+}
+
+static void fatx_put_super(struct super_block *sb)
+{
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+
+	if (sbi->nls_io) {
+		unload_nls(sbi->nls_io);
+		sbi->nls_io = NULL;
+	}
+
+	sb->s_fs_info = NULL;
+	kfree(sbi);
+}
+
+static struct kmem_cache *fatx_inode_cachep;
+
+static struct inode *fatx_alloc_inode(struct super_block *sb)
+{
+	struct fatx_inode_info *ei;
+	ei = kmem_cache_alloc(fatx_inode_cachep, GFP_KERNEL);
+	if (!ei)
+		return NULL;
+	return &ei->vfs_inode;
+}
+
+static void fatx_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(fatx_inode_cachep, FATX_I(inode));
+}
+
+static void init_once(void * foo, struct kmem_cache * cachep, unsigned long flags)
+{
+	struct fatx_inode_info *ei = (struct fatx_inode_info *)foo;
+
+	spin_lock_init(&ei->cache_lru_lock);
+	ei->nr_caches = 0;
+	ei->cache_valid_id = FAT_CACHE_VALID + 1;
+	INIT_LIST_HEAD(&ei->cache_lru);
+	INIT_HLIST_NODE(&ei->i_fatx_hash);
+	inode_init_once(&ei->vfs_inode);
+}
+
+static int __init fatx_init_inodecache(void)
+{
+	fatx_inode_cachep = kmem_cache_create("fatx_inode_cache",
+					     sizeof(struct fatx_inode_info),
+					     0, SLAB_RECLAIM_ACCOUNT,
+					     init_once, NULL);
+	if (fatx_inode_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+static void __exit fatx_destroy_inodecache(void)
+{
+	kmem_cache_destroy(fatx_inode_cachep);
+}
+
+static int fatx_remount(struct super_block *sb, int *flags, char *data)
+{
+	*flags |= MS_NODIRATIME | MS_NOATIME;
+	return 0;
+}
+
+static int fatx_statfs(struct dentry *dent, struct kstatfs *buf)
+{
+        /*FIXME not sure if this is right... */
+        struct super_block *sb = dent->d_sb;
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+
+	/* If the count of free cluster is still unknown, counts it here. */
+	if (sbi->free_clusters == -1) {
+		__s64 err = fatx_count_free_clusters(sb);
+		if (err)
+			return err;
+	}
+
+	buf->f_type = sb->s_magic;
+	buf->f_bsize = sbi->cluster_size;
+	buf->f_blocks = sbi->max_cluster - FAT_START_ENT;
+	buf->f_bfree = sbi->free_clusters;
+	buf->f_bavail = sbi->free_clusters;
+	buf->f_namelen = FATX_NAME;
+
+	return 0;
+}
+
+static int fatx_write_inode(struct inode *inode, int wait)
+{
+	struct super_block *sb = inode->i_sb;
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+	struct buffer_head *bh;
+	struct fatx_dir_entry *raw_entry;
+	loff_t i_pos;
+	int err = 0;
+
+retry:
+	i_pos = FATX_I(inode)->i_pos;
+	if (inode->i_ino == FATX_ROOT_INO || !i_pos)
+		return 0;
+
+	lock_kernel();
+	bh = sb_bread(sb, i_pos >> sbi->dir_per_block_bits);
+	if (!bh) {
+		printk(KERN_ERR "FATX: unable to read inode block "
+		       "for updating (i_pos %lld)\n", i_pos);
+		err = -EIO;
+		goto out;
+	}
+	spin_lock(&sbi->inode_hash_lock);
+	if (i_pos != FATX_I(inode)->i_pos) {
+		spin_unlock(&sbi->inode_hash_lock);
+		brelse(bh);
+		unlock_kernel();
+		goto retry;
+	}
+
+	raw_entry = &((struct fatx_dir_entry *) (bh->b_data))
+	    [i_pos & (sbi->dir_per_block - 1)];
+	if (S_ISDIR(inode->i_mode))
+		raw_entry->size = 0;
+	else
+		raw_entry->size = cpu_to_le32(inode->i_size);
+	raw_entry->attr = fatx_attr(inode);
+	raw_entry->start = cpu_to_le32(FATX_I(inode)->i_logstart);
+	
+	fatx_date_unix2dos(inode->i_mtime.tv_sec, &raw_entry->time, &raw_entry->date);
+	//raw_entry->time = cpu_to_le16(raw_entry->time);
+	//raw_entry->date = cpu_to_le16(raw_entry->date);
+	
+	//fatx_date_unix2dos(inode->i_mtime.tv_sec, &raw_entry->time, &raw_entry->date);	
+	//raw_entry->ctime = cpu_to_le16(raw_entry->ctime);
+	//raw_entry->cdate = cpu_to_le16(raw_entry->cdate);
+	//raw_entry->atime = cpu_to_le16(raw_entry->ctime);
+	//raw_entry->adate = cpu_to_le16(raw_entry->cdate);
+	
+	spin_unlock(&sbi->inode_hash_lock);
+	mark_buffer_dirty(bh);
+	if (wait)
+		err = sync_dirty_buffer(bh);
+	brelse(bh);
+out:
+	unlock_kernel();
+	return err;
+}
+
+int fatx_sync_inode(struct inode *inode)
+{
+	return fatx_write_inode(inode, 1);
+}
+
+EXPORT_SYMBOL(fatx_sync_inode);
+
+static int fatx_show_options(struct seq_file *m, struct vfsmount *mnt);
+static struct super_operations fatx_sops = {
+	.alloc_inode	= fatx_alloc_inode,
+	.destroy_inode	= fatx_destroy_inode,
+	.write_inode	= fatx_write_inode,
+	.delete_inode	= fatx_delete_inode,
+	.put_super	= fatx_put_super,
+	.statfs		= fatx_statfs,
+	.clear_inode	= fatx_clear_inode,
+	.remount_fs	= fatx_remount,
+
+	.read_inode	= make_bad_inode,
+
+	.show_options	= fatx_show_options,
+};
+
+/*
+ * a FAT file handle with fhtype 3 is
+ *  0/  i_ino - for fast, reliable lookup if still in the cache
+ *  1/  i_generation - to see if i_ino is still valid
+ *          bit 0 == 0 iff directory
+ *  2/  i_pos(8-39) - if ino has changed, but still in cache
+ *  3/  i_pos(4-7)|i_logstart - to semi-verify inode found at i_pos
+ *  4/  i_pos(0-3)|parent->i_logstart - maybe used to hunt for the file on disc
+ *
+ * Hack for NFSv2: Maximum FAT entry number is 28bits and maximum
+ * i_pos is 40bits (blocknr(32) + dir offset(8)), so two 4bits
+ * of i_logstart is used to store the directory entry offset.
+ */
+
+static struct dentry *
+fatx_decode_fh(struct super_block *sb, __u32 *fh, int len, int fhtype,
+	      int (*acceptable)(void *context, struct dentry *de),
+	      void *context)
+{
+	if (fhtype != 3)
+		return ERR_PTR(-ESTALE);
+	if (len < 5)
+		return ERR_PTR(-ESTALE);
+
+	return sb->s_export_op->find_exported_dentry(sb, fh, NULL, acceptable, context);
+}
+
+static struct dentry *fatx_get_dentry(struct super_block *sb, void *inump)
+{
+	struct inode *inode = NULL;
+	struct dentry *result;
+	__u32 *fh = inump;
+
+	inode = iget(sb, fh[0]);
+	if (!inode || is_bad_inode(inode) || inode->i_generation != fh[1]) {
+		if (inode)
+			iput(inode);
+		inode = NULL;
+	}
+	if (!inode) {
+		loff_t i_pos;
+		int i_logstart = fh[3];
+
+		i_pos = (loff_t)fh[2] << 8;
+		i_pos |= ((fh[3] >> 24) & 0xf0) | (fh[4] >> 28);
+
+		/* try 2 - see if i_pos is in F-d-c
+		 * require i_logstart to be the same
+		 * Will fail if you truncate and then re-write
+		 */
+
+		inode = fatx_iget(sb, i_pos);
+		if (inode && FATX_I(inode)->i_logstart != i_logstart) {
+			iput(inode);
+			inode = NULL;
+		}
+	}
+	if (!inode) {
+		/* For now, do nothing
+		 * What we could do is:
+		 * follow the file starting at fh[4], and record
+		 * the ".." entry, and the name of the fh[2] entry.
+		 * The follow the ".." file finding the next step up.
+		 * This way we build a path to the root of
+		 * the tree. If this works, we lookup the path and so
+		 * get this inode into the cache.
+		 * Finally try the fatx_iget lookup again
+		 * If that fails, then weare totally out of luck
+		 * But all that is for another day
+		 */
+	}
+	if (!inode)
+		return ERR_PTR(-ESTALE);
+
+
+	/* now to find a dentry.
+	 * If possible, get a well-connected one
+	 */
+	result = d_alloc_anon(inode);
+	if (result == NULL) {
+		iput(inode);
+		return ERR_PTR(-ENOMEM);
+	}
+	result->d_op = sb->s_root->d_op;
+	return result;
+}
+
+static int
+fatx_encode_fh(struct dentry *de, __u32 *fh, int *lenp, int connectable)
+{
+	int len = *lenp;
+	struct inode *inode =  de->d_inode;
+	u32 ipos_h, ipos_m, ipos_l;
+
+	if (len < 5)
+		return 255; /* no room */
+
+	ipos_h = FATX_I(inode)->i_pos >> 8;
+	ipos_m = (FATX_I(inode)->i_pos & 0xf0) << 24;
+	ipos_l = (FATX_I(inode)->i_pos & 0x0f) << 28;
+	*lenp = 5;
+	fh[0] = inode->i_ino;
+	fh[1] = inode->i_generation;
+	fh[2] = ipos_h;
+	fh[3] = ipos_m | FATX_I(inode)->i_logstart;
+	spin_lock(&de->d_lock);
+	fh[4] = ipos_l | FATX_I(de->d_parent->d_inode)->i_logstart;
+	spin_unlock(&de->d_lock);
+	return 3;
+}
+
+static struct dentry *fatx_get_parent(struct dentry *child)
+{
+	struct buffer_head *bh = NULL;
+	struct fatx_dir_entry *de = NULL;
+	loff_t i_pos = 0;
+	struct dentry *parent;
+	struct inode *inode;
+	/*
+	int err;
+	*/
+
+	lock_kernel();
+
+	/*
+	err = fatx_get_dotdot_entry(child->d_inode, &bh, &de, &i_pos);
+	if(err) {
+		parent = ERR_PTR(err);
+		goto out;
+	}
+	*/
+
+	inode = fatx_build_inode(child->d_sb, de, i_pos);
+	brelse(bh);
+	if (IS_ERR(inode)) {
+		parent = ERR_PTR(PTR_ERR(inode));
+		goto out;
+	}
+	parent = d_alloc_anon(inode);
+	if (!parent) {
+		iput(inode);
+		parent = ERR_PTR(-ENOMEM);
+	}
+out:
+	unlock_kernel();
+
+	return parent;
+}
+
+static struct export_operations fatx_export_ops = {
+	.decode_fh	= fatx_decode_fh,
+	.encode_fh	= fatx_encode_fh,
+	.get_dentry	= fatx_get_dentry,
+	.get_parent	= fatx_get_parent,
+};
+
+static int fatx_show_options(struct seq_file *m, struct vfsmount *mnt)
+{
+	struct fatx_sb_info *sbi = FATX_SB(mnt->mnt_sb);
+	struct fatx_mount_options *opts = &sbi->options;
+
+	if (opts->fs_uid != 0)
+		seq_printf(m, ",uid=%u", opts->fs_uid);
+	if (opts->fs_gid != 0)
+		seq_printf(m, ",gid=%u", opts->fs_gid);
+	seq_printf(m, ",fmask=%04o", opts->fs_fmask);
+	seq_printf(m, ",dmask=%04o", opts->fs_dmask);
+	if (opts->quiet)
+		seq_puts(m, ",quiet");
+	return 0;
+}
+
+enum {
+	Opt_uid, Opt_gid, Opt_umask, Opt_dmask, Opt_fmask, 
+	Opt_quiet, Opt_err,
+};
+
+static match_table_t fatx_tokens = {
+	{Opt_uid, "uid=%u"},
+	{Opt_gid, "gid=%u"},
+	{Opt_umask, "umask=%o"},
+	{Opt_dmask, "dmask=%o"},
+	{Opt_fmask, "fmask=%o"},
+	{Opt_err, NULL}
+};
+
+static int parse_options(char *options, struct fatx_mount_options *opts)
+{
+	char *p;
+	substring_t args[MAX_OPT_ARGS];
+	int option;
+
+	opts->fs_uid = current->uid;
+	opts->fs_gid = current->gid;
+	opts->fs_fmask = opts->fs_dmask = current->fs->umask;
+	opts->quiet = 0;
+
+	if (!options)
+		return 0;
+
+	while ((p = strsep(&options, ",")) != NULL) {
+		int token;
+		if (!*p)
+			continue;
+
+		token = match_token(p, fatx_tokens, args);
+		if (token == Opt_err) {
+			token = match_token(p, fatx_tokens, args);
+		}
+		switch (token) {
+		case Opt_quiet:
+			opts->quiet = 1;
+			break;
+		case Opt_uid:
+			if (match_int(&args[0], &option))
+				return 0;
+			opts->fs_uid = option;
+			break;
+		case Opt_gid:
+			if (match_int(&args[0], &option))
+				return 0;
+			opts->fs_gid = option;
+			break;
+		case Opt_umask:
+			if (match_octal(&args[0], &option))
+				return 0;
+			opts->fs_fmask = opts->fs_dmask = option;
+			break;
+		case Opt_dmask:
+			if (match_octal(&args[0], &option))
+				return 0;
+			opts->fs_dmask = option;
+			break;
+		case Opt_fmask:
+			if (match_octal(&args[0], &option))
+				return 0;
+			opts->fs_fmask = option;
+			break;
+		default:
+			printk(KERN_ERR "FATX: Unrecognized mount option \"%s\" "
+			       "or missing value\n", p);
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+
+static int fatx_read_root(struct inode *inode)
+{
+	struct super_block *sb = inode->i_sb;
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+	int error;
+
+	FATX_I(inode)->i_pos = 0;
+	inode->i_uid = sbi->options.fs_uid;
+	inode->i_gid = sbi->options.fs_gid;
+	inode->i_version++;
+	inode->i_generation = 0;
+	inode->i_mode = (S_IRWXUGO & ~sbi->options.fs_dmask) | S_IFDIR;
+	inode->i_op = sbi->dir_ops;
+	inode->i_fop = &fatx_dir_operations;
+	FATX_I(inode)->i_start = 0;
+	error = fatx_calc_dir_size(inode);
+	if (error < 0)
+		return error;
+	inode->i_size = sbi->dir_entries * sizeof(struct fatx_dir_entry);
+
+	// Not used anymore? -- lalee
+	// inode->i_blksize = sbi->cluster_size;
+
+	inode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))
+			   & ~((loff_t)sbi->cluster_size - 1)) >> 9;
+	FATX_I(inode)->i_logstart = 0;
+	FATX_I(inode)->mmu_private = inode->i_size;
+
+	FATX_I(inode)->i_attrs = ATTR_NONE;
+	inode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec = 0;
+	inode->i_mtime.tv_nsec = inode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = 1;
+	//FATX_I(inode)->i_ctime_ms = 0;
+	inode->i_nlink = fatx_subdirs(inode)+2;
+
+	return 0;
+}
+
+/*
+ * Read the super block of an MS-DOS FS.
+ */
+int fatx_fill_super_inode(struct super_block *sb, void *data, int silent,
+		   struct inode_operations *fs_dir_inode_ops)
+{
+	struct inode *root_inode = NULL;
+	struct buffer_head *bh;
+	struct fatx_boot_sector *b;
+	struct fatx_sb_info *sbi;
+	u16 logical_sector_size;
+	//u32 total_clusters;
+	u32 total_sectors;
+	unsigned long cl_count;
+	unsigned long fatx_length;
+	long error;
+
+	sbi = kmalloc(sizeof(struct fatx_sb_info), GFP_KERNEL);
+	if (!sbi)
+		return -ENOMEM;
+	sb->s_fs_info = sbi;
+	memset(sbi, 0, sizeof(struct fatx_sb_info));
+
+	sb->s_flags |= MS_NODIRATIME;
+	sb->s_magic = FATX_SUPER_MAGIC;
+	sb->s_op = &fatx_sops;
+	sb->s_export_op = &fatx_export_ops;
+	sbi->dir_ops = fs_dir_inode_ops;
+
+	error = parse_options(data, &sbi->options);
+	if (error)
+		goto out_fail;
+
+	error = -EIO;
+	sb_min_blocksize(sb, 512);
+	bh = sb_bread(sb, 0);
+	if (bh == NULL) {
+		printk(KERN_ERR "FATX: unable to read boot sector\n");
+		goto out_fail;
+	}
+
+	b = (struct fatx_boot_sector *) bh->b_data;
+
+	logical_sector_size = 512;
+
+	if (logical_sector_size < sb->s_blocksize) {
+		printk(KERN_ERR "FATX: logical sector size too small for device"
+		       " (logical sector size = %u)\n", logical_sector_size);
+		brelse(bh);
+		goto out_fail;
+	}
+	if (logical_sector_size > sb->s_blocksize) {
+		brelse(bh);
+
+		if (!sb_set_blocksize(sb, logical_sector_size)) {
+			printk(KERN_ERR "FATX: unable to set blocksize %u\n",
+			       logical_sector_size);
+			goto out_fail;
+		}
+		bh = sb_bread(sb, 0);
+		if (bh == NULL) {
+			printk(KERN_ERR "FATX: unable to read boot sector"
+			       " (logical sector size = %lu)\n",
+			       sb->s_blocksize);
+			goto out_fail;
+		}
+		b = (struct fatx_boot_sector *) bh->b_data;
+	}
+
+	sbi->sec_per_clus = CLUSTER_SIZE;
+	sbi->cluster_size = sb->s_blocksize * sbi->sec_per_clus;
+	sbi->cluster_bits = ffs(sbi->cluster_size) - 1;
+	sbi->fatxs = 1;
+	sbi->fatx_start = 8;
+	sbi->root_cluster = 0;
+	sbi->free_clusters = -1;	/* Don't know yet */
+	sbi->prev_free = 0;
+
+	total_sectors = sb->s_bdev->bd_inode->i_size >> 9;
+
+	cl_count = total_sectors / sbi->sec_per_clus;
+	if( cl_count >= 0xfff4 ) {
+		//sb->s_maxbytes = FATX32_MAX_NON_LFS;
+		sbi->fatx_bits = 32;
+	} else {
+		//sb->s_maxbytes = FATX16_MAX_NON_LFS;
+		sbi->fatx_bits = 16;
+	}
+	sb->s_maxbytes = 0xffffffff;
+
+	fatx_length = cl_count * (sbi->fatx_bits>>3);
+	if(fatx_length % 4096) {
+		fatx_length = ((fatx_length / 4096) + 1) * 4096;
+	}
+	sbi->fatx_length = fatx_length / logical_sector_size;
+	
+	sbi->dir_per_block = sb->s_blocksize / sizeof(struct fatx_dir_entry);
+	sbi->dir_per_block_bits = ffs(sbi->dir_per_block) - 1;
+
+	sbi->dir_start = sbi->fatx_start + sbi->fatx_length;
+	sbi->dir_entries = 256;
+
+	sbi->data_start = sbi->dir_start + sbi->sec_per_clus;
+
+	sbi->max_cluster = ((total_sectors-sbi->data_start) / sbi->sec_per_clus) + FAT_START_ENT;
+
+	sbi->nls_disk = NULL;
+	brelse(bh);
+
+	/* set up enough so that it can read an inode */
+	fatx_hash_init(sb);
+	fatx_ent_access_init(sb);
+
+	error = -ENOMEM;
+	root_inode = new_inode(sb);
+	if (!root_inode)
+		goto out_fail;
+	root_inode->i_ino = FATX_ROOT_INO;
+	root_inode->i_version = 1;
+	error = fatx_read_root(root_inode);
+	if (error < 0)
+		goto out_fail;
+	error = -ENOMEM;
+	insert_inode_hash(root_inode);
+	sb->s_root = d_alloc_root(root_inode);
+	if (!sb->s_root) {
+		printk(KERN_ERR "FATX: get root inode failed\n");
+		goto out_fail;
+	}
+
+	PRINTK("FATX: logical_sector_size:	%d\n",(int)logical_sector_size);
+	PRINTK("FATX: fatx_length:		%d\n",(int)sbi->fatx_length);
+	PRINTK("FATX: spc_bits:			%d\n",sbi->fatx_bits>>3);
+	PRINTK("FATX: fatx_start:		%d\n",(int)sbi->fatx_start);
+	PRINTK("FATX: dir_start:		%d\n",(int)sbi->dir_start);
+	PRINTK("FATX: data_start:		%d\n",(int)sbi->data_start);
+	PRINTK("FATX: max_cluster:		%ld\n",(unsigned long)sbi->max_cluster);
+	PRINTK("FATX: fatx_bits:		%d\n",(int)sbi->fatx_bits);
+	PRINTK("FATX: fatx_length:		%d\n",(int)sbi->fatx_length);
+	PRINTK("FATX: root_dir_sectors:		%d\n",(int)CLUSTER_SIZE);
+	PRINTK("FATX: dir_per_block:		%d\n",(int)sbi->dir_per_block);
+	PRINTK("FATX: dir_per_block_bits:	%d\n",(int)sbi->dir_per_block_bits);
+	PRINTK("FATX: dir_entries :		%d\n",(int)sbi->dir_entries);
+	PRINTK("FATX: cluster_bits:		%d\n",(int)sbi->cluster_bits);
+	PRINTK("FATX: sec_per_clus:		%d\n",(int)sbi->sec_per_clus);
+	PRINTK("FATX: cluster_size:		%d\n",(int)sbi->cluster_size);
+	PRINTK("FATX: s_blocksize_bits:		%d\n",(int)sb->s_blocksize_bits);
+	PRINTK("FATX: fatx_bits:		%d\n",(int)sbi->fatx_bits);
+	PRINTK("FATX: leaving total_sectors:	%d\n",total_sectors);
+	PRINTK("FATX: sizeof fatx_dir_entry:	%d\n",sizeof(struct fatx_dir_entry));
+
+	return 0;
+
+out_fail:
+	if (root_inode)
+		iput(root_inode);
+	if (sbi->nls_io)
+		unload_nls(sbi->nls_io);
+	kfree(sbi);
+	return error;
+}
+
+EXPORT_SYMBOL(fatx_fill_super_inode);
+
+int __init fatx_cache_init(void);
+void __exit fatx_cache_destroy(void);
+
+static struct file_system_type fatx_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "fatx",
+	.get_sb		= fatx_get_sb,
+	.kill_sb	= kill_block_super,
+	.fs_flags	= FS_REQUIRES_DEV,
+};
+
+static int __init init_fatx_fs(void)
+{
+	int ret;
+
+	ret = fatx_cache_init();
+	if (ret < 0)
+		return ret;
+	printk("FATX: 0.0.3\n");
+	fatx_init_inodecache();
+	return register_filesystem(&fatx_fs_type);
+}
+
+static void __exit exit_fatx_fs(void)
+{
+	fatx_cache_destroy();
+	fatx_destroy_inodecache();
+	unregister_filesystem(&fatx_fs_type);
+}
+
+module_init(init_fatx_fs)
+module_exit(exit_fatx_fs)
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("FATX filesystem support");
+module_param(fatx_debug,int,0);
+MODULE_PARM_DESC(fatxx_debug,"turn on fatxx debugging output");
diff -uprN a/fs/fatx/misc.c b/fs/fatx/misc.c
--- a/fs/fatx/misc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/fs/fatx/misc.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,199 @@
+/*
+ *  linux/fs/fatx/misc.c
+ *
+ *  Written 1992,1993 by Werner Almesberger
+ *  22/11/2000 - Fixed fatx_date_unix2dos for dates earlier than 01/01/1980
+ *		 and date_dos2unix for date==0 by Igor Zhbanov(bsg@uniyar.ac.ru)
+ *
+ *  FATX port 2005 by Edgar Hucek
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/fatx_fs.h>
+#include <linux/buffer_head.h>
+
+#define PRINTK(format, args...) do { if (fatx_debug) printk( format, ##args ); } while(0)
+
+/*
+ * fatx_fs_panic reports a severe file system problem and sets the file system
+ * read-only. The file system can be made writable again by remounting it.
+ */
+void fatx_fs_panic(struct super_block *s, const char *fmt, ...)
+{
+	va_list args;
+
+	printk(KERN_ERR "FATX: Filesystem panic (dev %s)\n", s->s_id);
+
+	printk(KERN_ERR "    ");
+	va_start(args, fmt);
+	vprintk(fmt, args);
+	va_end(args);
+	printk("\n");
+
+	if (!(s->s_flags & MS_RDONLY)) {
+		s->s_flags |= MS_RDONLY;
+		printk(KERN_ERR "    File system has been set read-only\n");
+	}
+}
+
+EXPORT_SYMBOL(fatx_fs_panic);
+
+/*
+ * fatx_chain_add() adds a new cluster to the chain of clusters represented
+ * by inode.
+ */
+__s64 fatx_chain_add(struct inode *inode, int new_dclus, int nr_cluster)
+{
+	struct super_block *sb = inode->i_sb;
+	struct fatx_sb_info *sbi = FATX_SB(sb);
+	__s64 ret; 
+	int new_fclus, last;
+
+	/*
+	 * We must locate the last cluster of the file to add this new
+	 * one (new_dclus) to the end of the link list (the FATX).
+	 */
+	last = new_fclus = 0;
+	if (FATX_I(inode)->i_start) {
+		int fclus, dclus;
+
+		PRINTK("FATX: %s new_fclus %d  inode->i_blocks %ld sbi->cluster_bits %d\n",
+			__FUNCTION__, new_fclus,  inode->i_blocks, sbi->cluster_bits);
+		ret = fatx_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);
+		if (ret < 0)
+			return ret;
+		new_fclus = fclus + 1;
+		last = dclus;
+	}
+
+	/* add new one to the last of the cluster chain */
+	if (last) {
+		struct fatx_entry fatxent;
+
+		fatxent_init(&fatxent);
+		ret = fatx_ent_read(inode, &fatxent, last);
+		if (ret >= 0) {
+			int wait = inode_needs_sync(inode);
+			ret = fatx_ent_write(inode, &fatxent, new_dclus, wait);
+			fatxent_brelse(&fatxent);
+		}
+		if (ret < 0)
+			return ret;
+//		fatx_cache_add(inode, new_fclus, new_dclus);
+	} else {
+		FATX_I(inode)->i_start = new_dclus;
+		FATX_I(inode)->i_logstart = new_dclus;
+		/*
+		 * Since generic_osync_inode() synchronize later if
+		 * this is not directory, we don't here.
+		 */
+		if (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode)) {
+			ret = fatx_sync_inode(inode);
+			if (ret)
+				return ret;
+		} else
+			mark_inode_dirty(inode);
+	}
+	if (new_fclus != (inode->i_blocks >> (sbi->cluster_bits - 9))) {
+		fatx_fs_panic(sb, "clusters badly computed (%d != %lu)",
+			new_fclus, inode->i_blocks >> (sbi->cluster_bits - 9));
+		fatx_cache_inval_inode(inode);
+	}
+	inode->i_blocks += nr_cluster << (sbi->cluster_bits - 9);
+
+	return 0;
+}
+
+extern struct timezone sys_tz;
+
+/* Linear day numbers of the respective 1sts in non-leap years. */
+static int day_n[] = {
+   /* Jan  Feb  Mar  Apr   May  Jun  Jul  Aug  Sep  Oct  Nov  Dec */
+	0,  31,  59,  90,  120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0, 0
+};
+
+int fatx_date_dos2unix(unsigned short time,unsigned short date)
+{
+	int month,year,secs,days;
+
+	/* first subtract and mask after that... Otherwise, if
+	   date == 0, bad things happen */
+	month=  ((date >> 5) - 1) & 15;
+	year =  date >> 9;
+	days =  (date & 31)-1+day_n[month]+(year/4)+(year+30)*365;
+	//skipped and current leap years
+	days += ((year & 3) == 0 && month < 2 ? 0 : 1) + 7; 
+	
+	secs =  (time & 31)*2;		//seconds into curr minute
+	secs += 60*((time >> 5) & 63);	//minutes into curr hour
+	secs += 3600*(time >> 11);	//hours into curr day
+	secs += 86400*days;		//days (from 1.1.70)
+	
+	secs += sys_tz.tz_minuteswest*60;
+	return secs;
+}
+
+/* Convert linear UNIX date to a MS-DOS time/date pair. */
+void fatx_date_unix2dos(int unix_date,unsigned short *time,
+    unsigned short *date)
+{
+	int day,year,nl_day,month;
+
+	unix_date -= sys_tz.tz_minuteswest*60;
+
+	/* bound low end at Jan 1 GMT 00:00:00 2000. */
+	if (unix_date < ((30 * 365) + 7) * 24 * 60 * 60) {
+		unix_date = ((30 * 365) + 7) * 24 * 60 * 60;
+	}
+		
+	*time = (unix_date % 60)/2 + 			//seconds
+		(((unix_date/60) % 60) << 5) +		//minutes
+		(((unix_date/3600) % 24) << 11);	//hours
+	
+	day = unix_date/86400-(30 * 365 + 7);		//days (from 1.1.2000)
+	year = day/365;
+	if ((year+3)/4+365*year > day) year--;
+	day -= (year+3)/4+365*year;
+	if (day == 59 && !(year & 3)) {
+		nl_day = day;
+		month = 2;
+	}
+	else {
+		nl_day = (year & 3) || day <= 59 ? day : day-1;
+		for (month = 0; month < 12; month++)
+			if (day_n[month] > nl_day) break;
+	}
+	*date = nl_day-day_n[month-1]+1+(month << 5)+(year << 9);
+}
+
+EXPORT_SYMBOL(fatx_date_unix2dos);
+
+int fatx_sync_bhs(struct buffer_head **bhs, int nr_bhs)
+{
+	int i, e, err = 0;
+
+	for (i = 0; i < nr_bhs; i++) {
+		lock_buffer(bhs[i]);
+		if (test_clear_buffer_dirty(bhs[i])) {
+			get_bh(bhs[i]);
+			bhs[i]->b_end_io = end_buffer_write_sync;
+			e = submit_bh(WRITE, bhs[i]);
+			if (!err && e)
+				err = e;
+		} else
+			unlock_buffer(bhs[i]);
+	}
+	for (i = 0; i < nr_bhs; i++) {
+		wait_on_buffer(bhs[i]);
+		if (buffer_eopnotsupp(bhs[i])) {
+			clear_buffer_eopnotsupp(bhs[i]);
+			err = -EOPNOTSUPP;
+		} else if (!err && !buffer_uptodate(bhs[i]))
+			err = -EIO;
+	}
+	return err;
+}
+
+EXPORT_SYMBOL(fatx_sync_bhs);
diff -uprN a/fs/fatx/namei.c b/fs/fatx/namei.c
--- a/fs/fatx/namei.c	1970-01-01 01:00:00.000000000 +0100
+++ b/fs/fatx/namei.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,598 @@
+/*
+ *  linux/fs/fatx/namei.c
+ *
+ *  Written 1992,1993 by Werner Almesberger
+ *  Hidden files 1995 by Albert Cahalan <albert@ccs.neu.edu> <adc@coe.neu.edu>
+ *  Rewritten for constant inumbers 1999 by Al Viro
+ *
+ *  FATX port 2005 by Edgar Hucek
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/buffer_head.h>
+#include <linux/fatx_fs.h>
+#include <linux/smp_lock.h>
+
+#define PRINTK(format, args...) do { if (fatx_debug) printk( format, ##args ); } while(0)
+
+/* Characters that are undesirable in an MS-DOS file name */
+static unsigned char bad_chars[] = "*?<>|\"";
+
+void fatx_printname(const char *name, int length)
+{
+	int i;
+	for(i=0;i<length;i++) {
+		printk("%c",name[i]);
+	}
+	printk("  len %d",length);
+}
+
+/***** Formats an MS-DOS file name. Rejects invalid names. */
+int fatx_format_name(const unsigned char *name, int len,
+			     unsigned char *out_name)
+{
+	int i;
+	char trash[FATX_NAME];
+
+	if (len > FATX_NAME) return -EINVAL;
+
+	if (out_name == NULL) out_name = trash;
+
+	memset(out_name,0xFF,FATX_NAME);
+
+	//check for bad characters in name
+	for(i=0; i<len; i++) {
+		if (strchr(bad_chars,name[i])) return -EINVAL;
+			out_name[i] = name[i];
+	}
+	
+	return 0;
+}
+
+/***** Locates a directory entry.  Uses unformatted name. */
+static int fatx_find(struct inode *dir, const unsigned char *name, int len,
+		      struct fatx_slot_info *sinfo)
+{
+	unsigned char fatx_name[FATX_NAME];
+	int err;
+
+	err = fatx_format_name(name, len, fatx_name);
+	if (err)
+		return -ENOENT;
+
+	err = fatx_scan(dir, fatx_name, sinfo);
+	if (err)
+		brelse(sinfo->bh);
+	return err;
+}
+
+/*
+ * Compute the hash for the fatx name corresponding to the dentry.
+ * Note: if the name is invalid, we leave the hash code unchanged so
+ * that the existing dentry can be used. The fatx fs routines will
+ * return ENOENT or EINVAL as appropriate.
+ */
+static int fatx_hash(struct dentry *dentry, struct qstr *qstr)
+{
+	unsigned char fatx_name[FATX_NAME];
+	int error;
+
+	error = fatx_format_name(qstr->name, qstr->len, fatx_name);
+	if (!error)
+		qstr->hash = full_name_hash(fatx_name, FATX_NAME);
+	return 0;
+}
+
+/*
+ * Compare two fatx names. If either of the names are invalid,
+ * we fall back to doing the standard name comparison.
+ */
+static int fatx_cmp(struct dentry *dentry, struct qstr *a, struct qstr *b)
+{
+	unsigned char a_fatx_name[FATX_NAME], b_fatx_name[FATX_NAME];
+	int error;
+
+	error = fatx_format_name(a->name, a->len, a_fatx_name);
+	if (error)
+		goto old_compare;
+	error = fatx_format_name(b->name, b->len, b_fatx_name);
+	if (error)
+		goto old_compare;
+	error = memcmp(a_fatx_name, b_fatx_name, FATX_NAME);
+out:
+	return error;
+
+old_compare:
+	error = 1;
+	if (a->len == b->len)
+		error = memcmp(a->name, b->name, a->len);
+	goto out;
+}
+
+static struct dentry_operations fatx_dentry_operations = {
+	.d_hash		= fatx_hash,
+	.d_compare	= fatx_cmp,
+};
+
+/*
+ * AV. Wrappers for FAT sb operations. Is it wise?
+ */
+
+/***** Get inode using directory and name */
+static struct dentry *fatx_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *nd)
+{
+	struct super_block *sb = dir->i_sb;
+	struct fatx_slot_info sinfo;
+	struct inode *inode = NULL;
+	int res;
+
+	dentry->d_op = &fatx_dentry_operations;
+
+	lock_kernel();
+	res = fatx_find(dir, dentry->d_name.name, dentry->d_name.len, &sinfo);
+	if (res == -ENOENT)
+		goto add;
+	if (res < 0)
+		goto out;
+	inode = fatx_build_inode(sb, sinfo.de, sinfo.i_pos);
+	brelse(sinfo.bh);
+	if (IS_ERR(inode)) {
+		res = PTR_ERR(inode);
+		goto out;
+	}
+add:
+	res = 0;
+	dentry = d_splice_alias(inode, dentry);
+	if (dentry)
+		dentry->d_op = &fatx_dentry_operations;
+out:
+	unlock_kernel();
+	if (!res)
+		return dentry;
+	return ERR_PTR(res);
+}
+
+/***** Creates a directory entry (name is already formatted). */
+static int fatx_add_entry(struct inode *dir, const unsigned char *name, int len,
+			   int is_dir, int cluster,
+			   struct timespec *ts, struct fatx_slot_info *sinfo)
+{
+	struct fatx_dir_entry de;
+	__le16 time, date;
+	int err;
+
+	memset(de.name,0xFF,FATX_NAME);
+	memcpy(de.name, name, FATX_NAME);
+	de.attr = is_dir ? ATTR_DIR : ATTR_ARCH;
+	de.name_length = len;
+	fatx_date_unix2dos(ts->tv_sec, &time, &date);
+	de.cdate = de.adate = 0;
+	de.ctime = 0;
+	de.time = time;
+	de.date = date;
+	de.start = cpu_to_le32(cluster);
+	de.size = 0;
+
+	err = fatx_add_entries(dir, &de, sinfo);
+	if (err)
+		return err;
+
+	dir->i_ctime = dir->i_mtime = *ts;
+	if (IS_DIRSYNC(dir))
+		(void)fatx_sync_inode(dir);
+	else
+		mark_inode_dirty(dir);
+
+	return 0;
+}
+
+/***** Create a file */
+static int fatx_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *nd)
+{
+	struct super_block *sb = dir->i_sb;
+	struct inode *inode;
+	struct fatx_slot_info sinfo;
+	struct timespec ts;
+	unsigned char fatx_name[FATX_NAME];
+	int err;
+
+	PRINTK("FATX: %s\n", __FUNCTION__ );
+	lock_kernel();
+
+	err = fatx_format_name(dentry->d_name.name, dentry->d_name.len, fatx_name);
+	if (err)
+		goto out;
+	/* Have to do it due to foo vs. .foo conflicts */
+	if (!fatx_scan(dir, fatx_name, &sinfo)) {
+		brelse(sinfo.bh);
+		err = -EINVAL;
+		goto out;
+	}
+
+	ts = CURRENT_TIME;
+	err = fatx_add_entry(dir, fatx_name, dentry->d_name.len, 0, 0, &ts, &sinfo);
+	if (err)
+		goto out;
+	inode = fatx_build_inode(sb, sinfo.de, sinfo.i_pos);
+	brelse(sinfo.bh);
+	if (IS_ERR(inode)) {
+		err = PTR_ERR(inode);
+		goto out;
+	}
+	inode->i_mtime = inode->i_atime = inode->i_ctime = ts;
+	/* timestamp is already written, so mark_inode_dirty() is unneeded. */
+
+	dentry->d_time = dentry->d_parent->d_inode->i_version;
+	d_instantiate(dentry, inode);
+
+out:
+	unlock_kernel();
+	return err;
+}
+
+/***** Remove a directory */
+static int fatx_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	struct inode *inode = dentry->d_inode;
+	struct fatx_slot_info sinfo;
+	int err;
+
+	PRINTK("FATX: %s\n", __FUNCTION__);
+	lock_kernel();
+	/*
+	 * Check whether the directory is not in use, then check
+	 * whether it is empty.
+	 */
+	err = fatx_dir_empty(inode);
+	if (err) {
+		PRINTK("FATX: %s fatx_remove_entries error\n", __FUNCTION__);
+		goto out;
+	}
+	err = fatx_find(dir, dentry->d_name.name, dentry->d_name.len, &sinfo);
+	if (err) {
+		PRINTK("FATX: %s fatx_find error\n", __FUNCTION__);
+		goto out;
+	}
+	err = fatx_remove_entries(dir, &sinfo);	/* and releases bh */
+	if (err) {
+		PRINTK("FATX: %s fatx_find error\n", __FUNCTION__);
+		goto out;
+	}
+	dir->i_nlink--;
+
+	inode->i_nlink = 0;
+	inode->i_ctime = CURRENT_TIME;
+	fatx_detach(inode);
+out:
+	unlock_kernel();
+
+	return err;
+}
+
+/***** Make a directory */
+static int fatx_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	struct super_block *sb = dir->i_sb;
+	struct fatx_slot_info sinfo;
+	struct inode *inode;
+	unsigned char fatx_name[FATX_NAME];
+	struct timespec ts;
+	int err, cluster;
+
+	lock_kernel();
+
+	PRINTK("FATX: %s\n", __FUNCTION__ );
+	err = fatx_format_name(dentry->d_name.name, dentry->d_name.len, fatx_name);
+	if (err)
+		goto out;
+	/* foo vs .foo situation */
+	if (!fatx_scan(dir, fatx_name, &sinfo)) {
+		brelse(sinfo.bh);
+		PRINTK("FATX: %s fatx_scan failed\n", __FUNCTION__ );
+		err = -EINVAL;
+		goto out;
+	}
+
+	ts = CURRENT_TIME;
+	cluster = fatx_alloc_new_dir(dir, &ts);
+	if (cluster < 0) {
+		PRINTK("FATX: %s fatx_alloc_new_dir failed\n", __FUNCTION__ );
+		err = cluster;
+		goto out;
+	}
+	err = fatx_add_entry(dir, fatx_name, dentry->d_name.len, 1, cluster, &ts, &sinfo);
+	if (err) {
+		PRINTK("FATX: %s fatx_add_entry failed\n", __FUNCTION__ );
+		goto out_free;
+	}
+
+	dir->i_nlink++;
+
+	inode = fatx_build_inode(sb, sinfo.de, sinfo.i_pos);
+	brelse(sinfo.bh);
+	if (IS_ERR(inode)) {
+		err = PTR_ERR(inode);
+		/* the directory was completed, just return a error */
+		PRINTK("FATX: %s fatx_build_inode failed\n", __FUNCTION__ );
+		goto out;
+	}
+	inode->i_nlink = 2;
+	inode->i_mtime = inode->i_atime = inode->i_ctime = ts;
+	/* timestamp is already written, so mark_inode_dirty() is unneeded. */
+
+	dentry->d_time = dentry->d_parent->d_inode->i_version;
+	d_instantiate(dentry, inode);
+
+	PRINTK("FATX: %s exit\n", __FUNCTION__ );
+	unlock_kernel();
+	return 0;
+
+out_free:
+	fatx_free_clusters(dir, cluster);
+out:
+	unlock_kernel();
+	return err;
+}
+
+/***** Unlink a file */
+static int fatx_unlink(struct inode *dir, struct dentry *dentry)
+{
+	struct inode *inode = dentry->d_inode;
+	struct fatx_slot_info sinfo;
+	int err;
+
+	PRINTK("FATX: %s\n", __FUNCTION__);
+	lock_kernel();
+	err = fatx_find(dir, dentry->d_name.name, dentry->d_name.len, &sinfo);
+	if (err)
+		goto out;
+
+	err = fatx_remove_entries(dir, &sinfo);	/* and releases bh */
+	if (err)
+		goto out;
+	inode->i_nlink = 0;
+	inode->i_ctime = CURRENT_TIME;
+	fatx_detach(inode);
+out:
+	unlock_kernel();
+
+	return err;
+}
+
+static int do_fatx_rename(struct inode *old_dir, unsigned char *old_name,
+			   struct dentry *old_dentry,
+			   struct inode *new_dir, unsigned char *new_name,
+			   struct dentry *new_dentry)
+{
+	/*
+	struct buffer_head *dotdot_bh;
+	struct fatx_dir_entry *dotdot_de;
+	loff_t dotdot_i_pos;
+	*/
+	struct inode *old_inode, *new_inode;
+	struct fatx_slot_info old_sinfo, sinfo;
+	struct timespec ts;
+	//int update_dotdot;
+	int err, old_attrs, is_dir, corrupt = 0;
+	int new_name_len = new_dentry->d_name.len;
+
+	PRINTK("FATX: %s\n", __FUNCTION__ );
+
+	//old_sinfo.bh = sinfo.bh = dotdot_bh = NULL;
+	old_sinfo.bh = sinfo.bh = NULL;
+	old_inode = old_dentry->d_inode;
+	new_inode = new_dentry->d_inode;
+
+	err = fatx_scan(old_dir, old_name, &old_sinfo);
+	if (err) {
+		err = -EIO;
+		goto out;
+	}
+
+	is_dir = S_ISDIR(old_inode->i_mode);
+	/*
+	update_dotdot = (is_dir && old_dir != new_dir);
+	if (update_dotdot) {
+		if (fatx_get_dotdot_entry(old_inode, &dotdot_bh, &dotdot_de,
+					 &dotdot_i_pos) < 0) {
+			err = -EIO;
+			goto out;
+		}
+	}
+	*/
+	old_attrs = FATX_I(old_inode)->i_attrs;
+	err = fatx_scan(new_dir, new_name, &sinfo);
+	if (!err) {
+		if (!new_inode) {
+			/* "foo" -> ".foo" case. just change the ATTR_HIDDEN */
+			if (sinfo.de != old_sinfo.de) {
+				err = -EINVAL;
+				goto out;
+			}
+			FATX_I(old_inode)->i_attrs &= ~ATTR_HIDDEN;
+			if (IS_DIRSYNC(old_dir)) {
+				err = fatx_sync_inode(old_inode);
+				if (err) {
+					FATX_I(old_inode)->i_attrs = old_attrs;
+					goto out;
+				}
+			} else
+				mark_inode_dirty(old_inode);
+
+			old_dir->i_version++;
+			old_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME;
+			if (IS_DIRSYNC(old_dir))
+				(void)fatx_sync_inode(old_dir);
+			else
+				mark_inode_dirty(old_dir);
+			goto out;
+		}
+	}
+
+	ts = CURRENT_TIME;
+	if (new_inode) {
+		if (err)
+			goto out;
+		if (FATX_I(new_inode)->i_pos != sinfo.i_pos) {
+			/* WTF??? Cry and fail. */
+			printk(KERN_WARNING "fatx_rename: fs corrupted\n");
+			goto out;
+		}
+
+		if (is_dir) {
+			err = fatx_dir_empty(new_inode);
+			if (err)
+				goto out;
+		}
+		fatx_detach(new_inode);
+	} else {
+		err = fatx_add_entry(new_dir, new_name, new_name_len, is_dir, 0,
+				      &ts, &sinfo);
+		if (err)
+			goto out;
+	}
+	new_dir->i_version++;
+
+	fatx_detach(old_inode);
+	fatx_attach(old_inode, sinfo.i_pos);
+	FATX_I(old_inode)->i_attrs &= ~ATTR_HIDDEN;
+	if (IS_DIRSYNC(new_dir)) {
+		err = fatx_sync_inode(old_inode);
+		if (err)
+			goto error_inode;
+	} else
+		mark_inode_dirty(old_inode);
+
+	/*
+	if (update_dotdot) {
+		int start = FATX_I(new_dir)->i_logstart;
+		dotdot_de->start = cpu_to_le32(start);
+		mark_buffer_dirty(dotdot_bh);
+		if (IS_DIRSYNC(new_dir)) {
+			err = sync_dirty_buffer(dotdot_bh);
+			if (err)
+				goto error_dotdot;
+		}
+		old_dir->i_nlink--;
+		if (!new_inode)
+			new_dir->i_nlink++;
+	}
+	*/
+	
+	err = fatx_remove_entries(old_dir, &old_sinfo);	/* and releases bh */
+	old_sinfo.bh = NULL;
+	if (err)
+		goto error_dotdot;
+	old_dir->i_version++;
+	old_dir->i_ctime = old_dir->i_mtime = ts;
+	if (IS_DIRSYNC(old_dir))
+		(void)fatx_sync_inode(old_dir);
+	else
+		mark_inode_dirty(old_dir);
+
+	if (new_inode) {
+		if (is_dir)
+			new_inode->i_nlink -= 2;
+		else
+			new_inode->i_nlink--;
+		new_inode->i_ctime = ts;
+	}
+out:
+	brelse(sinfo.bh);
+	brelse(old_sinfo.bh);
+	return err;
+
+error_dotdot:
+	corrupt = 1;
+	
+	/*
+	if (update_dotdot) {
+		int start = FATX_I(old_dir)->i_logstart;
+		dotdot_de->start = cpu_to_le32(start);
+		mark_buffer_dirty(dotdot_bh);
+		corrupt |= sync_dirty_buffer(dotdot_bh);
+	}
+	*/
+error_inode:
+	fatx_detach(old_inode);
+	fatx_attach(old_inode, old_sinfo.i_pos);
+	FATX_I(old_inode)->i_attrs = old_attrs;
+	if (new_inode) {
+		fatx_attach(new_inode, sinfo.i_pos);
+		if (corrupt)
+			corrupt |= fatx_sync_inode(new_inode);
+	} else {
+		/*
+		 * If new entry was not sharing the data cluster, it
+		 * shouldn't be serious corruption.
+		 */
+		int err2 = fatx_remove_entries(new_dir, &sinfo);
+		if (corrupt)
+			corrupt |= err2;
+		sinfo.bh = NULL;
+	}
+	if (corrupt < 0) {
+		fatx_fs_panic(new_dir->i_sb,
+			     "%s: Filesystem corrupted (i_pos %lld)",
+			     __FUNCTION__, sinfo.i_pos);
+	}
+	goto out;
+}
+
+/***** Rename, a wrapper for rename_same_dir & rename_diff_dir */
+static int fatx_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry)
+{
+	unsigned char old_fatx_name[FATX_NAME], new_fatx_name[FATX_NAME];
+	int err;
+
+	lock_kernel();
+
+	err = fatx_format_name(old_dentry->d_name.name,
+				old_dentry->d_name.len, old_fatx_name);
+	if (err)
+		goto out;
+	err = fatx_format_name(new_dentry->d_name.name,
+				new_dentry->d_name.len, new_fatx_name);
+	if (err)
+		goto out;
+
+	err = do_fatx_rename(old_dir, old_fatx_name, old_dentry,
+			      new_dir, new_fatx_name, new_dentry);
+out:
+	unlock_kernel();
+	return err;
+}
+
+static struct inode_operations fatx_dir_inode_operations = {
+	.create		= fatx_create,
+	.lookup		= fatx_lookup,
+	.unlink		= fatx_unlink,
+	.mkdir		= fatx_mkdir,
+	.rmdir		= fatx_rmdir,
+	.rename		= fatx_rename,
+	.setattr	= fatx_notify_change,
+};
+
+static int fatx_fill_super(struct super_block *sb, void *data, int silent)
+{
+	int res;
+
+	res = fatx_fill_super_inode(sb, data, silent, &fatx_dir_inode_operations);
+	if (res)
+		return res;
+
+	sb->s_root->d_op = &fatx_dentry_operations;
+	return 0;
+}
+
+int fatx_get_sb(struct file_system_type *fs_type,
+                                        int flags, const char *dev_name,
+                                        void *data, struct vfsmount *mnt)
+{
+        return get_sb_bdev(fs_type, flags, dev_name, data, fatx_fill_super,mnt);
+}
diff -uprN a/fs/partitions/Kconfig b/fs/partitions/Kconfig
--- a/fs/partitions/Kconfig	2007-07-09 00:32:17.000000000 +0100
+++ b/fs/partitions/Kconfig	2007-10-12 11:17:00.000000000 +0100
@@ -241,6 +241,14 @@ config EFI_PARTITION
 	  Say Y here if you would like to use hard disks under Linux which
 	  were partitioned using EFI GPT.
 
+config XBOX_PARTITION
+	bool "Xbox Partition support (EXPERIMENTAL)" if PARTITION_ADVANCED && EXPERIMENTAL && BROKEN
+	default y if X86_XBOX
+	help
+	  Say Y here if you are running Linux on the Xbox, or would
+	  like to access a hard disk partitioned for the Xbox under
+	  a PC running Linux. Otherwise, say N.
+
 config SYSV68_PARTITION
 	bool "SYSV68 partition table support" if PARTITION_ADVANCED
 	default y if VME
diff -uprN a/fs/partitions/Makefile b/fs/partitions/Makefile
--- a/fs/partitions/Makefile	2007-07-09 00:32:17.000000000 +0100
+++ b/fs/partitions/Makefile	2007-10-12 11:17:00.000000000 +0100
@@ -18,3 +18,4 @@ obj-$(CONFIG_IBM_PARTITION) += ibm.o
 obj-$(CONFIG_EFI_PARTITION) += efi.o
 obj-$(CONFIG_KARMA_PARTITION) += karma.o
 obj-$(CONFIG_SYSV68_PARTITION) += sysv68.o
+obj-$(CONFIG_XBOX_PARTITION) += xbox.o
diff -uprN a/fs/partitions/check.c b/fs/partitions/check.c
--- a/fs/partitions/check.c	2007-07-09 00:32:17.000000000 +0100
+++ b/fs/partitions/check.c	2007-10-12 11:17:00.000000000 +0100
@@ -35,6 +35,7 @@
 #include "efi.h"
 #include "karma.h"
 #include "sysv68.h"
+#include "xbox.h"
 
 #ifdef CONFIG_BLK_DEV_MD
 extern void md_autodetect_dev(dev_t dev);
@@ -182,6 +183,14 @@ check_partition(struct gendisk *hd, stru
 		}
 
 	}
+#ifdef CONFIG_XBOX_PARTITION
+        {
+                int xbox;
+
+                xbox = xbox_partition(state, bdev);
+                if(!res) res = xbox;
+        }
+#endif
 	if (res > 0)
 		return state;
 	if (err)
diff -uprN a/fs/partitions/xbox.c b/fs/partitions/xbox.c
--- a/fs/partitions/xbox.c	1970-01-01 01:00:00.000000000 +0100
+++ b/fs/partitions/xbox.c	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,216 @@
+/*
+ * fs/partitions/xbox.c
+ * Xbox disk partition support.
+ *
+ * Copyright (C) 2002  John Scott Tillman <speedbump@users.sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/errno.h>
+#include <linux/genhd.h>
+#include <linux/kernel.h>
+
+#include "check.h"
+#include "xbox.h"
+
+
+/*
+ * The native Xbox kernel makes use of an implicit partitioning
+ * scheme. Partition locations and sizes on-disk are hard-coded.
+ */
+#define XBOX_CONFIG_START   0x00000000L
+#define XBOX_CACHE1_START   0x00000400L
+#define XBOX_CACHE2_START   0x00177400L
+#define XBOX_CACHE3_START   0x002EE400L
+#define XBOX_SYSTEM_START   0x00465400L
+#define XBOX_DATA_START     0x0055F400L
+#define XBOX_EXTEND_F_START 0x00EE8AB0L
+#define XBOX_EXTEND_G_START 0x0FFFFFFFL
+
+#define XBOX_CONFIG_SIZE    (XBOX_CACHE1_START - XBOX_CONFIG_START)
+#define XBOX_CACHE1_SIZE    (XBOX_CACHE2_START - XBOX_CACHE1_START)
+#define XBOX_CACHE2_SIZE    (XBOX_CACHE3_START - XBOX_CACHE2_START)
+#define XBOX_CACHE3_SIZE    (XBOX_SYSTEM_START - XBOX_CACHE3_START)
+#define XBOX_SYSTEM_SIZE    (XBOX_DATA_START - XBOX_SYSTEM_START)
+#define XBOX_DATA_SIZE      (XBOX_EXTEND_F_START - XBOX_DATA_START)
+#define XBOX_EXTEND_F_SIZE  (XBOX_EXTEND_G_START - XBOX_EXTEND_F_START)
+
+#define XBOX_MAGIC_SECT       3L
+#define XBOX_PARTITION_IN_USE 0x80000000
+#define XBOX_DEV_MINOR_START  50
+
+#define XBOX_EXT_PART_NKP06  1
+#define XBOX_EXT_PART_NKP67  2
+
+
+typedef struct
+{
+    char name[16];
+    u32  flags;
+    u32  start;
+    u32  size;
+    u32  reserved;
+} xbox_partition_entry;
+
+typedef struct
+{
+    char                 magic[16];
+    char                 reserved[32];
+    xbox_partition_entry partitions[14];
+} xbox_partition_table;
+
+static int xbox_ext_partition_type = 0;
+
+static int __init xbox_setup_ext_partition(char *str)
+{
+    int val;
+    if (get_option(&str,&val) == 1) {
+      xbox_ext_partition_type = val;
+    }
+
+    return 1;
+}
+
+__setup("xboxpartition=", xbox_setup_ext_partition);
+
+
+static int xbox_check_magic(struct block_device *bdev, sector_t at_sect,
+        char *magic)
+{
+    Sector sect;
+    char *data;
+    int ret;
+
+    data = read_dev_sector(bdev, at_sect, &sect);
+    if (!data)
+        return -1;
+
+    /* Ick! */
+    ret = (*(u32*)data == *(u32*)magic) ? 1 : 0;
+    put_dev_sector(sect);
+
+    return ret;
+}
+
+static inline int xbox_drive_detect(struct block_device *bdev)
+{
+    /**
+    * "BRFR" is apparently the magic number in the config area
+    * the others are just paranoid checks to assure the expected
+    * "FATX" tags for the other xbox partitions
+    *
+    * the odds against a non-xbox drive having random data to match is
+    * astronomical...but it's possible I guess...you should only include
+    * this check if you actually *have* an xbox drive...since it has to
+    * be detected first
+    *
+    * @see check.c
+    */
+    return (xbox_check_magic(bdev, XBOX_MAGIC_SECT, "BRFR") &&
+        xbox_check_magic(bdev, XBOX_SYSTEM_START, "FATX") &&
+        xbox_check_magic(bdev, XBOX_DATA_START, "FATX")) ?
+        0 : -ENODEV;
+}
+
+static inline int
+xbox_ptbl_detect(struct block_device *bdev)
+{
+    /**
+    * check for "BRFR" magic number, then for "****PARTINFO****" at
+    * start of zeroth sector. This intentionally doesn't check for
+    * FATX signatures at the expected system and store locations
+    * as it's possible for these partitions to have been moved.
+    */
+    if (xbox_check_magic(bdev,XBOX_MAGIC_SECT,"BRFR")) {
+        Sector sect;
+        int retv;
+        xbox_partition_table *table;
+
+        table = (xbox_partition_table*)read_dev_sector(bdev, XBOX_CONFIG_START, &sect);
+
+        if (!table) return 0;
+
+        if (strncmp(table->magic, "****PARTINFO****", 16) == 0) retv = 1; else retv = 0;
+
+        put_dev_sector(sect);
+        return retv;
+    }
+
+    return 0; // no xbox drive
+}
+
+int xbox_partition(struct parsed_partitions *state, struct block_device *bdev)
+{
+    sector_t disk_size = bdev->bd_disk->capacity;
+
+    if (xbox_ext_partition_type == 0 && xbox_ptbl_detect(bdev)) {
+        int i;
+        Sector sect;
+        xbox_partition_table *table = (xbox_partition_table*)read_dev_sector(bdev,
+            XBOX_CONFIG_START, &sect);
+
+        if (!table) return 0;
+
+        printk(" [xbox_partition]");
+
+        for (i=0; i<14; i++) {
+            xbox_partition_entry *part = &table->partitions[i];
+            if (part->flags & XBOX_PARTITION_IN_USE) {
+                if (part->start >= disk_size)
+                    printk("xbox_partition: partition %d starts off the end of the disk, at sector %d, skipping\n", i, part->start);
+                else if (part->start + part->size > disk_size)
+                    printk("xbox_partition: partition %d extends past the end of the disk, to sector %d, skipping\n", i, part->start + part->size - 1);
+                else
+                    put_partition(state, XBOX_DEV_MINOR_START+i+bdev->bd_disk->first_minor,
+                        part->start, part->size);
+            }
+        }
+
+        put_dev_sector(sect);
+        return 1;
+    } else {
+        int err = xbox_drive_detect(bdev);
+        if (err)
+            return err;
+
+        printk(" [xbox]");
+        int slot = XBOX_DEV_MINOR_START + bdev->bd_disk->first_minor;
+        put_partition(state, slot++, XBOX_DATA_START, XBOX_DATA_SIZE);
+        put_partition(state, slot++, XBOX_SYSTEM_START, XBOX_SYSTEM_SIZE);
+        put_partition(state, slot++, XBOX_CACHE1_START, XBOX_CACHE1_SIZE);
+        put_partition(state, slot++, XBOX_CACHE2_START, XBOX_CACHE2_SIZE);
+        put_partition(state, slot++, XBOX_CACHE3_START, XBOX_CACHE3_SIZE);
+
+        if (disk_size <= XBOX_EXTEND_F_START)
+            goto out; /* no extended partitions */
+
+        /* Support for fixed size 'extended partitions' */
+        if (XBOX_EXTEND_G_START < disk_size) {
+            /* use NKPatcher67 style F and G drive */
+            if ( xbox_ext_partition_type == XBOX_EXT_PART_NKP67 ) {
+                /* There's an F and G on this system - F only goes to the LBA28 boundary */
+                put_partition(state, slot++, XBOX_EXTEND_F_START,
+                    XBOX_EXTEND_F_SIZE);
+                /* G goes to end of drive */
+                put_partition(state, slot++, XBOX_EXTEND_G_START,
+                    disk_size - XBOX_EXTEND_G_START);
+             } else {
+             /* use NKPatcher06 style F drive */
+                put_partition(state, slot++, XBOX_EXTEND_F_START,
+                    disk_size - XBOX_EXTEND_F_START);
+             }
+        } else {
+        /* Just a large F on this system - to end of drive*/
+            put_partition(state, slot++, XBOX_EXTEND_F_START,
+                disk_size - XBOX_EXTEND_F_START);
+        }
+    }
+
+out:
+    printk("\n");
+    return 1;
+}
diff -uprN a/fs/partitions/xbox.h b/fs/partitions/xbox.h
--- a/fs/partitions/xbox.h	1970-01-01 01:00:00.000000000 +0100
+++ b/fs/partitions/xbox.h	2007-10-12 11:17:00.000000000 +0100
@@ -0,0 +1,6 @@
+/*
+ *  fs/partitions/xbox.h
+ */
+
+int xbox_partition(struct parsed_partitions *state,
+			struct block_device *bdev);
diff -uprN a/include/asm-i386/mach-default/mach_pci_blacklist.h b/include/asm-i386/mach-default/mach_pci_blacklist.h
--- a/include/asm-i386/mach-default/mach_pci_blacklist.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/asm-i386/mach-default/mach_pci_blacklist.h	2007-10-12 11:17:01.000000000 +0100
@@ -0,0 +1,6 @@
+#ifndef __ASM_MACH_PCI_BLACKLIST_H
+#define __ASM_MACH_PCI_BLACKLIST_H
+
+#define mach_pci_is_blacklisted(bus,dev,fn) 0
+
+#endif
diff -uprN a/include/asm-i386/mach-xbox/mach_pci_blacklist.h b/include/asm-i386/mach-xbox/mach_pci_blacklist.h
--- a/include/asm-i386/mach-xbox/mach_pci_blacklist.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/asm-i386/mach-xbox/mach_pci_blacklist.h	2007-10-12 11:17:01.000000000 +0100
@@ -0,0 +1,10 @@
+#ifndef __ASM_MACH_PCI_BLACKLIST_H
+#define __ASM_MACH_PCI_BLACKLIST_H
+
+static inline int mach_pci_is_blacklisted(int bus, int dev, int fn)
+{
+	return (bus > 1) || ((bus != 0) && ((dev != 0) || (fn != 0))) ||
+		(!bus && !dev && ((fn == 1) || (fn == 2)));
+}
+
+#endif
diff -uprN a/include/asm-i386/mach-xbox/setup_arch.h b/include/asm-i386/mach-xbox/setup_arch.h
--- a/include/asm-i386/mach-xbox/setup_arch.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/asm-i386/mach-xbox/setup_arch.h	2007-10-12 11:17:01.000000000 +0100
@@ -0,0 +1,26 @@
+#ifndef _SETUP_PRE_XBOX_
+#define _SETUP_PRE_XBOX_
+
+/* Hook to call BIOS initialisation function */
+
+/* no action for generic */
+
+#define ARCH_SETUP arch_setup_xbox();
+
+#include <linux/timex.h>
+#include <asm/io.h>
+
+//int CLOCK_TICK_RATE;
+int machine_is_xbox = 0;
+
+static  inline void arch_setup_xbox(void) {
+	outl(0x80000000, 0xcf8);
+	if (inl(0xcfc)==0x02a510de) { /* Xbox PCI 0:0:0 ID 0x10de/0x02a5 */
+		machine_is_xbox = 1;
+//		CLOCK_TICK_RATE = 1125000;
+	} else {
+//		CLOCK_TICK_RATE = 1193180;
+	}
+}
+
+#endif
diff -uprN a/include/asm-i386/timex.h b/include/asm-i386/timex.h
--- a/include/asm-i386/timex.h	2007-07-09 00:32:17.000000000 +0100
+++ b/include/asm-i386/timex.h	2007-10-12 11:17:01.000000000 +0100
@@ -11,6 +11,8 @@
 
 #ifdef CONFIG_X86_ELAN
 #  define CLOCK_TICK_RATE 1189200 /* AMD Elan has different frequency! */
+#elif defined(CONFIG_X86_XBOX)
+#  define CLOCK_TICK_RATE 1125000 /* So does the Xbox */
 #else
 #  define CLOCK_TICK_RATE 1193182 /* Underlying HZ */
 #endif
diff -uprN a/include/linux/fatx_fs.h b/include/linux/fatx_fs.h
--- a/include/linux/fatx_fs.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/linux/fatx_fs.h	2007-10-12 11:17:01.000000000 +0100
@@ -0,0 +1,306 @@
+#ifndef _LINUX_FATX_FS_H
+#define _LINUX_FATX_FS_H
+
+/*
+ * The MS-DOS filesystem constants/structures
+ */
+#include <asm/byteorder.h>
+
+#define SECTOR_SIZE	512		/* sector size (bytes) */
+#define SECTOR_BITS	9		/* log2(SECTOR_SIZE) */
+#define FATX_DPB	(FATX_DPS)	/* dir entries per block */
+#define FATX_DPB_BITS	4		/* log2(FATX_DPB) */
+#define FATX_DPS	(SECTOR_SIZE / sizeof(struct fatx_dir_entry))
+#define FATX_DPS_BITS	4		/* log2(FATX_DPS) */
+#define CF_LE_W(v)	le16_to_cpu(v)
+#define CF_LE_L(v)	le32_to_cpu(v)
+#define CT_LE_W(v)	cpu_to_le16(v)
+#define CT_LE_L(v)	cpu_to_le32(v)
+
+
+#define FATX_SUPER_MAGIC cpu_to_le32(0x58544146)
+
+#define FATX32_MAX_NON_LFS     ((1UL<<32) - 1)
+#define FATX16_MAX_NON_LFS     ((1UL<<30) - 1)
+
+#define CLUSTER_SIZE            32
+#define FATX_ROOT_INO	1	/* == MINIX_ROOT_INO */
+#define FATX_DIR_BITS	6	/* log2(sizeof(struct fatx_dir_entry)) */
+
+/* directory limit */
+//#define FAT_MAX_DIR_ENTRIES	(65536)
+//#define FAT_MAX_DIR_SIZE	(FAT_MAX_DIR_ENTRIES << FATX_DIR_BITS)
+
+#define ATTR_NONE	0	/* no attribute bits */
+#define ATTR_RO		1	/* read-only */
+#define ATTR_HIDDEN	2	/* hidden */
+#define ATTR_SYS	4	/* system */
+#define ATTR_DIR	16	/* directory */
+#define ATTR_ARCH	32	/* archived */
+
+/* attribute bits that are copied "as is" */
+#define ATTR_UNUSED	(ATTR_ARCH | ATTR_SYS | ATTR_HIDDEN)
+/* bits that are used by the Windows 95/Windows NT extended FAT */
+#define ATTR_EXT	(ATTR_RO | ATTR_HIDDEN | ATTR_SYS)
+
+#define CASE_LOWER_BASE	8	/* base is lower case */
+#define CASE_LOWER_EXT	16	/* extension is lower case */
+
+#define DELETED_FLAG	0xe5	/* marks file as deleted when in name[0] */
+#define FATX_IS_FREE(de) (((de)->name_length==DELETED_FLAG || (de)->name_length==0xFF))
+#define FATX_END_OF_DIR(n) ((n)->name_length==0xFF)
+#define IS_FREE(de) ((de)->name_length==DELETED_FLAG)
+//#define IS_FREE(n)	(!*(n) || *(n) == DELETED_FLAG)
+
+/* directory limit */
+#define FATX_MAX_DIR_ENTRIES	(256)
+#define FATX_MAX_DIR_SIZE	(FATX_MAX_DIR_ENTRIES << FATX_DIR_BITS)
+
+/* valid file mode bits */
+#define FATX_VALID_MODE (S_IFREG | S_IFDIR | S_IRWXU | S_IRWXG | S_IRWXO)
+/* Convert attribute bits and a mask to the UNIX mode. */
+#define FATX_MKMODE(a, m) (m & (a & ATTR_RO ? S_IRUGO|S_IXUGO : S_IRWXUGO))
+
+#define FATX_NAME	42	/* maximum name length */
+
+/* start of data cluster's entry (number of reserved clusters) */
+#define FAT_START_ENT	2
+
+/* bad cluster mark */
+#define BAD_FAT16	0xFFF7
+#define BAD_FAT32	0xFFFFFFF7
+
+/* standard EOF */
+#define EOF_FAT16	0xFFFF
+#define EOF_FAT32	0xFFFFFFFF
+
+#define FAT_ENT_FREE	(0)
+#define FAT_ENT_BAD	(BAD_FAT32)
+#define FAT_ENT_EOF	(EOF_FAT32)
+
+struct fatx_boot_sector {
+        __u32	magic;		/* "FATX" */
+	__u32	volume_id;	/* Volume ID */
+        __u32	cluster_size;	/* sectors/cluster */
+	__u16	fats;		/* number of FATs */
+	__u32	unknown;
+};
+
+struct fatx_dir_entry {
+	__u8    name_length;    /* length of filename (bytes) */
+	__u8    attr;           /* attribute bits */
+	__u8    name[FATX_NAME];       /* filename */
+	__u32   start;          /* first cluster */
+	__u32   size;           /* file size (in bytes) */
+	__u16   time,date;      /* time, date */
+	__u16   ctime,cdate;    /* Creation time */
+	__u16   atime,adate;    /* Last access time */
+};
+
+struct fatx_slot_info {
+	loff_t i_pos;		/* on-disk position of directory entry */
+	loff_t slot_off;	/* offset for slot or de start */
+	struct fatx_dir_entry *de;
+	struct buffer_head *bh;
+};
+
+#ifdef __KERNEL__
+
+#include <linux/buffer_head.h>
+#include <linux/string.h>
+#include <linux/nls.h>
+#include <linux/fs.h>
+
+struct fatx_mount_options {
+	uid_t fs_uid;
+	gid_t fs_gid;
+	unsigned short fs_fmask;
+	unsigned short fs_dmask;
+	unsigned short codepage;  /* Codepage for shortname conversions */
+	char *iocharset;          /* Charset used for filename input/display */
+	unsigned quiet:1;         /* set = fake successful chmods and chowns */
+};
+
+#define FAT_HASH_BITS	8
+#define FAT_HASH_SIZE	(1UL << FAT_HASH_BITS)
+#define FAT_HASH_MASK	(FAT_HASH_SIZE-1)
+
+/*
+ * MS-DOS file system in-core superblock data
+ */
+struct fatx_sb_info {
+	unsigned short sec_per_clus; /* sectors/cluster */
+	unsigned short cluster_bits; /* log2(cluster_size) */
+	unsigned int cluster_size;   /* cluster size */
+	unsigned char fatxs,fatx_bits; /* number of FATs, FAT bits (16 or 32) */
+	unsigned short fatx_start;
+	unsigned long fatx_length;    /* FAT start & length (sec.) */
+	unsigned long dir_start;
+	unsigned short dir_entries;  /* root dir start & entries */
+	unsigned long data_start;    /* first data sector */
+	unsigned long max_cluster;   /* maximum cluster number */
+	unsigned long root_cluster;  /* first cluster of the root directory */
+	unsigned long fsinfo_sector; /* sector number of FAT32 fsinfo */
+	struct semaphore fatx_lock;
+	unsigned int prev_free;      /* previously allocated cluster number */
+	unsigned int free_clusters;  /* -1 if undefined */
+	struct fatx_mount_options options;
+	struct nls_table *nls_disk;  /* Codepage used on disk */
+	struct nls_table *nls_io;    /* Charset used for input and display */
+	void *dir_ops;		     /* Opaque; default directory operations */
+	int dir_per_block;	     /* dir entries per block */
+	int dir_per_block_bits;	     /* log2(dir_per_block) */
+
+	int fatxent_shift;
+	struct fatxent_operations *fatxent_ops;
+
+	spinlock_t inode_hash_lock;
+	struct hlist_head inode_hashtable[FAT_HASH_SIZE];
+};
+
+#define FAT_CACHE_VALID	0	/* special case for valid cache */
+
+/*
+ * MS-DOS file system inode data in memory
+ */
+struct fatx_inode_info {
+	spinlock_t cache_lru_lock;
+	struct list_head cache_lru;
+	int nr_caches;
+	/* for avoiding the race between fatx_free() and fatx_get_cluster() */
+	unsigned int cache_valid_id;
+
+	loff_t mmu_private;
+	int i_start;		/* first cluster or 0 */
+	int i_logstart;		/* logical first cluster */
+	int i_attrs;		/* unused attribute bits */
+	int i_ctime_ms;         /* unused change time in milliseconds */
+	loff_t i_pos;		/* on-disk position of directory entry or 0 */
+	struct hlist_node i_fatx_hash;	/* hash by i_location */
+	struct inode vfs_inode;
+};
+
+static inline struct fatx_sb_info *FATX_SB(struct super_block *sb)
+{
+	return sb->s_fs_info;
+}
+
+static inline struct fatx_inode_info *FATX_I(struct inode *inode)
+{
+	return container_of(inode, struct fatx_inode_info, vfs_inode);
+}
+
+/* Return the FAT attribute byte for this inode */
+static inline u8 fatx_attr(struct inode *inode)
+{
+	return ((inode->i_mode & S_IWUGO) ? ATTR_NONE : ATTR_RO) |
+		(S_ISDIR(inode->i_mode) ? ATTR_DIR : ATTR_NONE) |
+		FATX_I(inode)->i_attrs;
+}
+
+static inline sector_t fatx_clus_to_blknr(struct fatx_sb_info *sbi, __s64 clus)
+{
+	return ((sector_t)clus - FAT_START_ENT) * sbi->sec_per_clus
+		+ sbi->data_start;
+}
+
+/* fatx/cache.c */
+extern void fatx_cache_inval_inode(struct inode *inode);
+extern __s64 fatx_get_cluster(struct inode *inode, __s64 cluster,
+			   int *fclus, int *dclus);
+extern int fatx_bmap(struct inode *inode, sector_t sector, sector_t *phys);
+
+/* fatx/dir.c */
+extern struct file_operations fatx_dir_operations;
+extern int fatx_search_long(struct inode *inode, const unsigned char *name,
+			   int name_len, struct fatx_slot_info *sinfo);
+extern int fatx_dir_empty(struct inode *dir);
+extern int fatx_subdirs(struct inode *dir);
+extern int fatx_scan(struct inode *dir, const unsigned char *name,
+		    struct fatx_slot_info *sinfo);
+extern int fatx_get_dotdot_entry(struct inode *dir, struct buffer_head **bh,
+				struct fatx_dir_entry **de, loff_t *i_pos);
+extern int fatx_alloc_new_dir(struct inode *dir, struct timespec *ts);
+extern int fatx_add_entries(struct inode *dir, void *slots, struct fatx_slot_info *sinfo);
+extern int fatx_remove_entries(struct inode *dir, struct fatx_slot_info *sinfo);
+
+/* fatx/fatxent.c */
+struct fatx_entry {
+	int entry;
+	union {
+		__le16 *ent16_p;
+		__u32 *ent32_p;
+	} u;
+	int nr_bhs;
+	struct buffer_head *bhs[2];
+};
+
+static inline void fatxent_init(struct fatx_entry *fatxent)
+{
+	fatxent->nr_bhs = 0;
+	fatxent->entry = 0;
+	fatxent->u.ent32_p = NULL;
+	fatxent->bhs[0] = fatxent->bhs[1] = NULL;
+}
+
+static inline void fatxent_set_entry(struct fatx_entry *fatxent, int entry)
+{
+	fatxent->entry = entry;
+	fatxent->u.ent32_p = NULL;
+}
+
+static inline void fatxent_brelse(struct fatx_entry *fatxent)
+{
+	int i;
+	fatxent->u.ent32_p = NULL;
+	for (i = 0; i < fatxent->nr_bhs; i++)
+		brelse(fatxent->bhs[i]);
+	fatxent->nr_bhs = 0;
+	fatxent->bhs[0] = fatxent->bhs[1] = NULL;
+}
+
+extern void fatx_ent_access_init(struct super_block *sb);
+extern __s64 fatx_ent_read(struct inode *inode, struct fatx_entry *fatxent,
+			__s64 entry);
+extern int fatx_ent_write(struct inode *inode, struct fatx_entry *fatxent,
+			 __s64 new, int wait);
+extern __s64 fatx_alloc_clusters(struct inode *inode, __s64 *cluster,
+			      int nr_cluster);
+extern __s64 fatx_free_clusters(struct inode *inode, __s64 cluster);
+extern __s64 fatx_count_free_clusters(struct super_block *sb);
+
+/* fatx/file.c */
+extern int fatx_generic_ioctl(struct inode *inode, struct file *filp,
+			     unsigned int cmd, unsigned long arg);
+extern struct file_operations fatx_file_operations;
+extern struct inode_operations fatx_file_inode_operations;
+extern int fatx_notify_change(struct dentry * dentry, struct iattr * attr);
+extern void fatx_truncate(struct inode *inode);
+
+/* fatx/inode.c */
+extern void fatx_attach(struct inode *inode, loff_t i_pos);
+extern void fatx_detach(struct inode *inode);
+extern struct inode *fatx_iget(struct super_block *sb, loff_t i_pos);
+extern struct inode *fatx_build_inode(struct super_block *sb,
+			struct fatx_dir_entry *de, loff_t i_pos);
+extern int fatx_sync_inode(struct inode *inode);
+extern int fatx_fill_super_inode(struct super_block *sb, void *data, int silent,
+			struct inode_operations *fs_dir_inode_ops);
+extern unsigned int fatx_debug;
+
+/* fatx/misc.c */
+extern void fatx_fs_panic(struct super_block *s, const char *fmt, ...);
+extern __s64 fatx_chain_add(struct inode *inode, int new_dclus, int nr_cluster);
+extern int fatx_date_dos2unix(unsigned short time, unsigned short date);
+extern void fatx_date_unix2dos(int unix_date, __le16 *time, __le16 *date);
+extern int fatx_sync_bhs(struct buffer_head **bhs, int nr_bhs);
+
+/* fatx/namei.c */
+extern void fatx_printname(const char *name, int length);
+extern int fatx_get_sb(struct file_system_type *fs_type,
+                       int flags, const char *dev_name,
+                       void *data, struct vfsmount *mnt);
+
+#endif /* __KERNEL__ */
+
+#endif
diff -uprN a/include/linux/xbox.h b/include/linux/xbox.h
--- a/include/linux/xbox.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/linux/xbox.h	2007-10-12 11:17:01.000000000 +0100
@@ -0,0 +1,135 @@
+#ifndef _XBOX_H_
+#define _XBOX_H_
+
+#define XBOX_SMB_IO_BASE 0xC000
+#define XBOX_SMB_HOST_ADDRESS       (0x4 + XBOX_SMB_IO_BASE)
+#define XBOX_SMB_HOST_COMMAND       (0x8 + XBOX_SMB_IO_BASE)
+#define XBOX_SMB_HOST_DATA          (0x6 + XBOX_SMB_IO_BASE)
+#define XBOX_SMB_GLOBAL_ENABLE       (0x2 + XBOX_SMB_IO_BASE)
+#define XBOX_GE_CYC_TYPE_MASK (7)
+#define XBOX_BYTE_DATA    0x02
+
+#define XBOX_SMC_ADDRESS 0x10
+#define XBOX_TV_ADDRESS 0x45
+
+#define SMC_CMD_POWER 0x02
+#define SMC_CMD_TRAY_STATE 0x03
+#define SMC_CMD_AV_PACK 0x04
+#define SMC_CMD_LED_MODE 0x07
+#define SMC_CMD_LED_REGISTER 0x08
+#define SMC_CMD_EJECT 0x0C
+#define SMC_CMD_INTERRUPT_RESPOND 0x0D
+#define SMC_CMD_INTERRUPT_REASON 0x11
+#define SMC_CMD_RESET_ON_EJECT 0x19
+#define SMC_CMD_SCRATCH_REGISTER 0x1B
+// I think commands 20 and 21 are used for bootup authentication, but
+// I don't know those commands.  The CROM people know.
+//
+#define SMC_SUBCMD_POWER_RESET 0x01
+#define SMC_SUBCMD_POWER_CYCLE 0x40
+#define SMC_SUBCMD_POWER_OFF 0x80
+//
+#define SMC_SUBCMD_RESPOND_CONTINUE 0x04
+//
+// These are from recent posts to this list (except MISSING)
+#define SMC_VALUE_AV_SCART 0x00
+#define SMC_VALUE_AV_HDTV 0x01
+#define SMC_VALUE_AV_VGA 0x02
+#define SMC_VALUE_AV_RFU 0x03
+#define SMC_VALUE_AV_SVIDEO 0x04
+#define SMC_VALUE_AV_STANDARD 0x06
+#define SMC_VALUE_AV_UNDEFINED 0x05
+#define SMC_VALUE_AV_MISSING 0x07
+//
+#define SMC_SUBCMD_LED_MODE_DEFAULT 0x00
+#define SMC_SUBCMD_LED_MODE_CUSTOM 0x01
+
+#define SMC_SUBCMD_EJECT_EJECT 0x00
+#define SMC_SUBCMD_EJECT_LOAD 0x01
+
+// Bits 01...40 all have meaning but I don't know them all.
+#define SMC_VALUE_INTERRUPT_POWER_BUTTON 0x01
+#define SMC_VALUE_INTERRUPT_AV_REMOVED 0x10
+#define SMC_VALUE_INTERRUPT_EJECT_BUTTON 0x20
+
+#define SMC_SUBCMD_RESET_ON_EJECT_ENABLE 0x00
+#define SMC_SUBCMD_RESET_ON_EJECT_DISABLE 0x01
+
+// These are defined by the *kernel*, not the SMC.
+#define SMC_SCRATCH_EJECT_AFTER_BOOT 0x01
+#define SMC_SCRATCH_DISPLAY_ERROR 0x02
+#define SMC_SCRATCH_NO_ANIMATION 0x04
+#define SMC_SCRATCH_RUN_DASHBOARD 0x08
+
+/* interrupt causes */
+#define POWERDOWN_MASK (1<<0)
+#define TRAYCLOSED_MASK (1<<1)
+#define TRAYOPENING_MASK (1<<2)
+#define AVPLUGGED_MASK (1<<3)
+#define AVUNPLUGGED_MASK (1<<4)
+#define TRAYBUTTON_MASK (1<<5)
+#define TRAYCLOSING_MASK (1<<6)
+#define UNKNOWN_MASK (1<<7)
+
+extern int machine_is_xbox;
+
+#define XBOX_I2C_IO_BASE 0xc000
+static inline void Xbox_SMC_write(u8 d1,u8 d2) {
+	int c=4;
+	u8 b=0;
+	u32 dwSpinsToLive = 0x8000000;
+
+	/*
+	while(inw(XBOX_I2C_IO_BASE+0)&0x0800);
+	*/
+	while(c--) {
+		outb(XBOX_SMC_ADDRESS<<1, XBOX_SMB_HOST_ADDRESS);
+		outb((u8)d1, XBOX_SMB_HOST_COMMAND);
+		outb((u8)d2, XBOX_SMB_HOST_DATA);
+		outw(0xffff, XBOX_I2C_IO_BASE+0);
+		outb(0x0a, XBOX_SMB_GLOBAL_ENABLE);
+		{
+			while((b !=0x10) && ((b&0x26)==0) && (dwSpinsToLive--)) {
+				b=inb(XBOX_I2C_IO_BASE);
+			}
+			if(b&0x2) continue;
+			if(b&0x24) continue;
+			if(!(b&0x10)) continue;
+			break;
+		}
+	}
+}
+
+static inline int Xbox_SMC_read(u8 d) {
+        int c=4;
+	u8 b=0;
+	u32 dwSpinsToLive = 0x8000000;
+	
+	/*
+	while(inw(XBOX_I2C_IO_BASE+0)&0x0800);
+	*/
+        while(c--) {
+		outb((XBOX_SMC_ADDRESS<<1)|1, XBOX_SMB_HOST_ADDRESS);
+                outb(d, XBOX_SMB_HOST_COMMAND);
+                outw(0xffff, XBOX_I2C_IO_BASE+0);
+                outb(0x0a, XBOX_SMB_GLOBAL_ENABLE);
+		{
+			while((b !=0x10) && ((b&0x26)==0) && (dwSpinsToLive--)) {
+				b=inb(XBOX_I2C_IO_BASE);
+			}
+			if(b&0x2) continue;
+			if(b&0x24) continue;
+			if(!(b&0x10)) continue;
+			break;	
+		}
+	}
+	return (int)inb(XBOX_SMB_HOST_DATA);
+}
+
+#define Xbox_tray_load() Xbox_SMC_write(SMC_CMD_EJECT, SMC_SUBCMD_EJECT_LOAD);
+#define Xbox_tray_eject() Xbox_SMC_write(SMC_CMD_EJECT, SMC_SUBCMD_EJECT_EJECT);
+
+#define Xbox_power_off() Xbox_SMC_write(SMC_CMD_POWER, SMC_SUBCMD_POWER_OFF);
+#define Xbox_reset() Xbox_SMC_write(SMC_CMD_POWER, SMC_SUBCMD_POWER_RESET);
+
+#endif /* _XBOX_H_ */
diff -uprN a/include/linux/xboxfbctl.h b/include/linux/xboxfbctl.h
--- a/include/linux/xboxfbctl.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/linux/xboxfbctl.h	2007-10-12 11:17:01.000000000 +0100
@@ -0,0 +1,67 @@
+/*
+ * linux/include/video/xboxfbctl.h
+ * - Type definitions for ioctls of Xbox video driver
+ *
+ * Maintainer: Oliver Schwartz <Oliver.Schwartz@gmx.de>
+ *
+ * Contributors:
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * Known bugs and issues:
+ *
+ *      none
+ */
+
+#ifndef xbofbctl_h
+#define xbofbctl_h
+
+typedef enum enumVideoStandards {
+	TV_ENC_INVALID=-1,
+	TV_ENC_NTSC=0,
+	TV_ENC_NTSC60,
+	TV_ENC_PALBDGHI,
+	TV_ENC_PALN,
+	TV_ENC_PALNC,
+	TV_ENC_PALM,
+	TV_ENC_PAL60
+} xbox_tv_encoding;
+
+typedef enum enumAvTypes {
+	AV_INVALID=-1,
+	AV_SCART_RGB,
+	AV_SVIDEO,
+	AV_VGA_SOG,
+	AV_HDTV,
+	AV_COMPOSITE,
+	AV_VGA
+} xbox_av_type;
+
+typedef enum enumEncoderType {
+	ENCODER_CONEXANT,
+	ENCODER_FOCUS,
+	ENCODER_XCALIBUR
+} xbox_encoder_type;
+
+typedef struct _xboxOverscan {
+	double hoc;
+	double voc;
+} xbox_overscan;
+
+typedef struct _xboxFbConfig {
+	xbox_av_type av_type;
+	xbox_encoder_type encoder_type;
+} xboxfb_config;
+
+#define FBIO_XBOX_GET_OVERSCAN  _IOR('x', 1, xbox_overscan)
+/* in param: double  hoc (0.0-0.2), double voc (0.0 - 0.2) */
+#define FBIO_XBOX_SET_OVERSCAN  _IOW('x', 2, xbox_overscan)
+
+#define FBIO_XBOX_GET_TV_ENCODING  _IOR('x', 3, xbox_tv_encoding)
+#define FBIO_XBOX_SET_TV_ENCODING  _IOW('x', 4, xbox_tv_encoding)
+
+#define FBIO_XBOX_GET_CONFIG  _IOR('x', 5, xboxfb_config)
+
+#endif
diff -uprN a/sound/pci/ac97/ac97_codec.c b/sound/pci/ac97/ac97_codec.c
--- a/sound/pci/ac97/ac97_codec.c	2007-07-09 00:32:17.000000000 +0100
+++ b/sound/pci/ac97/ac97_codec.c	2007-10-12 12:15:31.000000000 +0100
@@ -2062,10 +2062,14 @@ int snd_ac97_mixer(struct snd_ac97_bus *
 	
 	/* test for AC'97 */
 	if (!(ac97->scaps & AC97_SCAP_SKIP_AUDIO) && !(ac97->scaps & AC97_SCAP_AUDIO)) {
-		/* test if we can write to the record gain volume register */
-		snd_ac97_write_cache(ac97, AC97_REC_GAIN, 0x8a06);
-		if (((err = snd_ac97_read(ac97, AC97_REC_GAIN)) & 0x7fff) == 0x0a06)
-			ac97->scaps |= AC97_SCAP_AUDIO;
+ 		if ((ac97->scaps & AC97_SCAP_DETECT_BY_VENDOR)) {
+  			ac97->scaps |= AC97_SCAP_AUDIO;
+ 		} else {
+ 			/* test if we can write to the record gain volume register */
+ 			snd_ac97_write_cache(ac97, AC97_REC_GAIN, 0x8a06);
+ 			if (((err = snd_ac97_read(ac97, AC97_REC_GAIN)) & 0x7fff) == 0x0a06)
+ 				ac97->scaps |= AC97_SCAP_AUDIO;
+ 		}
 	}
 	if (ac97->scaps & AC97_SCAP_AUDIO) {
 		ac97->caps = snd_ac97_read(ac97, AC97_RESET);
diff -uprN a/sound/usb/usbquirks.h b/sound/usb/usbquirks.h
--- a/sound/usb/usbquirks.h	2007-07-09 00:32:17.000000000 +0100
+++ b/sound/usb/usbquirks.h	2007-10-12 13:07:10.000000000 +0100
@@ -1704,4 +1704,79 @@ YAMAHA_DEVICE(0x7010, "UB99"),
 	}
 },
 
+{	/*
+	 * This quirk is for the Xbox Communicator
+	 * please NOTE:
+	 *
+	 *  THIS HAS _NOT_ BEEN TESTED THOROUGHLY!
+	 *
+	 *  IT IS REALLY JUST SOME COPY&PASTE FROM ABOVE.
+	 *  You have been warned.
+	 *
+	 *  In fact, I managed to kinda crash it and the Xbox hung while
+	 *   cleaning up alsa on shutdown.
+	 *
+	 * What worked was to cat <file> > /dev/dsp and get static
+	 *  on the headset. Getting Mplayer to output sound did not work
+	 *  for me (no music files and therefore no extensive tests, though).
+	 * Also I had no luck with the mic, mixer said it "found no elements".
+	 *
+	 * If you wanna try, go ahead and report to xbox-linux.org (ML, IRC)
+	 *
+	 * Marko Friedemann <mfr@bmx-chemnitz.de>
+	 */
+	USB_DEVICE(0x045e, 0x0283),
+	.driver_info = (unsigned long) & (const struct snd_usb_audio_quirk) {
+		.vendor_name = "Microsoft",
+		.product_name = "Xbox Communicator",
+		.ifnum = QUIRK_ANY_INTERFACE,
+		.type = QUIRK_COMPOSITE,
+		.data = & (const struct snd_usb_audio_quirk[]) {
+			{
+				.ifnum = 0,
+				.type = QUIRK_AUDIO_FIXED_ENDPOINT,
+				.data = & (const struct audioformat) {
+					/* these might as well be wrong */
+					.format = SNDRV_PCM_FORMAT_S16_LE,
+					/* same for these */
+					.channels = 1,
+					.iface = 0,
+					.altsetting = 0,
+					.altset_idx = 0,
+					.attributes = 0,
+					.endpoint = 0x04,
+					.ep_attr = 0x05,
+					/* and those */
+					.rates = SNDRV_PCM_RATE_CONTINUOUS,
+					.rate_min = 44100,
+					.rate_max = 44100,
+				}
+			},
+			{
+				.ifnum = 1,
+				.type = QUIRK_AUDIO_FIXED_ENDPOINT,
+				.data = & (const struct audioformat) {
+					/* these might as well be wrong */
+					.format = SNDRV_PCM_FORMAT_S16_LE,
+					/* same for these */
+					.channels = 1,
+					.iface = 1,
+					.altsetting = 0,
+					.altset_idx = 0,
+					.attributes = 0,
+					.endpoint = 0x85,
+					.ep_attr = 0x05,
+					/* and those */
+					.rates = SNDRV_PCM_RATE_CONTINUOUS,
+					.rate_min = 44100,
+					.rate_max = 44100,
+				}
+			},
+			{
+				.ifnum = -1
+			}
+		}
+	}
+},
+
 #undef USB_DEVICE_VENDOR_SPEC
